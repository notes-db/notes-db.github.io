import {
  markdown,
  markdownLanguage
} from "./chunk-YZO6KLOE.js";
import "./chunk-HR3ZU7JS.js";
import "./chunk-NRD5HGHM.js";
import "./chunk-E3BFFCFD.js";
import {
  autocompletion,
  closeBrackets
} from "./chunk-E7JABJM2.js";
import {
  Annotation,
  ChangeDesc,
  ChangeSet,
  CharCategory,
  Compartment,
  Decoration,
  Direction,
  EditorSelection,
  EditorState,
  EditorView,
  Facet,
  HighlightStyle,
  IndentContext,
  LanguageDescription,
  LanguageSupport,
  MapMode,
  NodeProp,
  Prec,
  RangeSet,
  RangeSetBuilder,
  SelectionRange,
  StateEffect,
  StateField,
  StreamLanguage,
  StringStream,
  Text,
  Transaction,
  ViewPlugin,
  WidgetType,
  codePointAt,
  codePointSize,
  combineConfig,
  countColumn,
  ensureSyntaxTree,
  findClusterBreak,
  foldCode,
  fromCodePoint,
  getIndentUnit,
  getIndentation,
  getPanel,
  indentString,
  indentUnit,
  keymap,
  matchBrackets,
  runScopeHandlers,
  showPanel,
  syntaxHighlighting,
  syntaxTree,
  tags
} from "./chunk-T6PZNUWD.js";
import "./chunk-6VKAD5OU.js";
import {
  createElementBlock,
  defineComponent,
  openBlock
} from "./chunk-Y5TCTR67.js";
import {
  __publicField
} from "./chunk-THBTSZW5.js";

// node_modules/solid-js/dist/dev.js
var sharedConfig = {};
function setHydrateContext(context) {
  sharedConfig.context = context;
}
function nextHydrateContext() {
  return {
    ...sharedConfig.context,
    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,
    count: 0
  };
}
var equalFn = (a, b) => a === b;
var $PROXY = Symbol("solid-proxy");
var $TRACK = Symbol("solid-track");
var $DEVCOMP = Symbol("solid-dev-component");
var signalOptions = {
  equals: equalFn
};
var ERROR = null;
var runEffects = runQueue;
var NOTPENDING = {};
var STALE = 1;
var PENDING = 2;
var UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var [transPending, setTransPending] = createSignal(false);
var Owner = null;
var Transition = null;
var Scheduler = null;
var ExternalSourceFactory = null;
var Listener = null;
var Pending = null;
var Updates = null;
var Effects = null;
var ExecCount = 0;
var rootCount = 0;
function createRoot(fn2, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn2.length === 0, root = unowned && false ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: null,
    owner: detachedOwner || owner
  }, updateFn = unowned ? () => fn2(() => {
    throw new Error("Dispose method must be an explicit argument to createRoot function");
  }) : () => fn2(() => cleanNode(root));
  {
    if (owner)
      root.name = `${owner.name}-r${rootCount++}`;
    globalThis._$afterCreateRoot && globalThis._$afterCreateRoot(root);
  }
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value,
    observers: null,
    observerSlots: null,
    pending: NOTPENDING,
    comparator: options.equals || void 0
  };
  if (!options.internal)
    s.name = registerGraph(options.name || hashValue(value), s);
  const setter = (value2) => {
    if (typeof value2 === "function") {
      if (Transition && Transition.running && Transition.sources.has(s))
        value2 = value2(s.pending !== NOTPENDING ? s.pending : s.tValue);
      else
        value2 = value2(s.pending !== NOTPENDING ? s.pending : s.value);
    }
    return writeSignal(s, value2);
  };
  return [readSignal.bind(s), setter];
}
function createComputed(fn2, value, options) {
  const c = createComputation(fn2, value, true, STALE, options);
  if (Scheduler && Transition && Transition.running)
    Updates.push(c);
  else
    updateComputation(c);
}
function createRenderEffect(fn2, value, options) {
  const c = createComputation(fn2, value, false, STALE, options);
  if (Scheduler && Transition && Transition.running)
    Updates.push(c);
  else
    updateComputation(c);
}
function createEffect(fn2, value, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn2, value, false, STALE, options), s = SuspenseContext && lookup(Owner, SuspenseContext.id);
  if (s)
    c.suspense = s;
  c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn2, value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn2, value, true, 0, options);
  c.pending = NOTPENDING;
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  if (Scheduler && Transition && Transition.running) {
    c.tState = STALE;
    Updates.push(c);
  } else
    updateComputation(c);
  return readSignal.bind(c);
}
function batch(fn2) {
  if (Pending)
    return fn2();
  let result;
  const q = Pending = [];
  try {
    result = fn2();
  } finally {
    Pending = null;
  }
  runUpdates(() => {
    for (let i = 0; i < q.length; i += 1) {
      const data = q[i];
      if (data.pending !== NOTPENDING) {
        const pending = data.pending;
        data.pending = NOTPENDING;
        writeSignal(data, pending);
      }
    }
  }, false);
  return result;
}
function untrack(fn2) {
  let result, listener = Listener;
  Listener = null;
  result = fn2();
  Listener = listener;
  return result;
}
function onMount(fn2) {
  createEffect(() => untrack(fn2));
}
function onCleanup(fn2) {
  if (Owner === null)
    console.warn("cleanups created outside a `createRoot` or `render` will never be run");
  else if (Owner.cleanups === null)
    Owner.cleanups = [fn2];
  else
    Owner.cleanups.push(fn2);
  return fn2;
}
function startTransition(fn2) {
  if (Transition && Transition.running) {
    fn2();
    return Transition.done;
  }
  const l = Listener;
  const o = Owner;
  return Promise.resolve().then(() => {
    Listener = l;
    Owner = o;
    let t;
    if (Scheduler || SuspenseContext) {
      t = Transition || (Transition = {
        sources: /* @__PURE__ */ new Set(),
        effects: [],
        promises: /* @__PURE__ */ new Set(),
        disposed: /* @__PURE__ */ new Set(),
        queue: /* @__PURE__ */ new Set(),
        running: true
      });
      t.done || (t.done = new Promise((res) => t.resolve = res));
      t.running = true;
    }
    batch(fn2);
    Listener = Owner = null;
    return t ? t.done : void 0;
  });
}
function devComponent(Comp, props) {
  const c = createComputation(() => untrack(() => {
    Object.assign(Comp, {
      [$DEVCOMP]: true
    });
    return Comp(props);
  }), void 0, true);
  c.pending = NOTPENDING;
  c.observers = null;
  c.observerSlots = null;
  c.state = 0;
  c.componentName = Comp.name;
  updateComputation(c);
  return c.tValue !== void 0 ? c.tValue : c.value;
}
function hashValue(v) {
  const s = /* @__PURE__ */ new Set();
  return `s${typeof v === "string" ? hash(v) : hash(JSON.stringify(v, (k2, v2) => {
    if (typeof v2 === "object" && v2 != null) {
      if (s.has(v2))
        return;
      s.add(v2);
      const keys = Object.keys(v2);
      const desc = Object.getOwnPropertyDescriptors(v2);
      const newDesc = keys.reduce((memo, key) => {
        const value = desc[key];
        if (!value.get)
          memo[key] = value;
        return memo;
      }, {});
      v2 = Object.create({}, newDesc);
    }
    if (typeof v2 === "bigint") {
      return `${v2.toString()}n`;
    }
    return v2;
  }) || "")}`;
}
function registerGraph(name, value) {
  let tryName = name;
  if (Owner) {
    let i = 0;
    Owner.sourceMap || (Owner.sourceMap = {});
    while (Owner.sourceMap[tryName])
      tryName = `${name}-${++i}`;
    Owner.sourceMap[tryName] = value;
  }
  return tryName;
}
function serializeGraph(owner) {
  owner || (owner = Owner);
  if (!owner)
    return {};
  return {
    ...serializeValues(owner.sourceMap),
    ...owner.owned ? serializeChildren(owner) : {}
  };
}
function createContext(defaultValue) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id),
    defaultValue
  };
}
function useContext(context) {
  let ctx;
  return (ctx = lookup(Owner, context.id)) !== void 0 ? ctx : context.defaultValue;
}
function children(fn2) {
  const children2 = createMemo(fn2);
  return createMemo(() => resolveChildren(children2()));
}
var SuspenseContext;
function readSignal() {
  const runningTransition = Transition && Transition.running;
  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {
    const updates = Updates;
    Updates = null;
    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);
    Updates = updates;
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  if (runningTransition && Transition.sources.has(this))
    return this.tValue;
  return this.value;
}
function writeSignal(node, value, isComp) {
  if (Pending) {
    if (node.pending === NOTPENDING)
      Pending.push(node);
    node.pending = value;
    return value;
  }
  if (node.comparator) {
    if (Transition && Transition.running && Transition.sources.has(node)) {
      if (node.comparator(node.tValue, value))
        return value;
    } else if (node.comparator(node.value, value))
      return value;
  }
  let TransitionRunning = false;
  if (Transition) {
    TransitionRunning = Transition.running;
    if (TransitionRunning || !isComp && Transition.sources.has(node)) {
      Transition.sources.add(node);
      node.tValue = value;
    }
    if (!TransitionRunning)
      node.value = value;
  } else
    node.value = value;
  if (node.observers && node.observers.length) {
    runUpdates(() => {
      for (let i = 0; i < node.observers.length; i += 1) {
        const o = node.observers[i];
        if (TransitionRunning && Transition.disposed.has(o))
          continue;
        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {
          if (o.pure)
            Updates.push(o);
          else
            Effects.push(o);
          if (o.observers)
            markDownstream(o);
        }
        if (TransitionRunning)
          o.tState = STALE;
        else
          o.state = STALE;
      }
      if (Updates.length > 1e6) {
        Updates = [];
        if ("_SOLID_DEV_")
          throw new Error("Potential Infinite Loop Detected.");
        throw new Error();
      }
    }, false);
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn)
    return;
  cleanNode(node);
  const owner = Owner, listener = Listener, time = ExecCount;
  Listener = Owner = node;
  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
  if (Transition && !Transition.running && Transition.sources.has(node)) {
    queueMicrotask(() => {
      runUpdates(() => {
        Transition && (Transition.running = true);
        runComputation(node, node.tValue, time);
      }, false);
    });
  }
  Listener = listener;
  Owner = owner;
}
function runComputation(node, value, time) {
  let nextValue;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    handleError(err);
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.observers && node.observers.length) {
      writeSignal(node, nextValue, true);
    } else if (Transition && Transition.running && node.pure) {
      Transition.sources.add(node);
      node.tValue = nextValue;
    } else
      node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn2, init, pure, state = STALE, options) {
  const c = {
    fn: fn2,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: null,
    pure
  };
  if (Transition && Transition.running) {
    c.state = 0;
    c.tState = state;
  }
  if (Owner === null)
    console.warn("computations created outside a `createRoot` or `render` will never be disposed");
  else if (Owner !== UNOWNED) {
    if (Transition && Transition.running && Owner.pure) {
      if (!Owner.tOwned)
        Owner.tOwned = [c];
      else
        Owner.tOwned.push(c);
    } else {
      if (!Owner.owned)
        Owner.owned = [c];
      else
        Owner.owned.push(c);
    }
    c.name = options && options.name || `${Owner.name || "c"}-${(Owner.owned || Owner.tOwned).length}`;
  }
  if (ExternalSourceFactory) {
    const [track, trigger] = createSignal(void 0, {
      equals: false
    });
    const ordinary = ExternalSourceFactory(c.fn, trigger);
    onCleanup(() => ordinary.dispose());
    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);
    c.fn = (x) => {
      track();
      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
    };
  }
  return c;
}
function runTop(node) {
  const runningTransition = Transition && Transition.running;
  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0)
    return;
  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING)
    return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback))
    return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (runningTransition && Transition.disposed.has(node))
      return;
    if (!runningTransition && node.state || runningTransition && node.tState)
      ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if (runningTransition) {
      let top = node, prev = ancestors[i + 1];
      while ((top = top.owner) && top !== prev) {
        if (Transition.disposed.has(top))
          return;
      }
    }
    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {
      updateComputation(node);
    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {
      const updates = Updates;
      Updates = null;
      lookUpstream(node, ancestors[0]);
      Updates = updates;
    }
  }
}
function runUpdates(fn2, init) {
  if (Updates)
    return fn2();
  let wait = false;
  if (!init)
    Updates = [];
  if (Effects)
    wait = true;
  else
    Effects = [];
  ExecCount++;
  try {
    const res = fn2();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!Updates)
      Effects = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    if (Scheduler && Transition && Transition.running)
      scheduleQueue(Updates);
    else
      runQueue(Updates);
    Updates = null;
  }
  if (wait)
    return;
  let res;
  if (Transition && Transition.running) {
    if (Transition.promises.size || Transition.queue.size) {
      Transition.running = false;
      Transition.effects.push.apply(Transition.effects, Effects);
      Effects = null;
      setTransPending(true);
      return;
    }
    const sources = Transition.sources;
    const disposed = Transition.disposed;
    res = Transition.resolve;
    for (const e of Effects) {
      "tState" in e && (e.state = e.tState);
      delete e.tState;
    }
    Transition = null;
    batch(() => {
      for (const d2 of disposed)
        cleanNode(d2);
      for (const v of sources) {
        v.value = v.tValue;
        if (v.owned) {
          for (let i = 0, len = v.owned.length; i < len; i++)
            cleanNode(v.owned[i]);
        }
        if (v.tOwned)
          v.owned = v.tOwned;
        delete v.tValue;
        delete v.tOwned;
        v.tState = 0;
      }
      setTransPending(false);
    });
  }
  if (Effects.length)
    batch(() => {
      runEffects(Effects);
      Effects = null;
    });
  else {
    Effects = null;
    globalThis._$afterUpdate && globalThis._$afterUpdate();
  }
  if (res)
    res();
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++)
    runTop(queue[i]);
}
function scheduleQueue(queue) {
  for (let i = 0; i < queue.length; i++) {
    const item = queue[i];
    const tasks = Transition.queue;
    if (!tasks.has(item)) {
      tasks.add(item);
      Scheduler(() => {
        tasks.delete(item);
        runUpdates(() => {
          Transition.running = true;
          runTop(item);
          if (!tasks.size) {
            Effects.push.apply(Effects, Transition.effects);
            Transition.effects = [];
          }
        }, false);
        Transition && (Transition.running = false);
      });
    }
  }
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user)
      runTop(e);
    else
      queue[userLength++] = e;
  }
  if (sharedConfig.context)
    setHydrateContext();
  const resume = queue.length;
  for (i = 0; i < userLength; i++)
    runTop(queue[i]);
  for (i = resume; i < queue.length; i++)
    runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  const runningTransition = Transition && Transition.running;
  if (runningTransition)
    node.tState = 0;
  else
    node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {
        if (source !== ignore)
          runTop(source);
      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING)
        lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  const runningTransition = Transition && Transition.running;
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (!runningTransition && !o.state || runningTransition && !o.tState) {
      if (runningTransition)
        o.tState = PENDING;
      else
        o.state = PENDING;
      if (o.pure)
        Updates.push(o);
      else
        Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (Transition && Transition.running && node.pure) {
    if (node.tOwned) {
      for (i = 0; i < node.tOwned.length; i++)
        cleanNode(node.tOwned[i]);
      delete node.tOwned;
    }
    reset(node, true);
  } else if (node.owned) {
    for (i = 0; i < node.owned.length; i++)
      cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = 0; i < node.cleanups.length; i++)
      node.cleanups[i]();
    node.cleanups = null;
  }
  if (Transition && Transition.running)
    node.tState = 0;
  else
    node.state = 0;
  node.context = null;
  delete node.sourceMap;
}
function reset(node, top) {
  if (!top) {
    node.tState = 0;
    Transition.disposed.add(node);
  }
  if (node.owned) {
    for (let i = 0; i < node.owned.length; i++)
      reset(node.owned[i]);
  }
}
function handleError(err) {
  const fns = ERROR && lookup(Owner, ERROR);
  if (!fns)
    throw err;
  for (const f of fns)
    f(err);
}
function lookup(owner, key) {
  return owner ? owner.context && owner.context[key] !== void 0 ? owner.context[key] : lookup(owner.owner, key) : void 0;
}
function resolveChildren(children2) {
  if (typeof children2 === "function" && !children2.length)
    return resolveChildren(children2());
  if (Array.isArray(children2)) {
    const results = [];
    for (let i = 0; i < children2.length; i++) {
      const result = resolveChildren(children2[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children2;
}
function createProvider(id) {
  return function provider(props) {
    let res;
    createComputed(() => res = untrack(() => {
      Owner.context = {
        [id]: props.value
      };
      return children(() => props.children);
    }));
    return res;
  };
}
function hash(s) {
  for (var i = 0, h3 = 9; i < s.length; )
    h3 = Math.imul(h3 ^ s.charCodeAt(i++), 9 ** 9);
  return `${h3 ^ h3 >>> 9}`;
}
function serializeValues(sources = {}) {
  const k2 = Object.keys(sources);
  const result = {};
  for (let i = 0; i < k2.length; i++) {
    const key = k2[i];
    result[key] = sources[key].value;
  }
  return result;
}
function serializeChildren(root) {
  const result = {};
  for (let i = 0, len = root.owned.length; i < len; i++) {
    const node = root.owned[i];
    result[node.componentName ? `${node.componentName}:${node.name}` : node.name] = {
      ...serializeValues(node.sourceMap),
      ...node.owned ? serializeChildren(node) : {}
    };
  }
  return result;
}
var FALLBACK = Symbol("fallback");
function dispose(d2) {
  for (let i = 0; i < d2.length; i++)
    d2[i]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], i, j;
    newItems[$TRACK];
    return untrack(() => {
      let newLen = newItems.length, newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++)
          ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i = newIndices.get(item);
          newIndicesNext[j] = i === void 0 ? -1 : i;
          newIndices.set(item, j);
        }
        for (i = start; i <= end; i++) {
          item = items[i];
          j = newIndices.get(item);
          if (j !== void 0 && j !== -1) {
            temp[j] = mapped[i];
            tempdisposers[j] = disposers[i];
            indexes && (tempIndexes[j] = indexes[i]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else
            disposers[i]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else
            mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j);
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
var hydrationEnabled = false;
function createComponent(Comp, props) {
  if (hydrationEnabled) {
    if (sharedConfig.context) {
      const c = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      const r = devComponent(Comp, props || {});
      setHydrateContext(c);
      return r;
    }
  }
  return devComponent(Comp, props || {});
}
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : void 0));
}
function Show(props) {
  let strictEqual = false;
  const condition = createMemo(() => props.when, void 0, {
    equals: (a, b) => strictEqual ? a === b : !a === !b
  });
  return createMemo(() => {
    const c = condition();
    if (c) {
      const child = props.children;
      return (strictEqual = typeof child === "function" && child.length > 0) ? untrack(() => child(c)) : child;
    }
    return props.fallback;
  });
}
var SuspenseListContext = createContext();
var DEV;
{
  DEV = {
    writeSignal,
    serializeGraph,
    registerGraph,
    hashValue
  };
}
if (globalThis) {
  if (!globalThis.Solid$$)
    globalThis.Solid$$ = true;
  else
    console.warn("You appear to have multiple instances of Solid. This can lead to unexpected behavior.");
}

// node_modules/crelt/index.es.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string")
    elt = document.createElement(elt);
  var i = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next)
      if (Object.prototype.hasOwnProperty.call(next, name)) {
        var value = next[name];
        if (typeof value == "string")
          elt.setAttribute(name, value);
        else if (value != null)
          elt[name] = value;
      }
    i++;
  }
  for (; i < arguments.length; i++)
    add(elt, arguments[i]);
  return elt;
}
function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++)
      add(elt, child[i]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
var SearchCursor = class {
  constructor(text, query, from = 0, to = text.length, normalize) {
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      for (let i = 0, pos = start; ; i++) {
        let code = norm.charCodeAt(i);
        let match = this.match(code, pos);
        if (match) {
          this.value = match;
          return this;
        }
        if (i == norm.length - 1)
          break;
        if (pos == start && i < str.length && str.charCodeAt(i) == code)
          pos++;
      }
    }
  }
  match(code, pos) {
    let match = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let index = this.matches[i], keep = false;
      if (this.query.charCodeAt(index) == code) {
        if (index == this.query.length - 1) {
          match = { from: this.matches[i + 1], to: pos + 1 };
        } else {
          this.matches[i]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i, 2);
        i -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = { from: pos, to: pos + 1 };
      else
        this.matches.push(1, pos);
    }
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  constructor(text, query, options, from = 0, to = text.length) {
    this.text = text;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  next() {
    for (let off2 = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off2;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        if (from == this.curLine.length)
          this.nextLine();
        if (from < to || from > this.value.to) {
          this.value = { from, to, match };
          return this;
        }
        off2 = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off2 = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc, from, to) {
    let cached = flattened.get(doc);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new FlattenedDoc(from, doc.sliceString(from, to));
      flattened.set(doc, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text = doc.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to)
      text += doc.sliceString(cached.to, to);
    flattened.set(doc, new FlattenedDoc(cachedFrom, text));
    return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options, from, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off2 = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off2) {
        this.re.lastIndex = off2 + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)
        match = null;
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        this.value = { from, to, match };
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        return this;
      } else {
        if (this.flat.to == this.to) {
          this.done = true;
          return this;
        }
        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
      }
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let input = crelt("input", { class: "cm-textfield", name: "line" });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln2, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line = ln2 ? +ln2 : startLine.number;
    if (ln2 && percent) {
      let pc = line / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line = Math.round(state.doc.lines * pc);
    } else if (ln2 && sign) {
      line = line * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
    view.dispatch({
      effects: dialogEffect.of(false),
      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
      scrollIntoView: true
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = StateEffect.define();
var dialogField = StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(dialogEffect))
        value = e.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var baseTheme$1 = EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
var matchDeco = Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
var matchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to).trim();
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor.next().done) {
        let { from, to } = cursor.value;
        if (!check || insideWordBoundaries(check, state, from, to)) {
          if (range.empty && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme = EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var searchConfigFacet = Facet.define({
  combine(configs) {
    var _a;
    return {
      top: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.top, void 0) || false,
      caseSensitive: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.caseSensitive, void 0) || false,
      literal: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.literal, void 0) || false,
      createPanel: ((_a = configs.find((c) => c.createPanel)) === null || _a === void 0 ? void 0 : _a.createPanel) || ((view) => new SearchPanel(view))
    };
  }
});
var SearchQuery = class {
  constructor(config) {
    this.search = config.search;
    this.caseSensitive = !!config.caseSensitive;
    this.literal = !!config.literal;
    this.regexp = !!config.regexp;
    this.replace = config.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.literal ? this.search : this.search.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;
  }
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  getCursor(doc, from = 0, to = doc.length) {
    return this.regexp ? regexpCursor(this, doc, from, to) : stringCursor(this, doc, from, to);
  }
};
var QueryType = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, doc, from, to) {
  return new SearchCursor(doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase());
}
var StringQuery = class extends QueryType {
  constructor(spec) {
    super(spec);
  }
  nextMatch(doc, curFrom, curTo) {
    let cursor = stringCursor(this.spec, doc, curTo, doc.length).nextOverlapping();
    if (cursor.done)
      cursor = stringCursor(this.spec, doc, 0, curFrom).nextOverlapping();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(doc, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor = stringCursor(this.spec, doc, start, pos), range = null;
      while (!cursor.nextOverlapping().done)
        range = cursor.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(doc, curFrom, curTo) {
    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);
  }
  getReplacement(_result) {
    return this.spec.replace;
  }
  matchAll(doc, limit) {
    let cursor = stringCursor(this.spec, doc, 0, doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(doc, from, to, add2) {
    let cursor = stringCursor(this.spec, doc, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, doc.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
};
function regexpCursor(spec, doc, from, to) {
  return new RegExpCursor(doc, spec.search, spec.caseSensitive ? void 0 : { ignoreCase: true }, from, to);
}
var RegExpQuery = class extends QueryType {
  nextMatch(doc, curFrom, curTo) {
    let cursor = regexpCursor(this.spec, doc, curTo, doc.length).next();
    if (cursor.done)
      cursor = regexpCursor(this.spec, doc, 0, curFrom).next();
    return cursor.done ? null : cursor.value;
  }
  prevMatchInRange(doc, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(from, to - size * 1e4);
      let cursor = regexpCursor(this.spec, doc, start, to), range = null;
      while (!cursor.next().done)
        range = cursor.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(doc, curFrom, curTo) {
    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);
  }
  getReplacement(result) {
    return this.spec.replace.replace(/\$([$&\d+])/g, (m2, i) => i == "$" ? "$" : i == "&" ? result.match[0] : i != "0" && +i < result.match.length ? result.match[i] : m2);
  }
  matchAll(doc, limit) {
    let cursor = regexpCursor(this.spec, doc, 0, doc.length), ranges = [];
    while (!cursor.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor.value);
    }
    return ranges;
  }
  highlight(doc, from, to, add2) {
    let cursor = regexpCursor(this.spec, doc, Math.max(0, from - 250), Math.min(to + 250, doc.length));
    while (!cursor.next().done)
      add2(cursor.value.from, cursor.value.to);
  }
};
var setSearchQuery = StateEffect.define();
var togglePanel = StateEffect.define();
var searchState = StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
      let { from, to } = ranges[i];
      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250)
        to = ranges[++i].to;
      query.highlight(view.state.doc, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next = query.nextMatch(view.state.doc, to, to);
  if (!next)
    return false;
  view.dispatch({
    selection: { anchor: next.from, head: next.to },
    scrollIntoView: true,
    effects: announceMatch(view, next),
    userEvent: "select.search"
  });
  return true;
});
var findPrevious = searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let range = query.prevMatch(state.doc, from, from);
  if (!range)
    return false;
  view.dispatch({
    selection: { anchor: range.from, head: range.to },
    scrollIntoView: true,
    effects: announceMatch(view, range),
    userEvent: "select.search"
  });
  return true;
});
var selectMatches = searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state.doc, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var replaceNext = searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let next = query.nextMatch(state.doc, from, from);
  if (!next)
    return false;
  let changes = [], selection, replacement;
  let announce = [];
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state.doc, next.from, next.to);
    announce.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  if (next) {
    let off2 = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection = { anchor: next.from - off2, head: next.to - off2 };
    announce.push(announceMatch(view, next));
  }
  view.dispatch({
    changes,
    selection,
    scrollIntoView: !!selection,
    effects: announce,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state.doc, 1e9).map((match) => {
    let { from, to } = match;
    return { from, to, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a, _b, _c;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal
  });
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let panel = getPanel(view, createSearchPanel);
    if (!panel)
      return false;
    let searchInput = panel.dom.querySelector("[main-field]");
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      checked: query.regexp,
      onchange: this.commit
    });
    function button(name, onclick, content) {
      return crelt("button", { class: "cm-button", name, onclick, type: "button" }, content);
    }
    this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")]),
        crelt("button", {
          name: "close",
          onclick: () => closeSearchPanel(view),
          "aria-label": phrase(view, "close"),
          type: "button"
        }, ["\xD7"])
      ]
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e) {
    if (runScopeHandlers(this.view, e, "search-panel")) {
      e.preventDefault();
    } else if (e.keyCode == 13 && e.target == this.searchField) {
      e.preventDefault();
      (e.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e.keyCode == 13 && e.target == this.replaceField) {
      e.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i = 0; i < AnnounceMargin; i++)
      if (!Break.test(text[i + 1]) && Break.test(text[i])) {
        text = text.slice(i);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
      if (!Break.test(text[i - 1]) && Break.test(text[i])) {
        text = text.slice(0, i);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme = EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  Prec.lowest(searchHighlighter),
  baseTheme
];

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let config = getConfig(target.state);
  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = command(changeLineComment, 0);
var lineComment = command(changeLineComment, 1);
var lineUncomment = command(changeLineComment, 2);
var toggleBlockComment = command(changeBlockComment, 0);
var blockComment = command(changeBlockComment, 1);
var blockUncomment = command(changeBlockComment, 2);
var toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
function getConfig(state, pos = state.selection.main.head) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r) => getConfig(state, r.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i) => {
      if (comments[i])
        return [];
      return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i = 0, comment; i < comments.length; i++)
      if (comment = comments[i]) {
        let token = tokens[i], { open, close } = comment;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let token = getConfig(state, pos).line;
        if (!token)
          continue;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment, token, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment, token } of lines)
      if (comment >= 0) {
        let from = line.from + comment, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500
    }, { minDepth: Math.max, newGroupDelay: Math.min });
  }
});
function changeEnd(changes) {
  let end = 0;
  changes.iterChangedRanges((_2, to) => end = to);
  return end;
}
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
      let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config = {}) {
  return [
    historyField_,
    historyConfig.of(config),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        let command2 = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection) {
  return function({ state, dispatch }) {
    if (!selection && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(0);
var redoDepth = depth(1);
var HistEvent = class {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a, _b, _c;
    return {
      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(json) {
    return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  static fromTransaction(tr, selection) {
    let effects = none;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none);
  }
  static selection(selections) {
    return new HistEvent(void 0, none, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t) => ranges.push(f, t));
  b.iterChangedRanges((_f, _t2, f, t) => {
    for (let i = 0; i < ranges.length; ) {
      let from = ranges[i++], to = ranges[i++];
      if (t >= from && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
var none = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection))
      return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, newGroupDelay, maxLen) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
    } else {
      done = updateBranch(done, done.length, maxLen, event);
    }
    return new HistoryState(done, none, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
      return this;
    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, selection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1];
    if (selection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch) }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none, none);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection))
    return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
var cursorCharBackward = (view) => cursorByChar(view, false);
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at2 = start.head; ; ) {
    let next = forward ? pos.childAfter(at2) : pos.childBefore(at2);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at2 = forward ? next.to : next.from;
  }
  let bracket = pos.type.prop(bracketProp), match, newPos;
  if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageHeight(view) {
  return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);
}
function cursorByPage(view, forward) {
  let { state } = view, selection = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);
  });
  if (selection.eq(state.selection))
    return false;
  let startPos = view.coordsAtPos(state.selection.main.head);
  let scrollRect = view.scrollDOM.getBoundingClientRect();
  let effect;
  if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
    effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollRect.top });
  view.dispatch(setSel(state, selection), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection = updateSel(state.selection, (range) => {
    let matching2 = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching2 || !matching2.end)
      return range;
    found = true;
    let head = matching2.start.from == range.head ? matching2.end.to : matching2.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(view, how) {
  let selection = updateSel(view.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn);
  });
  if (selection.eq(view.state.selection))
    return false;
  view.dispatch(setSel(view.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageHeight(view)));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection = updateSel(state.selection, (range) => {
    var _a;
    let context = syntaxTree(state).resolveInner(range.head, 1);
    while (!(context.from < range.from && context.to >= range.to || context.to > range.to && context.from <= range.from || !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))
      context = context.parent;
    return EditorSelection.range(context.to, context.from);
  });
  dispatch(setSel(state, selection));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur = state.selection, selection = null;
  if (cur.ranges.length > 1)
    selection = EditorSelection.create([cur.main]);
  else if (!cur.main.empty)
    selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
  if (!selection)
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy({ state, dispatch }, by) {
  if (state.readOnly)
    return false;
  let event = "delete.selection";
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(from);
      if (towards < from)
        event = "delete.backward";
      else if (towards > from)
        event = "delete.forward";
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from) };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
  let { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
  }
  return skipAtomic(target, targetPos, forward);
});
var deleteCharBackward = (view) => deleteByChar(view, false);
var deleteCharForward = (view) => deleteByChar(view, true);
var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
  let pos = start, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == start && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar != " " || pos != start)
      cat = nextCat;
    pos = next;
  }
  return skipAtomic(target, pos, forward);
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
  let lineEnd = view.lineBlockAt(pos).to;
  return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);
});
var deleteToLineStart = (view) => deleteBy(view, (pos) => {
  let lineStart = view.lineBlockAt(pos).from;
  return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r of block.ranges)
        ranges.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection = updateSel(state.selection, (range) => view.moveVertically(range, true)).map(changes);
  view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = /^\s*/.exec(state.doc.lineAt(from).text)[0].length;
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert = ["", indentString(state, indent)];
      if (explode)
        insert.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert) },
        range: EditorSelection.cursor(from + 1 + insert[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur != norm || range.from < line.from + cur.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteToLineStart },
  { mac: "Mod-Delete", run: deleteToLineEnd }
].concat(emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
var defaultKeymap = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment }
].concat(standardKeymap);

// node_modules/@replit/codemirror-vim/dist/index.js
function initVim(CodeMirror2) {
  var Pos2 = CodeMirror2.Pos;
  function transformCursor(cm, range) {
    var vim2 = cm.state.vim;
    if (!vim2 || vim2.insertMode)
      return range.head;
    var head = vim2.sel.head;
    if (!head)
      return range.head;
    if (vim2.visualBlock) {
      if (range.head.line != head.line) {
        return;
      }
    }
    if (range.from() == range.anchor && !range.empty()) {
      if (range.head.line == head.line && range.head.ch != head.ch)
        return new Pos2(range.head.line, range.head.ch - 1);
    }
    return range.head;
  }
  var defaultKeymap2 = [
    { keys: "<Left>", type: "keyToKey", toKeys: "h" },
    { keys: "<Right>", type: "keyToKey", toKeys: "l" },
    { keys: "<Up>", type: "keyToKey", toKeys: "k" },
    { keys: "<Down>", type: "keyToKey", toKeys: "j" },
    { keys: "g<Up>", type: "keyToKey", toKeys: "gk" },
    { keys: "g<Down>", type: "keyToKey", toKeys: "gj" },
    { keys: "<Space>", type: "keyToKey", toKeys: "l" },
    { keys: "<BS>", type: "keyToKey", toKeys: "h", context: "normal" },
    { keys: "<Del>", type: "keyToKey", toKeys: "x", context: "normal" },
    { keys: "<C-Space>", type: "keyToKey", toKeys: "W" },
    { keys: "<C-BS>", type: "keyToKey", toKeys: "B", context: "normal" },
    { keys: "<S-Space>", type: "keyToKey", toKeys: "w" },
    { keys: "<S-BS>", type: "keyToKey", toKeys: "b", context: "normal" },
    { keys: "<C-n>", type: "keyToKey", toKeys: "j" },
    { keys: "<C-p>", type: "keyToKey", toKeys: "k" },
    { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>" },
    { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>" },
    { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
    { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
    { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>" },
    { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
    { keys: "s", type: "keyToKey", toKeys: "cl", context: "normal" },
    { keys: "s", type: "keyToKey", toKeys: "c", context: "visual" },
    { keys: "S", type: "keyToKey", toKeys: "cc", context: "normal" },
    { keys: "S", type: "keyToKey", toKeys: "VdO", context: "visual" },
    { keys: "<Home>", type: "keyToKey", toKeys: "0" },
    { keys: "<End>", type: "keyToKey", toKeys: "$" },
    { keys: "<PageUp>", type: "keyToKey", toKeys: "<C-b>" },
    { keys: "<PageDown>", type: "keyToKey", toKeys: "<C-f>" },
    { keys: "<CR>", type: "keyToKey", toKeys: "j^", context: "normal" },
    { keys: "<Ins>", type: "keyToKey", toKeys: "i", context: "normal" },
    { keys: "<Ins>", type: "action", action: "toggleOverwrite", context: "insert" },
    { keys: "H", type: "motion", motion: "moveToTopLine", motionArgs: { linewise: true, toJumplist: true } },
    { keys: "M", type: "motion", motion: "moveToMiddleLine", motionArgs: { linewise: true, toJumplist: true } },
    { keys: "L", type: "motion", motion: "moveToBottomLine", motionArgs: { linewise: true, toJumplist: true } },
    { keys: "h", type: "motion", motion: "moveByCharacters", motionArgs: { forward: false } },
    { keys: "l", type: "motion", motion: "moveByCharacters", motionArgs: { forward: true } },
    { keys: "j", type: "motion", motion: "moveByLines", motionArgs: { forward: true, linewise: true } },
    { keys: "k", type: "motion", motion: "moveByLines", motionArgs: { forward: false, linewise: true } },
    { keys: "gj", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: true } },
    { keys: "gk", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: false } },
    { keys: "w", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: false } },
    { keys: "W", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: false, bigWord: true } },
    { keys: "e", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: true, inclusive: true } },
    { keys: "E", type: "motion", motion: "moveByWords", motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true } },
    { keys: "b", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false } },
    { keys: "B", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false, bigWord: true } },
    { keys: "ge", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: true, inclusive: true } },
    { keys: "gE", type: "motion", motion: "moveByWords", motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true } },
    { keys: "{", type: "motion", motion: "moveByParagraph", motionArgs: { forward: false, toJumplist: true } },
    { keys: "}", type: "motion", motion: "moveByParagraph", motionArgs: { forward: true, toJumplist: true } },
    { keys: "(", type: "motion", motion: "moveBySentence", motionArgs: { forward: false } },
    { keys: ")", type: "motion", motion: "moveBySentence", motionArgs: { forward: true } },
    { keys: "<C-f>", type: "motion", motion: "moveByPage", motionArgs: { forward: true } },
    { keys: "<C-b>", type: "motion", motion: "moveByPage", motionArgs: { forward: false } },
    { keys: "<C-d>", type: "motion", motion: "moveByScroll", motionArgs: { forward: true, explicitRepeat: true } },
    { keys: "<C-u>", type: "motion", motion: "moveByScroll", motionArgs: { forward: false, explicitRepeat: true } },
    { keys: "gg", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true } },
    { keys: "G", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true } },
    { keys: "g$", type: "motion", motion: "moveToEndOfDisplayLine" },
    { keys: "g^", type: "motion", motion: "moveToStartOfDisplayLine" },
    { keys: "g0", type: "motion", motion: "moveToStartOfDisplayLine" },
    { keys: "0", type: "motion", motion: "moveToStartOfLine" },
    { keys: "^", type: "motion", motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: "+", type: "motion", motion: "moveByLines", motionArgs: { forward: true, toFirstChar: true } },
    { keys: "-", type: "motion", motion: "moveByLines", motionArgs: { forward: false, toFirstChar: true } },
    { keys: "_", type: "motion", motion: "moveByLines", motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 } },
    { keys: "$", type: "motion", motion: "moveToEol", motionArgs: { inclusive: true } },
    { keys: "%", type: "motion", motion: "moveToMatchedSymbol", motionArgs: { inclusive: true, toJumplist: true } },
    { keys: "f<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: true, inclusive: true } },
    { keys: "F<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: false } },
    { keys: "t<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: true, inclusive: true } },
    { keys: "T<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: false } },
    { keys: ";", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: true } },
    { keys: ",", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: false } },
    { keys: "'<character>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: true, linewise: true } },
    { keys: "`<character>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: true } },
    { keys: "]`", type: "motion", motion: "jumpToMark", motionArgs: { forward: true } },
    { keys: "[`", type: "motion", motion: "jumpToMark", motionArgs: { forward: false } },
    { keys: "]'", type: "motion", motion: "jumpToMark", motionArgs: { forward: true, linewise: true } },
    { keys: "['", type: "motion", motion: "jumpToMark", motionArgs: { forward: false, linewise: true } },
    { keys: "]p", type: "action", action: "paste", isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true } },
    { keys: "[p", type: "action", action: "paste", isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true } },
    { keys: "]<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: true, toJumplist: true } },
    { keys: "[<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: false, toJumplist: true } },
    { keys: "|", type: "motion", motion: "moveToColumn" },
    { keys: "o", type: "motion", motion: "moveToOtherHighlightedEnd", context: "visual" },
    { keys: "O", type: "motion", motion: "moveToOtherHighlightedEnd", motionArgs: { sameLine: true }, context: "visual" },
    { keys: "d", type: "operator", operator: "delete" },
    { keys: "y", type: "operator", operator: "yank" },
    { keys: "c", type: "operator", operator: "change" },
    { keys: "=", type: "operator", operator: "indentAuto" },
    { keys: ">", type: "operator", operator: "indent", operatorArgs: { indentRight: true } },
    { keys: "<", type: "operator", operator: "indent", operatorArgs: { indentRight: false } },
    { keys: "g~", type: "operator", operator: "changeCase" },
    { keys: "gu", type: "operator", operator: "changeCase", operatorArgs: { toLower: true }, isEdit: true },
    { keys: "gU", type: "operator", operator: "changeCase", operatorArgs: { toLower: false }, isEdit: true },
    { keys: "n", type: "motion", motion: "findNext", motionArgs: { forward: true, toJumplist: true } },
    { keys: "N", type: "motion", motion: "findNext", motionArgs: { forward: false, toJumplist: true } },
    { keys: "gn", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: true } },
    { keys: "gN", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: false } },
    { keys: "x", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false } },
    { keys: "X", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true } },
    { keys: "D", type: "operatorMotion", operator: "delete", motion: "moveToEol", motionArgs: { inclusive: true }, context: "normal" },
    { keys: "D", type: "operator", operator: "delete", operatorArgs: { linewise: true }, context: "visual" },
    { keys: "Y", type: "operatorMotion", operator: "yank", motion: "expandToLine", motionArgs: { linewise: true }, context: "normal" },
    { keys: "Y", type: "operator", operator: "yank", operatorArgs: { linewise: true }, context: "visual" },
    { keys: "C", type: "operatorMotion", operator: "change", motion: "moveToEol", motionArgs: { inclusive: true }, context: "normal" },
    { keys: "C", type: "operator", operator: "change", operatorArgs: { linewise: true }, context: "visual" },
    { keys: "~", type: "operatorMotion", operator: "changeCase", motion: "moveByCharacters", motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: "normal" },
    { keys: "~", type: "operator", operator: "changeCase", context: "visual" },
    { keys: "<C-u>", type: "operatorMotion", operator: "delete", motion: "moveToStartOfLine", context: "insert" },
    { keys: "<C-w>", type: "operatorMotion", operator: "delete", motion: "moveByWords", motionArgs: { forward: false, wordEnd: false }, context: "insert" },
    { keys: "<C-w>", type: "idle", context: "normal" },
    { keys: "<C-i>", type: "action", action: "jumpListWalk", actionArgs: { forward: true } },
    { keys: "<C-o>", type: "action", action: "jumpListWalk", actionArgs: { forward: false } },
    { keys: "<C-e>", type: "action", action: "scroll", actionArgs: { forward: true, linewise: true } },
    { keys: "<C-y>", type: "action", action: "scroll", actionArgs: { forward: false, linewise: true } },
    { keys: "a", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "charAfter" }, context: "normal" },
    { keys: "A", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "eol" }, context: "normal" },
    { keys: "A", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "endOfSelectedArea" }, context: "visual" },
    { keys: "i", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "inplace" }, context: "normal" },
    { keys: "gi", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "lastEdit" }, context: "normal" },
    { keys: "I", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "firstNonBlank" }, context: "normal" },
    { keys: "gI", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "bol" }, context: "normal" },
    { keys: "I", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { insertAt: "startOfSelectedArea" }, context: "visual" },
    { keys: "o", type: "action", action: "newLineAndEnterInsertMode", isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: "normal" },
    { keys: "O", type: "action", action: "newLineAndEnterInsertMode", isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: "normal" },
    { keys: "v", type: "action", action: "toggleVisualMode" },
    { keys: "V", type: "action", action: "toggleVisualMode", actionArgs: { linewise: true } },
    { keys: "<C-v>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: true } },
    { keys: "<C-q>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: true } },
    { keys: "gv", type: "action", action: "reselectLastSelection" },
    { keys: "J", type: "action", action: "joinLines", isEdit: true },
    { keys: "gJ", type: "action", action: "joinLines", actionArgs: { keepSpaces: true }, isEdit: true },
    { keys: "p", type: "action", action: "paste", isEdit: true, actionArgs: { after: true, isEdit: true } },
    { keys: "P", type: "action", action: "paste", isEdit: true, actionArgs: { after: false, isEdit: true } },
    { keys: "r<character>", type: "action", action: "replace", isEdit: true },
    { keys: "@<character>", type: "action", action: "replayMacro" },
    { keys: "q<character>", type: "action", action: "enterMacroRecordMode" },
    { keys: "R", type: "action", action: "enterInsertMode", isEdit: true, actionArgs: { replace: true }, context: "normal" },
    { keys: "R", type: "operator", operator: "change", operatorArgs: { linewise: true, fullLine: true }, context: "visual", exitVisualBlock: true },
    { keys: "u", type: "action", action: "undo", context: "normal" },
    { keys: "u", type: "operator", operator: "changeCase", operatorArgs: { toLower: true }, context: "visual", isEdit: true },
    { keys: "U", type: "operator", operator: "changeCase", operatorArgs: { toLower: false }, context: "visual", isEdit: true },
    { keys: "<C-r>", type: "action", action: "redo" },
    { keys: "m<character>", type: "action", action: "setMark" },
    { keys: '"<character>', type: "action", action: "setRegister" },
    { keys: "zz", type: "action", action: "scrollToCursor", actionArgs: { position: "center" } },
    { keys: "z.", type: "action", action: "scrollToCursor", actionArgs: { position: "center" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: "zt", type: "action", action: "scrollToCursor", actionArgs: { position: "top" } },
    { keys: "z<CR>", type: "action", action: "scrollToCursor", actionArgs: { position: "top" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: "zb", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" } },
    { keys: "z-", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
    { keys: ".", type: "action", action: "repeatLastEdit" },
    { keys: "<C-a>", type: "action", action: "incrementNumberToken", isEdit: true, actionArgs: { increase: true, backtrack: false } },
    { keys: "<C-x>", type: "action", action: "incrementNumberToken", isEdit: true, actionArgs: { increase: false, backtrack: false } },
    { keys: "<C-t>", type: "action", action: "indent", actionArgs: { indentRight: true }, context: "insert" },
    { keys: "<C-d>", type: "action", action: "indent", actionArgs: { indentRight: false }, context: "insert" },
    { keys: "a<character>", type: "motion", motion: "textObjectManipulation" },
    { keys: "i<character>", type: "motion", motion: "textObjectManipulation", motionArgs: { textObjectInner: true } },
    { keys: "/", type: "search", searchArgs: { forward: true, querySrc: "prompt", toJumplist: true } },
    { keys: "?", type: "search", searchArgs: { forward: false, querySrc: "prompt", toJumplist: true } },
    { keys: "*", type: "search", searchArgs: { forward: true, querySrc: "wordUnderCursor", wholeWordOnly: true, toJumplist: true } },
    { keys: "#", type: "search", searchArgs: { forward: false, querySrc: "wordUnderCursor", wholeWordOnly: true, toJumplist: true } },
    { keys: "g*", type: "search", searchArgs: { forward: true, querySrc: "wordUnderCursor", toJumplist: true } },
    { keys: "g#", type: "search", searchArgs: { forward: false, querySrc: "wordUnderCursor", toJumplist: true } },
    { keys: ":", type: "ex" }
  ];
  var defaultKeymapLength = defaultKeymap2.length;
  var defaultExCommandMap = [
    { name: "colorscheme", shortName: "colo" },
    { name: "map" },
    { name: "imap", shortName: "im" },
    { name: "nmap", shortName: "nm" },
    { name: "vmap", shortName: "vm" },
    { name: "unmap" },
    { name: "write", shortName: "w" },
    { name: "undo", shortName: "u" },
    { name: "redo", shortName: "red" },
    { name: "set", shortName: "se" },
    { name: "setlocal", shortName: "setl" },
    { name: "setglobal", shortName: "setg" },
    { name: "sort", shortName: "sor" },
    { name: "substitute", shortName: "s", possiblyAsync: true },
    { name: "nohlsearch", shortName: "noh" },
    { name: "yank", shortName: "y" },
    { name: "delmarks", shortName: "delm" },
    { name: "registers", shortName: "reg", excludeFromCommandHistory: true },
    { name: "vglobal", shortName: "v" },
    { name: "global", shortName: "g" }
  ];
  function enterVimMode(cm) {
    cm.setOption("disableInput", true);
    cm.setOption("showCursorWhenSelecting", false);
    CodeMirror2.signal(cm, "vim-mode-change", { mode: "normal" });
    cm.on("cursorActivity", onCursorActivity);
    maybeInitVimState(cm);
    CodeMirror2.on(cm.getInputField(), "paste", getOnPasteFn(cm));
  }
  function leaveVimMode(cm) {
    cm.setOption("disableInput", false);
    cm.off("cursorActivity", onCursorActivity);
    CodeMirror2.off(cm.getInputField(), "paste", getOnPasteFn(cm));
    cm.state.vim = null;
    if (highlightTimeout)
      clearTimeout(highlightTimeout);
  }
  function detachVimMap(cm, next) {
    if (this == CodeMirror2.keyMap.vim) {
      cm.options.$customCursor = null;
      CodeMirror2.rmClass(cm.getWrapperElement(), "cm-fat-cursor");
    }
    if (!next || next.attach != attachVimMap)
      leaveVimMode(cm);
  }
  function attachVimMap(cm, prev) {
    if (this == CodeMirror2.keyMap.vim) {
      if (cm.curOp)
        cm.curOp.selectionChanged = true;
      cm.options.$customCursor = transformCursor;
      CodeMirror2.addClass(cm.getWrapperElement(), "cm-fat-cursor");
    }
    if (!prev || prev.attach != attachVimMap)
      enterVimMode(cm);
  }
  CodeMirror2.defineOption("vimMode", false, function(cm, val, prev) {
    if (val && cm.getOption("keyMap") != "vim")
      cm.setOption("keyMap", "vim");
    else if (!val && prev != CodeMirror2.Init && /^vim/.test(cm.getOption("keyMap")))
      cm.setOption("keyMap", "default");
  });
  function cmKey(key, cm) {
    if (!cm) {
      return void 0;
    }
    if (this[key]) {
      return this[key];
    }
    var vimKey2 = cmKeyToVimKey(key);
    if (!vimKey2) {
      return false;
    }
    var cmd2 = vimApi.findKey(cm, vimKey2);
    if (typeof cmd2 == "function") {
      CodeMirror2.signal(cm, "vim-keypress", vimKey2);
    }
    return cmd2;
  }
  var modifiers = { Shift: "S", Ctrl: "C", Alt: "A", Cmd: "D", Mod: "A", CapsLock: "" };
  var specialKeys = { Enter: "CR", Backspace: "BS", Delete: "Del", Insert: "Ins" };
  function cmKeyToVimKey(key) {
    if (key.charAt(0) == "'") {
      return key.charAt(1);
    }
    var pieces = key.split(/-(?!$)/);
    var lastPiece = pieces[pieces.length - 1];
    if (pieces.length == 1 && pieces[0].length == 1) {
      return false;
    } else if (pieces.length == 2 && pieces[0] == "Shift" && lastPiece.length == 1) {
      return false;
    }
    var hasCharacter = false;
    for (var i = 0; i < pieces.length; i++) {
      var piece = pieces[i];
      if (piece in modifiers) {
        pieces[i] = modifiers[piece];
      } else {
        hasCharacter = true;
      }
      if (piece in specialKeys) {
        pieces[i] = specialKeys[piece];
      }
    }
    if (!hasCharacter) {
      return false;
    }
    if (isUpperCase(lastPiece)) {
      pieces[pieces.length - 1] = lastPiece.toLowerCase();
    }
    return "<" + pieces.join("-") + ">";
  }
  function getOnPasteFn(cm) {
    var vim2 = cm.state.vim;
    if (!vim2.onPasteFn) {
      vim2.onPasteFn = function() {
        if (!vim2.insertMode) {
          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));
          actions.enterInsertMode(cm, {}, vim2);
        }
      };
    }
    return vim2.onPasteFn;
  }
  var numberRegex = /[\d]/;
  var wordCharTest = [CodeMirror2.isWordChar, function(ch) {
    return ch && !CodeMirror2.isWordChar(ch) && !/\s/.test(ch);
  }], bigWordCharTest = [function(ch) {
    return /\S/.test(ch);
  }];
  function makeKeyRange(start, size) {
    var keys = [];
    for (var i = start; i < start + size; i++) {
      keys.push(String.fromCharCode(i));
    }
    return keys;
  }
  var upperCaseAlphabet = makeKeyRange(65, 26);
  var lowerCaseAlphabet = makeKeyRange(97, 26);
  var numbers = makeKeyRange(48, 10);
  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ["<", ">"]);
  var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ["-", '"', ".", ":", "_", "/", "+"]);
  var upperCaseChars;
  try {
    upperCaseChars = new RegExp("^[\\p{Lu}]$", "u");
  } catch (_2) {
    upperCaseChars = /^[A-Z]$/;
  }
  function isLine(cm, line) {
    return line >= cm.firstLine() && line <= cm.lastLine();
  }
  function isLowerCase(k2) {
    return /^[a-z]$/.test(k2);
  }
  function isMatchableSymbol(k2) {
    return "()[]{}".indexOf(k2) != -1;
  }
  function isNumber(k2) {
    return numberRegex.test(k2);
  }
  function isUpperCase(k2) {
    return upperCaseChars.test(k2);
  }
  function isWhiteSpaceString(k2) {
    return /^\s*$/.test(k2);
  }
  function isEndOfSentenceSymbol(k2) {
    return ".?!".indexOf(k2) != -1;
  }
  function inArray(val, arr) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] == val) {
        return true;
      }
    }
    return false;
  }
  var options = {};
  function defineOption(name, defaultValue, type, aliases, callback) {
    if (defaultValue === void 0 && !callback) {
      throw Error("defaultValue is required unless callback is provided");
    }
    if (!type) {
      type = "string";
    }
    options[name] = {
      type,
      defaultValue,
      callback
    };
    if (aliases) {
      for (var i = 0; i < aliases.length; i++) {
        options[aliases[i]] = options[name];
      }
    }
    if (defaultValue) {
      setOption(name, defaultValue);
    }
  }
  function setOption(name, value, cm, cfg) {
    var option = options[name];
    cfg = cfg || {};
    var scope = cfg.scope;
    if (!option) {
      return new Error("Unknown option: " + name);
    }
    if (option.type == "boolean") {
      if (value && value !== true) {
        return new Error("Invalid argument: " + name + "=" + value);
      } else if (value !== false) {
        value = true;
      }
    }
    if (option.callback) {
      if (scope !== "local") {
        option.callback(value, void 0);
      }
      if (scope !== "global" && cm) {
        option.callback(value, cm);
      }
    } else {
      if (scope !== "local") {
        option.value = option.type == "boolean" ? !!value : value;
      }
      if (scope !== "global" && cm) {
        cm.state.vim.options[name] = { value };
      }
    }
  }
  function getOption(name, cm, cfg) {
    var option = options[name];
    cfg = cfg || {};
    var scope = cfg.scope;
    if (!option) {
      return new Error("Unknown option: " + name);
    }
    if (option.callback) {
      var local = cm && option.callback(void 0, cm);
      if (scope !== "global" && local !== void 0) {
        return local;
      }
      if (scope !== "local") {
        return option.callback();
      }
      return;
    } else {
      var local = scope !== "global" && (cm && cm.state.vim.options[name]);
      return (local || scope !== "local" && option || {}).value;
    }
  }
  defineOption("filetype", void 0, "string", ["ft"], function(name, cm) {
    if (cm === void 0) {
      return;
    }
    if (name === void 0) {
      var mode = cm.getOption("mode");
      return mode == "null" ? "" : mode;
    } else {
      var mode = name == "" ? "null" : name;
      cm.setOption("mode", mode);
    }
  });
  var createCircularJumpList = function() {
    var size = 100;
    var pointer = -1;
    var head = 0;
    var tail = 0;
    var buffer = new Array(size);
    function add2(cm, oldCur, newCur) {
      var current = pointer % size;
      var curMark = buffer[current];
      function useNextSlot(cursor) {
        var next = ++pointer % size;
        var trashMark = buffer[next];
        if (trashMark) {
          trashMark.clear();
        }
        buffer[next] = cm.setBookmark(cursor);
      }
      if (curMark) {
        var markPos = curMark.find();
        if (markPos && !cursorEqual(markPos, oldCur)) {
          useNextSlot(oldCur);
        }
      } else {
        useNextSlot(oldCur);
      }
      useNextSlot(newCur);
      head = pointer;
      tail = pointer - size + 1;
      if (tail < 0) {
        tail = 0;
      }
    }
    function move(cm, offset) {
      pointer += offset;
      if (pointer > head) {
        pointer = head;
      } else if (pointer < tail) {
        pointer = tail;
      }
      var mark = buffer[(size + pointer) % size];
      if (mark && !mark.find()) {
        var inc = offset > 0 ? 1 : -1;
        var newCur;
        var oldCur = cm.getCursor();
        do {
          pointer += inc;
          mark = buffer[(size + pointer) % size];
          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {
            break;
          }
        } while (pointer < head && pointer > tail);
      }
      return mark;
    }
    function find(cm, offset) {
      var oldPointer = pointer;
      var mark = move(cm, offset);
      pointer = oldPointer;
      return mark && mark.find();
    }
    return {
      cachedCursor: void 0,
      add: add2,
      find,
      move
    };
  };
  var createInsertModeChanges = function(c) {
    if (c) {
      return {
        changes: c.changes,
        expectCursorActivityForChange: c.expectCursorActivityForChange
      };
    }
    return {
      changes: [],
      expectCursorActivityForChange: false
    };
  };
  function MacroModeState() {
    this.latestRegister = void 0;
    this.isPlaying = false;
    this.isRecording = false;
    this.replaySearchQueries = [];
    this.onRecordingDone = void 0;
    this.lastInsertModeChanges = createInsertModeChanges();
  }
  MacroModeState.prototype = {
    exitMacroRecordMode: function() {
      var macroModeState = vimGlobalState.macroModeState;
      if (macroModeState.onRecordingDone) {
        macroModeState.onRecordingDone();
      }
      macroModeState.onRecordingDone = void 0;
      macroModeState.isRecording = false;
    },
    enterMacroRecordMode: function(cm, registerName) {
      var register = vimGlobalState.registerController.getRegister(registerName);
      if (register) {
        register.clear();
        this.latestRegister = registerName;
        if (cm.openDialog) {
          var template = dom("span", { class: "cm-vim-message" }, "recording @" + registerName);
          this.onRecordingDone = cm.openDialog(template, null, { bottom: true });
        }
        this.isRecording = true;
      }
    }
  };
  function maybeInitVimState(cm) {
    if (!cm.state.vim) {
      cm.state.vim = {
        inputState: new InputState(),
        lastEditInputState: void 0,
        lastEditActionCommand: void 0,
        lastHPos: -1,
        lastHSPos: -1,
        lastMotion: null,
        marks: {},
        insertMode: false,
        insertModeRepeat: void 0,
        visualMode: false,
        visualLine: false,
        visualBlock: false,
        lastSelection: null,
        lastPastedText: null,
        sel: {},
        options: {}
      };
    }
    return cm.state.vim;
  }
  var vimGlobalState;
  function resetVimGlobalState() {
    vimGlobalState = {
      searchQuery: null,
      searchIsReversed: false,
      lastSubstituteReplacePart: void 0,
      jumpList: createCircularJumpList(),
      macroModeState: new MacroModeState(),
      lastCharacterSearch: { increment: 0, forward: true, selectedCharacter: "" },
      registerController: new RegisterController({}),
      searchHistoryController: new HistoryController(),
      exCommandHistoryController: new HistoryController()
    };
    for (var optionName in options) {
      var option = options[optionName];
      option.value = option.defaultValue;
    }
  }
  var lastInsertModeKeyTimer;
  var vimApi = {
    enterVimMode,
    buildKeyMap: function() {
    },
    getRegisterController: function() {
      return vimGlobalState.registerController;
    },
    resetVimGlobalState_: resetVimGlobalState,
    getVimGlobalState_: function() {
      return vimGlobalState;
    },
    maybeInitVimState_: maybeInitVimState,
    suppressErrorLogging: false,
    InsertModeKey,
    map: function(lhs, rhs, ctx) {
      exCommandDispatcher.map(lhs, rhs, ctx);
    },
    unmap: function(lhs, ctx) {
      return exCommandDispatcher.unmap(lhs, ctx);
    },
    noremap: function(lhs, rhs, ctx) {
      function toCtxArray(ctx2) {
        return ctx2 ? [ctx2] : ["normal", "insert", "visual"];
      }
      var ctxsToMap = toCtxArray(ctx);
      var actualLength = defaultKeymap2.length, origLength = defaultKeymapLength;
      for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {
        var mapping = defaultKeymap2[i];
        if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== "ex" && mapping.type.substr(0, 3) !== "key") {
          var newMapping = {};
          for (var key in mapping) {
            newMapping[key] = mapping[key];
          }
          newMapping.keys = lhs;
          if (ctx && !newMapping.context) {
            newMapping.context = ctx;
          }
          this._mapCommand(newMapping);
          var mappedCtxs = toCtxArray(mapping.context);
          ctxsToMap = ctxsToMap.filter(function(el) {
            return mappedCtxs.indexOf(el) === -1;
          });
        }
      }
    },
    mapclear: function(ctx) {
      var actualLength = defaultKeymap2.length, origLength = defaultKeymapLength;
      var userKeymap = defaultKeymap2.slice(0, actualLength - origLength);
      defaultKeymap2 = defaultKeymap2.slice(actualLength - origLength);
      if (ctx) {
        for (var i = userKeymap.length - 1; i >= 0; i--) {
          var mapping = userKeymap[i];
          if (ctx !== mapping.context) {
            if (mapping.context) {
              this._mapCommand(mapping);
            } else {
              var contexts = ["normal", "insert", "visual"];
              for (var j in contexts) {
                if (contexts[j] !== ctx) {
                  var newMapping = {};
                  for (var key in mapping) {
                    newMapping[key] = mapping[key];
                  }
                  newMapping.context = contexts[j];
                  this._mapCommand(newMapping);
                }
              }
            }
          }
        }
      }
    },
    setOption,
    getOption,
    defineOption,
    defineEx: function(name, prefix, func) {
      if (!prefix) {
        prefix = name;
      } else if (name.indexOf(prefix) !== 0) {
        throw new Error('(Vim.defineEx) "' + prefix + '" is not a prefix of "' + name + '", command not registered');
      }
      exCommands[name] = func;
      exCommandDispatcher.commandMap_[prefix] = { name, shortName: prefix, type: "api" };
    },
    handleKey: function(cm, key, origin) {
      var command2 = this.findKey(cm, key, origin);
      if (typeof command2 === "function") {
        return command2();
      }
    },
    multiSelectHandleKey,
    findKey: function(cm, key, origin) {
      var vim2 = maybeInitVimState(cm);
      function handleMacroRecording() {
        var macroModeState = vimGlobalState.macroModeState;
        if (macroModeState.isRecording) {
          if (key == "q") {
            macroModeState.exitMacroRecordMode();
            clearInputState(cm);
            return true;
          }
          if (origin != "mapping") {
            logKey(macroModeState, key);
          }
        }
      }
      function handleEsc() {
        if (key == "<Esc>") {
          if (vim2.visualMode) {
            exitVisualMode(cm);
          } else if (vim2.insertMode) {
            exitInsertMode(cm);
          } else {
            return;
          }
          clearInputState(cm);
          return true;
        }
      }
      function doKeyToKey(keys) {
        var match;
        while (keys) {
          match = /<\w+-.+?>|<\w+>|./.exec(keys);
          key = match[0];
          keys = keys.substring(match.index + key.length);
          vimApi.handleKey(cm, key, "mapping");
        }
      }
      function handleKeyInsertMode() {
        if (handleEsc()) {
          return true;
        }
        var keys = vim2.inputState.keyBuffer = vim2.inputState.keyBuffer + key;
        var keysAreChars = key.length == 1;
        var match = commandDispatcher.matchCommand(keys, defaultKeymap2, vim2.inputState, "insert");
        while (keys.length > 1 && match.type != "full") {
          var keys = vim2.inputState.keyBuffer = keys.slice(1);
          var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap2, vim2.inputState, "insert");
          if (thisMatch.type != "none") {
            match = thisMatch;
          }
        }
        if (match.type == "none") {
          clearInputState(cm);
          return false;
        } else if (match.type == "partial") {
          if (lastInsertModeKeyTimer) {
            window.clearTimeout(lastInsertModeKeyTimer);
          }
          lastInsertModeKeyTimer = window.setTimeout(
            function() {
              if (vim2.insertMode && vim2.inputState.keyBuffer) {
                clearInputState(cm);
              }
            },
            getOption("insertModeEscKeysTimeout")
          );
          return !keysAreChars;
        }
        if (lastInsertModeKeyTimer) {
          window.clearTimeout(lastInsertModeKeyTimer);
        }
        if (keysAreChars) {
          var selections = cm.listSelections();
          for (var i = 0; i < selections.length; i++) {
            var here = selections[i].head;
            cm.replaceRange("", offsetCursor(here, 0, -(keys.length - 1)), here, "+input");
          }
          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
        }
        clearInputState(cm);
        return match.command;
      }
      function handleKeyNonInsertMode() {
        if (handleMacroRecording() || handleEsc()) {
          return true;
        }
        var keys = vim2.inputState.keyBuffer = vim2.inputState.keyBuffer + key;
        if (/^[1-9]\d*$/.test(keys)) {
          return true;
        }
        var keysMatcher = /^(\d*)(.*)$/.exec(keys);
        if (!keysMatcher) {
          clearInputState(cm);
          return false;
        }
        var context = vim2.visualMode ? "visual" : "normal";
        var mainKey = keysMatcher[2] || keysMatcher[1];
        if (vim2.inputState.operatorShortcut && vim2.inputState.operatorShortcut.slice(-1) == mainKey) {
          mainKey = vim2.inputState.operatorShortcut;
        }
        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap2, vim2.inputState, context);
        if (match.type == "none") {
          clearInputState(cm);
          return false;
        } else if (match.type == "partial") {
          return true;
        } else if (match.type == "clear") {
          clearInputState(cm);
          return true;
        }
        vim2.inputState.keyBuffer = "";
        keysMatcher = /^(\d*)(.*)$/.exec(keys);
        if (keysMatcher[1] && keysMatcher[1] != "0") {
          vim2.inputState.pushRepeatDigit(keysMatcher[1]);
        }
        return match.command;
      }
      var command2;
      if (vim2.insertMode) {
        command2 = handleKeyInsertMode();
      } else {
        command2 = handleKeyNonInsertMode();
      }
      if (command2 === false) {
        return !vim2.insertMode && key.length === 1 ? function() {
          return true;
        } : void 0;
      } else if (command2 === true) {
        return function() {
          return true;
        };
      } else {
        return function() {
          return cm.operation(function() {
            cm.curOp.isVimOp = true;
            try {
              if (command2.type == "keyToKey") {
                doKeyToKey(command2.toKeys);
              } else {
                commandDispatcher.processCommand(cm, vim2, command2);
              }
            } catch (e) {
              cm.state.vim = void 0;
              maybeInitVimState(cm);
              if (!vimApi.suppressErrorLogging) {
                console["log"](e);
              }
              throw e;
            }
            return true;
          });
        };
      }
    },
    handleEx: function(cm, input) {
      exCommandDispatcher.processCommand(cm, input);
    },
    defineMotion,
    defineAction,
    defineOperator,
    mapCommand,
    _mapCommand,
    defineRegister,
    exitVisualMode,
    exitInsertMode
  };
  function InputState() {
    this.prefixRepeat = [];
    this.motionRepeat = [];
    this.operator = null;
    this.operatorArgs = null;
    this.motion = null;
    this.motionArgs = null;
    this.keyBuffer = [];
    this.registerName = null;
  }
  InputState.prototype.pushRepeatDigit = function(n) {
    if (!this.operator) {
      this.prefixRepeat = this.prefixRepeat.concat(n);
    } else {
      this.motionRepeat = this.motionRepeat.concat(n);
    }
  };
  InputState.prototype.getRepeat = function() {
    var repeat = 0;
    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
      repeat = 1;
      if (this.prefixRepeat.length > 0) {
        repeat *= parseInt(this.prefixRepeat.join(""), 10);
      }
      if (this.motionRepeat.length > 0) {
        repeat *= parseInt(this.motionRepeat.join(""), 10);
      }
    }
    return repeat;
  };
  function clearInputState(cm, reason) {
    cm.state.vim.inputState = new InputState();
    CodeMirror2.signal(cm, "vim-command-done", reason);
  }
  function Register(text, linewise, blockwise) {
    this.clear();
    this.keyBuffer = [text || ""];
    this.insertModeChanges = [];
    this.searchQueries = [];
    this.linewise = !!linewise;
    this.blockwise = !!blockwise;
  }
  Register.prototype = {
    setText: function(text, linewise, blockwise) {
      this.keyBuffer = [text || ""];
      this.linewise = !!linewise;
      this.blockwise = !!blockwise;
    },
    pushText: function(text, linewise) {
      if (linewise) {
        if (!this.linewise) {
          this.keyBuffer.push("\n");
        }
        this.linewise = true;
      }
      this.keyBuffer.push(text);
    },
    pushInsertModeChanges: function(changes) {
      this.insertModeChanges.push(createInsertModeChanges(changes));
    },
    pushSearchQuery: function(query) {
      this.searchQueries.push(query);
    },
    clear: function() {
      this.keyBuffer = [];
      this.insertModeChanges = [];
      this.searchQueries = [];
      this.linewise = false;
    },
    toString: function() {
      return this.keyBuffer.join("");
    }
  };
  function defineRegister(name, register) {
    var registers = vimGlobalState.registerController.registers;
    if (!name || name.length != 1) {
      throw Error("Register name must be 1 character");
    }
    if (registers[name]) {
      throw Error("Register already defined " + name);
    }
    registers[name] = register;
    validRegisters.push(name);
  }
  function RegisterController(registers) {
    this.registers = registers;
    this.unnamedRegister = registers['"'] = new Register();
    registers["."] = new Register();
    registers[":"] = new Register();
    registers["/"] = new Register();
    registers["+"] = new Register();
  }
  RegisterController.prototype = {
    pushText: function(registerName, operator, text, linewise, blockwise) {
      if (registerName === "_")
        return;
      if (linewise && text.charAt(text.length - 1) !== "\n") {
        text += "\n";
      }
      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;
      if (!register) {
        switch (operator) {
          case "yank":
            this.registers["0"] = new Register(text, linewise, blockwise);
            break;
          case "delete":
          case "change":
            if (text.indexOf("\n") == -1) {
              this.registers["-"] = new Register(text, linewise);
            } else {
              this.shiftNumericRegisters_();
              this.registers["1"] = new Register(text, linewise);
            }
            break;
        }
        this.unnamedRegister.setText(text, linewise, blockwise);
        return;
      }
      var append = isUpperCase(registerName);
      if (append) {
        register.pushText(text, linewise);
      } else {
        register.setText(text, linewise, blockwise);
      }
      if (registerName === "+") {
        navigator.clipboard.writeText(text);
      }
      this.unnamedRegister.setText(register.toString(), linewise);
    },
    getRegister: function(name) {
      if (!this.isValidRegister(name)) {
        return this.unnamedRegister;
      }
      name = name.toLowerCase();
      if (!this.registers[name]) {
        this.registers[name] = new Register();
      }
      return this.registers[name];
    },
    isValidRegister: function(name) {
      return name && inArray(name, validRegisters);
    },
    shiftNumericRegisters_: function() {
      for (var i = 9; i >= 2; i--) {
        this.registers[i] = this.getRegister("" + (i - 1));
      }
    }
  };
  function HistoryController() {
    this.historyBuffer = [];
    this.iterator = 0;
    this.initialPrefix = null;
  }
  HistoryController.prototype = {
    nextMatch: function(input, up) {
      var historyBuffer = this.historyBuffer;
      var dir = up ? -1 : 1;
      if (this.initialPrefix === null)
        this.initialPrefix = input;
      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {
        var element = historyBuffer[i];
        for (var j = 0; j <= element.length; j++) {
          if (this.initialPrefix == element.substring(0, j)) {
            this.iterator = i;
            return element;
          }
        }
      }
      if (i >= historyBuffer.length) {
        this.iterator = historyBuffer.length;
        return this.initialPrefix;
      }
      if (i < 0)
        return input;
    },
    pushInput: function(input) {
      var index = this.historyBuffer.indexOf(input);
      if (index > -1)
        this.historyBuffer.splice(index, 1);
      if (input.length)
        this.historyBuffer.push(input);
    },
    reset: function() {
      this.initialPrefix = null;
      this.iterator = this.historyBuffer.length;
    }
  };
  var commandDispatcher = {
    matchCommand: function(keys, keyMap, inputState, context) {
      var matches = commandMatches(keys, keyMap, context, inputState);
      if (!matches.full && !matches.partial) {
        return { type: "none" };
      } else if (!matches.full && matches.partial) {
        return { type: "partial" };
      }
      var bestMatch;
      for (var i = 0; i < matches.full.length; i++) {
        var match = matches.full[i];
        if (!bestMatch) {
          bestMatch = match;
        }
      }
      if (bestMatch.keys.slice(-11) == "<character>") {
        var character = lastChar(keys);
        if (!character || character.length > 1)
          return { type: "clear" };
        inputState.selectedCharacter = character;
      }
      return { type: "full", command: bestMatch };
    },
    processCommand: function(cm, vim2, command2) {
      vim2.inputState.repeatOverride = command2.repeatOverride;
      switch (command2.type) {
        case "motion":
          this.processMotion(cm, vim2, command2);
          break;
        case "operator":
          this.processOperator(cm, vim2, command2);
          break;
        case "operatorMotion":
          this.processOperatorMotion(cm, vim2, command2);
          break;
        case "action":
          this.processAction(cm, vim2, command2);
          break;
        case "search":
          this.processSearch(cm, vim2, command2);
          break;
        case "ex":
        case "keyToEx":
          this.processEx(cm, vim2, command2);
          break;
      }
    },
    processMotion: function(cm, vim2, command2) {
      vim2.inputState.motion = command2.motion;
      vim2.inputState.motionArgs = copyArgs(command2.motionArgs);
      this.evalInput(cm, vim2);
    },
    processOperator: function(cm, vim2, command2) {
      var inputState = vim2.inputState;
      if (inputState.operator) {
        if (inputState.operator == command2.operator) {
          inputState.motion = "expandToLine";
          inputState.motionArgs = { linewise: true };
          this.evalInput(cm, vim2);
          return;
        } else {
          clearInputState(cm);
        }
      }
      inputState.operator = command2.operator;
      inputState.operatorArgs = copyArgs(command2.operatorArgs);
      if (command2.keys.length > 1) {
        inputState.operatorShortcut = command2.keys;
      }
      if (command2.exitVisualBlock) {
        vim2.visualBlock = false;
        updateCmSelection(cm);
      }
      if (vim2.visualMode) {
        this.evalInput(cm, vim2);
      }
    },
    processOperatorMotion: function(cm, vim2, command2) {
      var visualMode = vim2.visualMode;
      var operatorMotionArgs = copyArgs(command2.operatorMotionArgs);
      if (operatorMotionArgs) {
        if (visualMode && operatorMotionArgs.visualLine) {
          vim2.visualLine = true;
        }
      }
      this.processOperator(cm, vim2, command2);
      if (!visualMode) {
        this.processMotion(cm, vim2, command2);
      }
    },
    processAction: function(cm, vim2, command2) {
      var inputState = vim2.inputState;
      var repeat = inputState.getRepeat();
      var repeatIsExplicit = !!repeat;
      var actionArgs = copyArgs(command2.actionArgs) || {};
      if (inputState.selectedCharacter) {
        actionArgs.selectedCharacter = inputState.selectedCharacter;
      }
      if (command2.operator) {
        this.processOperator(cm, vim2, command2);
      }
      if (command2.motion) {
        this.processMotion(cm, vim2, command2);
      }
      if (command2.motion || command2.operator) {
        this.evalInput(cm, vim2);
      }
      actionArgs.repeat = repeat || 1;
      actionArgs.repeatIsExplicit = repeatIsExplicit;
      actionArgs.registerName = inputState.registerName;
      clearInputState(cm);
      vim2.lastMotion = null;
      if (command2.isEdit) {
        this.recordLastEdit(vim2, inputState, command2);
      }
      actions[command2.action](cm, actionArgs, vim2);
    },
    processSearch: function(cm, vim2, command2) {
      if (!cm.getSearchCursor) {
        return;
      }
      var forward = command2.searchArgs.forward;
      var wholeWordOnly = command2.searchArgs.wholeWordOnly;
      getSearchState(cm).setReversed(!forward);
      var promptPrefix = forward ? "/" : "?";
      var originalQuery = getSearchState(cm).getQuery();
      var originalScrollPos = cm.getScrollInfo();
      function handleQuery(query2, ignoreCase, smartCase) {
        vimGlobalState.searchHistoryController.pushInput(query2);
        vimGlobalState.searchHistoryController.reset();
        try {
          updateSearchQuery(cm, query2, ignoreCase, smartCase);
        } catch (e) {
          showConfirm(cm, "Invalid regex: " + query2);
          clearInputState(cm);
          return;
        }
        commandDispatcher.processMotion(cm, vim2, {
          type: "motion",
          motion: "findNext",
          motionArgs: { forward: true, toJumplist: command2.searchArgs.toJumplist }
        });
      }
      function onPromptClose(query2) {
        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
        handleQuery(query2, true, true);
        var macroModeState2 = vimGlobalState.macroModeState;
        if (macroModeState2.isRecording) {
          logSearchQuery(macroModeState2, query2);
        }
      }
      function onPromptKeyUp(e, query2, close) {
        var keyName = CodeMirror2.keyName(e), up, offset;
        if (keyName == "Up" || keyName == "Down") {
          up = keyName == "Up" ? true : false;
          offset = e.target ? e.target.selectionEnd : 0;
          query2 = vimGlobalState.searchHistoryController.nextMatch(query2, up) || "";
          close(query2);
          if (offset && e.target)
            e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
        } else {
          if (keyName != "Left" && keyName != "Right" && keyName != "Ctrl" && keyName != "Alt" && keyName != "Shift")
            vimGlobalState.searchHistoryController.reset();
        }
        var parsedQuery;
        try {
          parsedQuery = updateSearchQuery(
            cm,
            query2,
            true,
            true
          );
        } catch (e2) {
        }
        if (parsedQuery) {
          cm.scrollIntoView(findNext2(cm, !forward, parsedQuery), 30);
        } else {
          clearSearchHighlight(cm);
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
        }
      }
      function onPromptKeyDown(e, query2, close) {
        var keyName = CodeMirror2.keyName(e);
        if (keyName == "Esc" || keyName == "Ctrl-C" || keyName == "Ctrl-[" || keyName == "Backspace" && query2 == "") {
          vimGlobalState.searchHistoryController.pushInput(query2);
          vimGlobalState.searchHistoryController.reset();
          updateSearchQuery(cm, originalQuery);
          clearSearchHighlight(cm);
          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
          CodeMirror2.e_stop(e);
          clearInputState(cm);
          close();
          cm.focus();
        } else if (keyName == "Up" || keyName == "Down") {
          CodeMirror2.e_stop(e);
        } else if (keyName == "Ctrl-U") {
          CodeMirror2.e_stop(e);
          close("");
        }
      }
      switch (command2.searchArgs.querySrc) {
        case "prompt":
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isPlaying) {
            var query = macroModeState.replaySearchQueries.shift();
            handleQuery(query, true, false);
          } else {
            showPrompt(cm, {
              onClose: onPromptClose,
              prefix: promptPrefix,
              desc: "(JavaScript regexp)",
              onKeyUp: onPromptKeyUp,
              onKeyDown: onPromptKeyDown
            });
          }
          break;
        case "wordUnderCursor":
          var word = expandWordUnderCursor(
            cm,
            false,
            true,
            false,
            true
          );
          var isKeyword = true;
          if (!word) {
            word = expandWordUnderCursor(
              cm,
              false,
              true,
              false,
              false
            );
            isKeyword = false;
          }
          if (!word) {
            return;
          }
          var query = cm.getLine(word.start.line).substring(
            word.start.ch,
            word.end.ch
          );
          if (isKeyword && wholeWordOnly) {
            query = "\\b" + query + "\\b";
          } else {
            query = escapeRegex(query);
          }
          vimGlobalState.jumpList.cachedCursor = cm.getCursor();
          cm.setCursor(word.start);
          handleQuery(query, true, false);
          break;
      }
    },
    processEx: function(cm, vim2, command2) {
      function onPromptClose(input) {
        vimGlobalState.exCommandHistoryController.pushInput(input);
        vimGlobalState.exCommandHistoryController.reset();
        exCommandDispatcher.processCommand(cm, input);
        clearInputState(cm);
      }
      function onPromptKeyDown(e, input, close) {
        var keyName = CodeMirror2.keyName(e), up, offset;
        if (keyName == "Esc" || keyName == "Ctrl-C" || keyName == "Ctrl-[" || keyName == "Backspace" && input == "") {
          vimGlobalState.exCommandHistoryController.pushInput(input);
          vimGlobalState.exCommandHistoryController.reset();
          CodeMirror2.e_stop(e);
          clearInputState(cm);
          close();
          cm.focus();
        }
        if (keyName == "Up" || keyName == "Down") {
          CodeMirror2.e_stop(e);
          up = keyName == "Up" ? true : false;
          offset = e.target ? e.target.selectionEnd : 0;
          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || "";
          close(input);
          if (offset && e.target)
            e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
        } else if (keyName == "Ctrl-U") {
          CodeMirror2.e_stop(e);
          close("");
        } else {
          if (keyName != "Left" && keyName != "Right" && keyName != "Ctrl" && keyName != "Alt" && keyName != "Shift")
            vimGlobalState.exCommandHistoryController.reset();
        }
      }
      if (command2.type == "keyToEx") {
        exCommandDispatcher.processCommand(cm, command2.exArgs.input);
      } else {
        if (vim2.visualMode) {
          showPrompt(cm, {
            onClose: onPromptClose,
            prefix: ":",
            value: "'<,'>",
            onKeyDown: onPromptKeyDown,
            selectValueOnOpen: false
          });
        } else {
          showPrompt(cm, {
            onClose: onPromptClose,
            prefix: ":",
            onKeyDown: onPromptKeyDown
          });
        }
      }
    },
    evalInput: function(cm, vim2) {
      var inputState = vim2.inputState;
      var motion = inputState.motion;
      var motionArgs = inputState.motionArgs || {};
      var operator = inputState.operator;
      var operatorArgs = inputState.operatorArgs || {};
      var registerName = inputState.registerName;
      var sel = vim2.sel;
      var origHead = copyCursor(vim2.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor("head"));
      var origAnchor = copyCursor(vim2.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor("anchor"));
      var oldHead = copyCursor(origHead);
      var oldAnchor = copyCursor(origAnchor);
      var newHead, newAnchor;
      var repeat;
      if (operator) {
        this.recordLastEdit(vim2, inputState);
      }
      if (inputState.repeatOverride !== void 0) {
        repeat = inputState.repeatOverride;
      } else {
        repeat = inputState.getRepeat();
      }
      if (repeat > 0 && motionArgs.explicitRepeat) {
        motionArgs.repeatIsExplicit = true;
      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {
        repeat = 1;
        motionArgs.repeatIsExplicit = false;
      }
      if (inputState.selectedCharacter) {
        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;
      }
      motionArgs.repeat = repeat;
      clearInputState(cm);
      if (motion) {
        var motionResult = motions[motion](cm, origHead, motionArgs, vim2, inputState);
        vim2.lastMotion = motions[motion];
        if (!motionResult) {
          return;
        }
        if (motionArgs.toJumplist) {
          var jumpList = vimGlobalState.jumpList;
          var cachedCursor = jumpList.cachedCursor;
          if (cachedCursor) {
            recordJumpPosition(cm, cachedCursor, motionResult);
            delete jumpList.cachedCursor;
          } else {
            recordJumpPosition(cm, origHead, motionResult);
          }
        }
        if (motionResult instanceof Array) {
          newAnchor = motionResult[0];
          newHead = motionResult[1];
        } else {
          newHead = motionResult;
        }
        if (!newHead) {
          newHead = copyCursor(origHead);
        }
        if (vim2.visualMode) {
          if (!(vim2.visualBlock && newHead.ch === Infinity)) {
            newHead = clipCursorToContent(cm, newHead);
          }
          if (newAnchor) {
            newAnchor = clipCursorToContent(cm, newAnchor);
          }
          newAnchor = newAnchor || oldAnchor;
          sel.anchor = newAnchor;
          sel.head = newHead;
          updateCmSelection(cm);
          updateMark(
            cm,
            vim2,
            "<",
            cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead
          );
          updateMark(
            cm,
            vim2,
            ">",
            cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor
          );
        } else if (!operator) {
          newHead = clipCursorToContent(cm, newHead);
          cm.setCursor(newHead.line, newHead.ch);
        }
      }
      if (operator) {
        if (operatorArgs.lastSel) {
          newAnchor = oldAnchor;
          var lastSel = operatorArgs.lastSel;
          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
          if (lastSel.visualLine) {
            newHead = new Pos2(oldAnchor.line + lineOffset, oldAnchor.ch);
          } else if (lastSel.visualBlock) {
            newHead = new Pos2(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
          } else if (lastSel.head.line == lastSel.anchor.line) {
            newHead = new Pos2(oldAnchor.line, oldAnchor.ch + chOffset);
          } else {
            newHead = new Pos2(oldAnchor.line + lineOffset, oldAnchor.ch);
          }
          vim2.visualMode = true;
          vim2.visualLine = lastSel.visualLine;
          vim2.visualBlock = lastSel.visualBlock;
          sel = vim2.sel = {
            anchor: newAnchor,
            head: newHead
          };
          updateCmSelection(cm);
        } else if (vim2.visualMode) {
          operatorArgs.lastSel = {
            anchor: copyCursor(sel.anchor),
            head: copyCursor(sel.head),
            visualBlock: vim2.visualBlock,
            visualLine: vim2.visualLine
          };
        }
        var curStart, curEnd, linewise, mode;
        var cmSel;
        if (vim2.visualMode) {
          curStart = cursorMin(sel.head, sel.anchor);
          curEnd = cursorMax(sel.head, sel.anchor);
          linewise = vim2.visualLine || operatorArgs.linewise;
          mode = vim2.visualBlock ? "block" : linewise ? "line" : "char";
          cmSel = makeCmSelection(cm, {
            anchor: curStart,
            head: curEnd
          }, mode);
          if (linewise) {
            var ranges = cmSel.ranges;
            if (mode == "block") {
              for (var i = 0; i < ranges.length; i++) {
                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
              }
            } else if (mode == "line") {
              ranges[0].head = new Pos2(ranges[0].head.line + 1, 0);
            }
          }
        } else {
          curStart = copyCursor(newAnchor || oldAnchor);
          curEnd = copyCursor(newHead || oldHead);
          if (cursorIsBefore(curEnd, curStart)) {
            var tmp = curStart;
            curStart = curEnd;
            curEnd = tmp;
          }
          linewise = motionArgs.linewise || operatorArgs.linewise;
          if (linewise) {
            expandSelectionToLine(cm, curStart, curEnd);
          } else if (motionArgs.forward) {
            clipToLine(cm, curStart, curEnd);
          }
          mode = "char";
          var exclusive = !motionArgs.inclusive || linewise;
          cmSel = makeCmSelection(cm, {
            anchor: curStart,
            head: curEnd
          }, mode, exclusive);
        }
        cm.setSelections(cmSel.ranges, cmSel.primary);
        vim2.lastMotion = null;
        operatorArgs.repeat = repeat;
        operatorArgs.registerName = registerName;
        operatorArgs.linewise = linewise;
        var operatorMoveTo = operators[operator](
          cm,
          operatorArgs,
          cmSel.ranges,
          oldAnchor,
          newHead
        );
        if (vim2.visualMode) {
          exitVisualMode(cm, operatorMoveTo != null);
        }
        if (operatorMoveTo) {
          cm.setCursor(operatorMoveTo);
        }
      }
    },
    recordLastEdit: function(vim2, inputState, actionCommand) {
      var macroModeState = vimGlobalState.macroModeState;
      if (macroModeState.isPlaying) {
        return;
      }
      vim2.lastEditInputState = inputState;
      vim2.lastEditActionCommand = actionCommand;
      macroModeState.lastInsertModeChanges.changes = [];
      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
      macroModeState.lastInsertModeChanges.visualBlock = vim2.visualBlock ? vim2.sel.head.line - vim2.sel.anchor.line : 0;
    }
  };
  var motions = {
    moveToTopLine: function(cm, _head, motionArgs) {
      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;
      return new Pos2(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
    },
    moveToMiddleLine: function(cm) {
      var range = getUserVisibleLines(cm);
      var line = Math.floor((range.top + range.bottom) * 0.5);
      return new Pos2(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
    },
    moveToBottomLine: function(cm, _head, motionArgs) {
      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;
      return new Pos2(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
    },
    expandToLine: function(_cm, head, motionArgs) {
      var cur = head;
      return new Pos2(cur.line + motionArgs.repeat - 1, Infinity);
    },
    findNext: function(cm, _head, motionArgs) {
      var state = getSearchState(cm);
      var query = state.getQuery();
      if (!query) {
        return;
      }
      var prev = !motionArgs.forward;
      prev = state.isReversed() ? !prev : prev;
      highlightSearchMatches(cm, query);
      return findNext2(cm, prev, query, motionArgs.repeat);
    },
    findAndSelectNextInclusive: function(cm, _head, motionArgs, vim2, prevInputState) {
      var state = getSearchState(cm);
      var query = state.getQuery();
      if (!query) {
        return;
      }
      var prev = !motionArgs.forward;
      prev = state.isReversed() ? !prev : prev;
      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim2);
      if (!next) {
        return;
      }
      if (prevInputState.operator) {
        return next;
      }
      var from = next[0];
      var to = new Pos2(next[1].line, next[1].ch - 1);
      if (vim2.visualMode) {
        if (vim2.visualLine || vim2.visualBlock) {
          vim2.visualLine = false;
          vim2.visualBlock = false;
          CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: "" });
        }
        var anchor = vim2.sel.anchor;
        if (anchor) {
          if (state.isReversed()) {
            if (motionArgs.forward) {
              return [anchor, from];
            }
            return [anchor, to];
          } else {
            if (motionArgs.forward) {
              return [anchor, to];
            }
            return [anchor, from];
          }
        }
      } else {
        vim2.visualMode = true;
        vim2.visualLine = false;
        vim2.visualBlock = false;
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: "" });
      }
      return prev ? [to, from] : [from, to];
    },
    goToMark: function(cm, _head, motionArgs, vim2) {
      var pos = getMarkPos(cm, vim2, motionArgs.selectedCharacter);
      if (pos) {
        return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;
      }
      return null;
    },
    moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim2) {
      if (vim2.visualBlock && motionArgs.sameLine) {
        var sel = vim2.sel;
        return [
          clipCursorToContent(cm, new Pos2(sel.anchor.line, sel.head.ch)),
          clipCursorToContent(cm, new Pos2(sel.head.line, sel.anchor.ch))
        ];
      } else {
        return [vim2.sel.head, vim2.sel.anchor];
      }
    },
    jumpToMark: function(cm, head, motionArgs, vim2) {
      var best = head;
      for (var i = 0; i < motionArgs.repeat; i++) {
        var cursor = best;
        for (var key in vim2.marks) {
          if (!isLowerCase(key)) {
            continue;
          }
          var mark = vim2.marks[key].find();
          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);
          if (isWrongDirection) {
            continue;
          }
          if (motionArgs.linewise && mark.line == cursor.line) {
            continue;
          }
          var equal = cursorEqual(cursor, best);
          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);
          if (equal || between) {
            best = mark;
          }
        }
      }
      if (motionArgs.linewise) {
        best = new Pos2(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
      }
      return best;
    },
    moveByCharacters: function(_cm, head, motionArgs) {
      var cur = head;
      var repeat = motionArgs.repeat;
      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
      return new Pos2(cur.line, ch);
    },
    moveByLines: function(cm, head, motionArgs, vim2) {
      var cur = head;
      var endCh = cur.ch;
      switch (vim2.lastMotion) {
        case this.moveByLines:
        case this.moveByDisplayLines:
        case this.moveByScroll:
        case this.moveToColumn:
        case this.moveToEol:
          endCh = vim2.lastHPos;
          break;
        default:
          vim2.lastHPos = endCh;
      }
      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);
      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
      var first = cm.firstLine();
      var last = cm.lastLine();
      var posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, "line", vim2.lastHSPos);
      var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;
      if (hasMarkedText) {
        line = posV.line;
        endCh = posV.ch;
      }
      if (line < first && cur.line == first) {
        return this.moveToStartOfLine(cm, head, motionArgs, vim2);
      } else if (line > last && cur.line == last) {
        return moveToEol(cm, head, motionArgs, vim2, true);
      }
      if (motionArgs.toFirstChar) {
        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));
        vim2.lastHPos = endCh;
      }
      vim2.lastHSPos = cm.charCoords(new Pos2(line, endCh), "div").left;
      return new Pos2(line, endCh);
    },
    moveByDisplayLines: function(cm, head, motionArgs, vim2) {
      var cur = head;
      switch (vim2.lastMotion) {
        case this.moveByDisplayLines:
        case this.moveByScroll:
        case this.moveByLines:
        case this.moveToColumn:
        case this.moveToEol:
          break;
        default:
          vim2.lastHSPos = cm.charCoords(cur, "div").left;
      }
      var repeat = motionArgs.repeat;
      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, "line", vim2.lastHSPos);
      if (res.hitSide) {
        if (motionArgs.forward) {
          var lastCharCoords = cm.charCoords(res, "div");
          var goalCoords = { top: lastCharCoords.top + 8, left: vim2.lastHSPos };
          var res = cm.coordsChar(goalCoords, "div");
        } else {
          var resCoords = cm.charCoords(new Pos2(cm.firstLine(), 0), "div");
          resCoords.left = vim2.lastHSPos;
          res = cm.coordsChar(resCoords, "div");
        }
      }
      vim2.lastHPos = res.ch;
      return res;
    },
    moveByPage: function(cm, head, motionArgs) {
      var curStart = head;
      var repeat = motionArgs.repeat;
      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, "page");
    },
    moveByParagraph: function(cm, head, motionArgs) {
      var dir = motionArgs.forward ? 1 : -1;
      return findParagraph(cm, head, motionArgs.repeat, dir);
    },
    moveBySentence: function(cm, head, motionArgs) {
      var dir = motionArgs.forward ? 1 : -1;
      return findSentence(cm, head, motionArgs.repeat, dir);
    },
    moveByScroll: function(cm, head, motionArgs, vim2) {
      var scrollbox = cm.getScrollInfo();
      var curEnd = null;
      var repeat = motionArgs.repeat;
      if (!repeat) {
        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
      }
      var orig = cm.charCoords(head, "local");
      motionArgs.repeat = repeat;
      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim2);
      if (!curEnd) {
        return null;
      }
      var dest = cm.charCoords(curEnd, "local");
      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
      return curEnd;
    },
    moveByWords: function(cm, head, motionArgs) {
      return moveToWord(
        cm,
        head,
        motionArgs.repeat,
        !!motionArgs.forward,
        !!motionArgs.wordEnd,
        !!motionArgs.bigWord
      );
    },
    moveTillCharacter: function(cm, _head, motionArgs) {
      var repeat = motionArgs.repeat;
      var curEnd = moveToCharacter(
        cm,
        repeat,
        motionArgs.forward,
        motionArgs.selectedCharacter
      );
      var increment = motionArgs.forward ? -1 : 1;
      recordLastCharacterSearch(increment, motionArgs);
      if (!curEnd)
        return null;
      curEnd.ch += increment;
      return curEnd;
    },
    moveToCharacter: function(cm, head, motionArgs) {
      var repeat = motionArgs.repeat;
      recordLastCharacterSearch(0, motionArgs);
      return moveToCharacter(
        cm,
        repeat,
        motionArgs.forward,
        motionArgs.selectedCharacter
      ) || head;
    },
    moveToSymbol: function(cm, head, motionArgs) {
      var repeat = motionArgs.repeat;
      return findSymbol(
        cm,
        repeat,
        motionArgs.forward,
        motionArgs.selectedCharacter
      ) || head;
    },
    moveToColumn: function(cm, head, motionArgs, vim2) {
      var repeat = motionArgs.repeat;
      vim2.lastHPos = repeat - 1;
      vim2.lastHSPos = cm.charCoords(head, "div").left;
      return moveToColumn(cm, repeat);
    },
    moveToEol: function(cm, head, motionArgs, vim2) {
      return moveToEol(cm, head, motionArgs, vim2, false);
    },
    moveToFirstNonWhiteSpaceCharacter: function(cm, head) {
      var cursor = head;
      return new Pos2(
        cursor.line,
        findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line))
      );
    },
    moveToMatchedSymbol: function(cm, head) {
      var cursor = head;
      var line = cursor.line;
      var ch = cursor.ch;
      var lineText = cm.getLine(line);
      var symbol;
      for (; ch < lineText.length; ch++) {
        symbol = lineText.charAt(ch);
        if (symbol && isMatchableSymbol(symbol)) {
          var style = cm.getTokenTypeAt(new Pos2(line, ch + 1));
          if (style !== "string" && style !== "comment") {
            break;
          }
        }
      }
      if (ch < lineText.length) {
        var re = ch === "<" || ch === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/;
        var matched = cm.findMatchingBracket(new Pos2(line, ch), { bracketRegex: re });
        return matched.to;
      } else {
        return cursor;
      }
    },
    moveToStartOfLine: function(_cm, head) {
      return new Pos2(head.line, 0);
    },
    moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {
      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
      if (motionArgs.repeatIsExplicit) {
        lineNum = motionArgs.repeat - cm.getOption("firstLineNumber");
      }
      return new Pos2(
        lineNum,
        findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum))
      );
    },
    moveToStartOfDisplayLine: function(cm) {
      cm.execCommand("goLineLeft");
      return cm.getCursor();
    },
    moveToEndOfDisplayLine: function(cm) {
      cm.execCommand("goLineRight");
      var head = cm.getCursor();
      if (head.sticky == "before")
        head.ch--;
      return head;
    },
    textObjectManipulation: function(cm, head, motionArgs, vim2) {
      var mirroredPairs = {
        "(": ")",
        ")": "(",
        "{": "}",
        "}": "{",
        "[": "]",
        "]": "[",
        "<": ">",
        ">": "<"
      };
      var selfPaired = { "'": true, '"': true, "`": true };
      var character = motionArgs.selectedCharacter;
      if (character == "b") {
        character = "(";
      } else if (character == "B") {
        character = "{";
      }
      var inclusive = !motionArgs.textObjectInner;
      var tmp;
      if (mirroredPairs[character]) {
        tmp = selectCompanionObject(cm, head, character, inclusive);
      } else if (selfPaired[character]) {
        tmp = findBeginningAndEnd(cm, head, character, inclusive);
      } else if (character === "W") {
        tmp = expandWordUnderCursor(
          cm,
          inclusive,
          true,
          true
        );
      } else if (character === "w") {
        tmp = expandWordUnderCursor(
          cm,
          inclusive,
          true,
          false
        );
      } else if (character === "p") {
        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
        motionArgs.linewise = true;
        if (vim2.visualMode) {
          if (!vim2.visualLine) {
            vim2.visualLine = true;
          }
        } else {
          var operatorArgs = vim2.inputState.operatorArgs;
          if (operatorArgs) {
            operatorArgs.linewise = true;
          }
          tmp.end.line--;
        }
      } else if (character === "t") {
        tmp = expandTagUnderCursor(cm, head, inclusive);
      } else if (character === "s") {
        var content = cm.getLine(head.line);
        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {
          head.ch -= 1;
        }
        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);
        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);
        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {
          start = { line: start.line, ch: start.ch + 1 };
        }
        tmp = { start, end };
      } else {
        return null;
      }
      if (!cm.state.vim.visualMode) {
        return [tmp.start, tmp.end];
      } else {
        return expandSelection(cm, tmp.start, tmp.end);
      }
    },
    repeatLastCharacterSearch: function(cm, head, motionArgs) {
      var lastSearch = vimGlobalState.lastCharacterSearch;
      var repeat = motionArgs.repeat;
      var forward = motionArgs.forward === lastSearch.forward;
      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
      cm.moveH(-increment, "char");
      motionArgs.inclusive = forward ? true : false;
      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
      if (!curEnd) {
        cm.moveH(increment, "char");
        return head;
      }
      curEnd.ch += increment;
      return curEnd;
    }
  };
  function defineMotion(name, fn2) {
    motions[name] = fn2;
  }
  function fillArray(val, times) {
    var arr = [];
    for (var i = 0; i < times; i++) {
      arr.push(val);
    }
    return arr;
  }
  var operators = {
    change: function(cm, args, ranges) {
      var finalHead, text;
      var vim2 = cm.state.vim;
      var anchor = ranges[0].anchor, head = ranges[0].head;
      if (!vim2.visualMode) {
        text = cm.getRange(anchor, head);
        var lastState = vim2.lastEditInputState || {};
        if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
          var match = /\s+$/.exec(text);
          if (match && lastState.motionArgs && lastState.motionArgs.forward) {
            head = offsetCursor(head, 0, -match[0].length);
            text = text.slice(0, -match[0].length);
          }
        }
        var prevLineEnd = new Pos2(anchor.line - 1, Number.MAX_VALUE);
        var wasLastLine = cm.firstLine() == cm.lastLine();
        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {
          cm.replaceRange("", prevLineEnd, head);
        } else {
          cm.replaceRange("", anchor, head);
        }
        if (args.linewise) {
          if (!wasLastLine) {
            cm.setCursor(prevLineEnd);
            CodeMirror2.commands.newlineAndIndent(cm);
          }
          anchor.ch = Number.MAX_VALUE;
        }
        finalHead = anchor;
      } else if (args.fullLine) {
        head.ch = Number.MAX_VALUE;
        head.line--;
        cm.setSelection(anchor, head);
        text = cm.getSelection();
        cm.replaceSelection("");
        finalHead = anchor;
      } else {
        text = cm.getSelection();
        var replacement = fillArray("", ranges.length);
        cm.replaceSelections(replacement);
        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
      }
      vimGlobalState.registerController.pushText(
        args.registerName,
        "change",
        text,
        args.linewise,
        ranges.length > 1
      );
      actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);
    },
    "delete": function(cm, args, ranges) {
      var finalHead, text;
      var vim2 = cm.state.vim;
      if (!vim2.visualBlock) {
        var anchor = ranges[0].anchor, head = ranges[0].head;
        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {
          if (anchor.line == cm.firstLine()) {
            anchor.ch = 0;
          } else {
            anchor = new Pos2(anchor.line - 1, lineLength(cm, anchor.line - 1));
          }
        }
        text = cm.getRange(anchor, head);
        cm.replaceRange("", anchor, head);
        finalHead = anchor;
        if (args.linewise) {
          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
        }
      } else {
        text = cm.getSelection();
        var replacement = fillArray("", ranges.length);
        cm.replaceSelections(replacement);
        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
      }
      vimGlobalState.registerController.pushText(
        args.registerName,
        "delete",
        text,
        args.linewise,
        vim2.visualBlock
      );
      return clipCursorToContent(cm, finalHead);
    },
    indent: function(cm, args, ranges) {
      var vim2 = cm.state.vim;
      if (cm.indentMore) {
        var repeat = vim2.visualMode ? args.repeat : 1;
        for (var j = 0; j < repeat; j++) {
          if (args.indentRight)
            cm.indentMore();
          else
            cm.indentLess();
        }
      } else {
        var startLine = ranges[0].anchor.line;
        var endLine = vim2.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;
        var repeat = vim2.visualMode ? args.repeat : 1;
        if (args.linewise) {
          endLine--;
        }
        for (var i = startLine; i <= endLine; i++) {
          for (var j = 0; j < repeat; j++) {
            cm.indentLine(i, args.indentRight);
          }
        }
      }
      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
    },
    indentAuto: function(cm, _args, ranges) {
      cm.execCommand("indentAuto");
      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
    },
    changeCase: function(cm, args, ranges, oldAnchor, newHead) {
      var selections = cm.getSelections();
      var swapped = [];
      var toLower = args.toLower;
      for (var j = 0; j < selections.length; j++) {
        var toSwap = selections[j];
        var text = "";
        if (toLower === true) {
          text = toSwap.toLowerCase();
        } else if (toLower === false) {
          text = toSwap.toUpperCase();
        } else {
          for (var i = 0; i < toSwap.length; i++) {
            var character = toSwap.charAt(i);
            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();
          }
        }
        swapped.push(text);
      }
      cm.replaceSelections(swapped);
      if (args.shouldMoveCursor) {
        return newHead;
      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
      } else if (args.linewise) {
        return oldAnchor;
      } else {
        return cursorMin(ranges[0].anchor, ranges[0].head);
      }
    },
    yank: function(cm, args, ranges, oldAnchor) {
      var vim2 = cm.state.vim;
      var text = cm.getSelection();
      var endPos = vim2.visualMode ? cursorMin(vim2.sel.anchor, vim2.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;
      vimGlobalState.registerController.pushText(
        args.registerName,
        "yank",
        text,
        args.linewise,
        vim2.visualBlock
      );
      return endPos;
    }
  };
  function defineOperator(name, fn2) {
    operators[name] = fn2;
  }
  var actions = {
    jumpListWalk: function(cm, actionArgs, vim2) {
      if (vim2.visualMode) {
        return;
      }
      var repeat = actionArgs.repeat;
      var forward = actionArgs.forward;
      var jumpList = vimGlobalState.jumpList;
      var mark = jumpList.move(cm, forward ? repeat : -repeat);
      var markPos = mark ? mark.find() : void 0;
      markPos = markPos ? markPos : cm.getCursor();
      cm.setCursor(markPos);
    },
    scroll: function(cm, actionArgs, vim2) {
      if (vim2.visualMode) {
        return;
      }
      var repeat = actionArgs.repeat || 1;
      var lineHeight = cm.defaultTextHeight();
      var top = cm.getScrollInfo().top;
      var delta = lineHeight * repeat;
      var newPos = actionArgs.forward ? top + delta : top - delta;
      var cursor = copyCursor(cm.getCursor());
      var cursorCoords = cm.charCoords(cursor, "local");
      if (actionArgs.forward) {
        if (newPos > cursorCoords.top) {
          cursor.line += (newPos - cursorCoords.top) / lineHeight;
          cursor.line = Math.ceil(cursor.line);
          cm.setCursor(cursor);
          cursorCoords = cm.charCoords(cursor, "local");
          cm.scrollTo(null, cursorCoords.top);
        } else {
          cm.scrollTo(null, newPos);
        }
      } else {
        var newBottom = newPos + cm.getScrollInfo().clientHeight;
        if (newBottom < cursorCoords.bottom) {
          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
          cursor.line = Math.floor(cursor.line);
          cm.setCursor(cursor);
          cursorCoords = cm.charCoords(cursor, "local");
          cm.scrollTo(
            null,
            cursorCoords.bottom - cm.getScrollInfo().clientHeight
          );
        } else {
          cm.scrollTo(null, newPos);
        }
      }
    },
    scrollToCursor: function(cm, actionArgs) {
      var lineNum = cm.getCursor().line;
      var charCoords = cm.charCoords(new Pos2(lineNum, 0), "local");
      var height = cm.getScrollInfo().clientHeight;
      var y2 = charCoords.top;
      switch (actionArgs.position) {
        case "center":
          y2 = charCoords.bottom - height / 2;
          break;
        case "bottom":
          var lineLastCharPos = new Pos2(lineNum, cm.getLine(lineNum).length - 1);
          var lineLastCharCoords = cm.charCoords(lineLastCharPos, "local");
          var lineHeight = lineLastCharCoords.bottom - y2;
          y2 = y2 - height + lineHeight;
          break;
      }
      cm.scrollTo(null, y2);
    },
    replayMacro: function(cm, actionArgs, vim2) {
      var registerName = actionArgs.selectedCharacter;
      var repeat = actionArgs.repeat;
      var macroModeState = vimGlobalState.macroModeState;
      if (registerName == "@") {
        registerName = macroModeState.latestRegister;
      } else {
        macroModeState.latestRegister = registerName;
      }
      while (repeat--) {
        executeMacroRegister(cm, vim2, macroModeState, registerName);
      }
    },
    enterMacroRecordMode: function(cm, actionArgs) {
      var macroModeState = vimGlobalState.macroModeState;
      var registerName = actionArgs.selectedCharacter;
      if (vimGlobalState.registerController.isValidRegister(registerName)) {
        macroModeState.enterMacroRecordMode(cm, registerName);
      }
    },
    toggleOverwrite: function(cm) {
      if (!cm.state.overwrite) {
        cm.toggleOverwrite(true);
        cm.setOption("keyMap", "vim-replace");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "replace" });
      } else {
        cm.toggleOverwrite(false);
        cm.setOption("keyMap", "vim-insert");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "insert" });
      }
    },
    enterInsertMode: function(cm, actionArgs, vim2) {
      if (cm.getOption("readOnly")) {
        return;
      }
      vim2.insertMode = true;
      vim2.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
      var insertAt = actionArgs ? actionArgs.insertAt : null;
      var sel = vim2.sel;
      var head = actionArgs.head || cm.getCursor("head");
      var height = cm.listSelections().length;
      if (insertAt == "eol") {
        head = new Pos2(head.line, lineLength(cm, head.line));
      } else if (insertAt == "bol") {
        head = new Pos2(head.line, 0);
      } else if (insertAt == "charAfter") {
        head = offsetCursor(head, 0, 1);
      } else if (insertAt == "firstNonBlank") {
        head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);
      } else if (insertAt == "startOfSelectedArea") {
        if (!vim2.visualMode)
          return;
        if (!vim2.visualBlock) {
          if (sel.head.line < sel.anchor.line) {
            head = sel.head;
          } else {
            head = new Pos2(sel.anchor.line, 0);
          }
        } else {
          head = new Pos2(
            Math.min(sel.head.line, sel.anchor.line),
            Math.min(sel.head.ch, sel.anchor.ch)
          );
          height = Math.abs(sel.head.line - sel.anchor.line) + 1;
        }
      } else if (insertAt == "endOfSelectedArea") {
        if (!vim2.visualMode)
          return;
        if (!vim2.visualBlock) {
          if (sel.head.line >= sel.anchor.line) {
            head = offsetCursor(sel.head, 0, 1);
          } else {
            head = new Pos2(sel.anchor.line, 0);
          }
        } else {
          head = new Pos2(
            Math.min(sel.head.line, sel.anchor.line),
            Math.max(sel.head.ch, sel.anchor.ch) + 1
          );
          height = Math.abs(sel.head.line - sel.anchor.line) + 1;
        }
      } else if (insertAt == "inplace") {
        if (vim2.visualMode) {
          return;
        }
      } else if (insertAt == "lastEdit") {
        head = getLastEditPos(cm) || head;
      }
      cm.setOption("disableInput", false);
      if (actionArgs && actionArgs.replace) {
        cm.toggleOverwrite(true);
        cm.setOption("keyMap", "vim-replace");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "replace" });
      } else {
        cm.toggleOverwrite(false);
        cm.setOption("keyMap", "vim-insert");
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "insert" });
      }
      if (!vimGlobalState.macroModeState.isPlaying) {
        cm.on("change", onChange);
        CodeMirror2.on(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
      }
      if (vim2.visualMode) {
        exitVisualMode(cm);
      }
      selectForInsert(cm, head, height);
    },
    toggleVisualMode: function(cm, actionArgs, vim2) {
      var repeat = actionArgs.repeat;
      var anchor = cm.getCursor();
      var head;
      if (!vim2.visualMode) {
        vim2.visualMode = true;
        vim2.visualLine = !!actionArgs.linewise;
        vim2.visualBlock = !!actionArgs.blockwise;
        head = clipCursorToContent(
          cm,
          new Pos2(anchor.line, anchor.ch + repeat - 1)
        );
        vim2.sel = {
          anchor,
          head
        };
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim2.visualLine ? "linewise" : vim2.visualBlock ? "blockwise" : "" });
        updateCmSelection(cm);
        updateMark(cm, vim2, "<", cursorMin(anchor, head));
        updateMark(cm, vim2, ">", cursorMax(anchor, head));
      } else if (vim2.visualLine ^ actionArgs.linewise || vim2.visualBlock ^ actionArgs.blockwise) {
        vim2.visualLine = !!actionArgs.linewise;
        vim2.visualBlock = !!actionArgs.blockwise;
        CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual", subMode: vim2.visualLine ? "linewise" : vim2.visualBlock ? "blockwise" : "" });
        updateCmSelection(cm);
      } else {
        exitVisualMode(cm);
      }
    },
    reselectLastSelection: function(cm, _actionArgs, vim2) {
      var lastSelection = vim2.lastSelection;
      if (vim2.visualMode) {
        updateLastSelection(cm, vim2);
      }
      if (lastSelection) {
        var anchor = lastSelection.anchorMark.find();
        var head = lastSelection.headMark.find();
        if (!anchor || !head) {
          return;
        }
        vim2.sel = {
          anchor,
          head
        };
        vim2.visualMode = true;
        vim2.visualLine = lastSelection.visualLine;
        vim2.visualBlock = lastSelection.visualBlock;
        updateCmSelection(cm);
        updateMark(cm, vim2, "<", cursorMin(anchor, head));
        updateMark(cm, vim2, ">", cursorMax(anchor, head));
        CodeMirror2.signal(cm, "vim-mode-change", {
          mode: "visual",
          subMode: vim2.visualLine ? "linewise" : vim2.visualBlock ? "blockwise" : ""
        });
      }
    },
    joinLines: function(cm, actionArgs, vim2) {
      var curStart, curEnd;
      if (vim2.visualMode) {
        curStart = cm.getCursor("anchor");
        curEnd = cm.getCursor("head");
        if (cursorIsBefore(curEnd, curStart)) {
          var tmp = curEnd;
          curEnd = curStart;
          curStart = tmp;
        }
        curEnd.ch = lineLength(cm, curEnd.line) - 1;
      } else {
        var repeat = Math.max(actionArgs.repeat, 2);
        curStart = cm.getCursor();
        curEnd = clipCursorToContent(cm, new Pos2(
          curStart.line + repeat - 1,
          Infinity
        ));
      }
      var finalCh = 0;
      for (var i = curStart.line; i < curEnd.line; i++) {
        finalCh = lineLength(cm, curStart.line);
        var tmp = new Pos2(
          curStart.line + 1,
          lineLength(cm, curStart.line + 1)
        );
        var text = cm.getRange(curStart, tmp);
        text = actionArgs.keepSpaces ? text.replace(/\n\r?/g, "") : text.replace(/\n\s*/g, " ");
        cm.replaceRange(text, curStart, tmp);
      }
      var curFinalPos = new Pos2(curStart.line, finalCh);
      if (vim2.visualMode) {
        exitVisualMode(cm, false);
      }
      cm.setCursor(curFinalPos);
    },
    newLineAndEnterInsertMode: function(cm, actionArgs, vim2) {
      vim2.insertMode = true;
      var insertAt = copyCursor(cm.getCursor());
      if (insertAt.line === cm.firstLine() && !actionArgs.after) {
        cm.replaceRange("\n", new Pos2(cm.firstLine(), 0));
        cm.setCursor(cm.firstLine(), 0);
      } else {
        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;
        insertAt.ch = lineLength(cm, insertAt.line);
        cm.setCursor(insertAt);
        var newlineFn = CodeMirror2.commands.newlineAndIndentContinueComment || CodeMirror2.commands.newlineAndIndent;
        newlineFn(cm);
      }
      this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim2);
    },
    paste: function(cm, actionArgs, vim2) {
      var register = vimGlobalState.registerController.getRegister(
        actionArgs.registerName
      );
      if (actionArgs.registerName === "+") {
        navigator.clipboard.readText().then((value) => {
          this.continuePaste(cm, actionArgs, vim2, value, register);
        });
      } else {
        var text = register.toString();
        this.continuePaste(cm, actionArgs, vim2, text, register);
      }
    },
    continuePaste: function(cm, actionArgs, vim2, text, register) {
      var cur = copyCursor(cm.getCursor());
      if (!text) {
        return;
      }
      if (actionArgs.matchIndent) {
        var tabSize = cm.getOption("tabSize");
        var whitespaceLength = function(str) {
          var tabs = str.split("	").length - 1;
          var spaces = str.split(" ").length - 1;
          return tabs * tabSize + spaces * 1;
        };
        var currentLine = cm.getLine(cm.getCursor().line);
        var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
        var chompedText = text.replace(/\n$/, "");
        var wasChomped = text !== chompedText;
        var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
        var text = chompedText.replace(/^\s*/gm, function(wspace) {
          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
          if (newIndent < 0) {
            return "";
          } else if (cm.getOption("indentWithTabs")) {
            var quotient = Math.floor(newIndent / tabSize);
            return Array(quotient + 1).join("	");
          } else {
            return Array(newIndent + 1).join(" ");
          }
        });
        text += wasChomped ? "\n" : "";
      }
      if (actionArgs.repeat > 1) {
        var text = Array(actionArgs.repeat + 1).join(text);
      }
      var linewise = register.linewise;
      var blockwise = register.blockwise;
      if (blockwise) {
        text = text.split("\n");
        if (linewise) {
          text.pop();
        }
        for (var i = 0; i < text.length; i++) {
          text[i] = text[i] == "" ? " " : text[i];
        }
        cur.ch += actionArgs.after ? 1 : 0;
        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
      } else if (linewise) {
        if (vim2.visualMode) {
          text = vim2.visualLine ? text.slice(0, -1) : "\n" + text.slice(0, text.length - 1) + "\n";
        } else if (actionArgs.after) {
          text = "\n" + text.slice(0, text.length - 1);
          cur.ch = lineLength(cm, cur.line);
        } else {
          cur.ch = 0;
        }
      } else {
        cur.ch += actionArgs.after ? 1 : 0;
      }
      var curPosFinal;
      var idx;
      if (vim2.visualMode) {
        vim2.lastPastedText = text;
        var lastSelectionCurEnd;
        var selectedArea = getSelectedAreaRange(cm, vim2);
        var selectionStart = selectedArea[0];
        var selectionEnd = selectedArea[1];
        var selectedText = cm.getSelection();
        var selections = cm.listSelections();
        var emptyStrings = new Array(selections.length).join("1").split("1");
        if (vim2.lastSelection) {
          lastSelectionCurEnd = vim2.lastSelection.headMark.find();
        }
        vimGlobalState.registerController.unnamedRegister.setText(selectedText);
        if (blockwise) {
          cm.replaceSelections(emptyStrings);
          selectionEnd = new Pos2(selectionStart.line + text.length - 1, selectionStart.ch);
          cm.setCursor(selectionStart);
          selectBlock(cm, selectionEnd);
          cm.replaceSelections(text);
          curPosFinal = selectionStart;
        } else if (vim2.visualBlock) {
          cm.replaceSelections(emptyStrings);
          cm.setCursor(selectionStart);
          cm.replaceRange(text, selectionStart, selectionStart);
          curPosFinal = selectionStart;
        } else {
          cm.replaceRange(text, selectionStart, selectionEnd);
          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
        }
        if (lastSelectionCurEnd) {
          vim2.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
        }
        if (linewise) {
          curPosFinal.ch = 0;
        }
      } else {
        if (blockwise) {
          cm.setCursor(cur);
          for (var i = 0; i < text.length; i++) {
            var line = cur.line + i;
            if (line > cm.lastLine()) {
              cm.replaceRange("\n", new Pos2(line, 0));
            }
            var lastCh = lineLength(cm, line);
            if (lastCh < cur.ch) {
              extendLineToColumn(cm, line, cur.ch);
            }
          }
          cm.setCursor(cur);
          selectBlock(cm, new Pos2(cur.line + text.length - 1, cur.ch));
          cm.replaceSelections(text);
          curPosFinal = cur;
        } else {
          cm.replaceRange(text, cur);
          if (linewise && actionArgs.after) {
            curPosFinal = new Pos2(
              cur.line + 1,
              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1))
            );
          } else if (linewise && !actionArgs.after) {
            curPosFinal = new Pos2(
              cur.line,
              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line))
            );
          } else if (!linewise && actionArgs.after) {
            idx = cm.indexFromPos(cur);
            curPosFinal = cm.posFromIndex(idx + text.length - 1);
          } else {
            idx = cm.indexFromPos(cur);
            curPosFinal = cm.posFromIndex(idx + text.length);
          }
        }
      }
      if (vim2.visualMode) {
        exitVisualMode(cm, false);
      }
      cm.setCursor(curPosFinal);
    },
    undo: function(cm, actionArgs) {
      cm.operation(function() {
        repeatFn(cm, CodeMirror2.commands.undo, actionArgs.repeat)();
        cm.setCursor(cm.getCursor("anchor"));
      });
    },
    redo: function(cm, actionArgs) {
      repeatFn(cm, CodeMirror2.commands.redo, actionArgs.repeat)();
    },
    setRegister: function(_cm, actionArgs, vim2) {
      vim2.inputState.registerName = actionArgs.selectedCharacter;
    },
    setMark: function(cm, actionArgs, vim2) {
      var markName = actionArgs.selectedCharacter;
      updateMark(cm, vim2, markName, cm.getCursor());
    },
    replace: function(cm, actionArgs, vim2) {
      var replaceWith = actionArgs.selectedCharacter;
      var curStart = cm.getCursor();
      var replaceTo;
      var curEnd;
      var selections = cm.listSelections();
      if (vim2.visualMode) {
        curStart = cm.getCursor("start");
        curEnd = cm.getCursor("end");
      } else {
        var line = cm.getLine(curStart.line);
        replaceTo = curStart.ch + actionArgs.repeat;
        if (replaceTo > line.length) {
          replaceTo = line.length;
        }
        curEnd = new Pos2(curStart.line, replaceTo);
      }
      if (replaceWith == "\n") {
        if (!vim2.visualMode)
          cm.replaceRange("", curStart, curEnd);
        (CodeMirror2.commands.newlineAndIndentContinueComment || CodeMirror2.commands.newlineAndIndent)(cm);
      } else {
        var replaceWithStr = cm.getRange(curStart, curEnd);
        replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
        if (vim2.visualBlock) {
          var spaces = new Array(cm.getOption("tabSize") + 1).join(" ");
          replaceWithStr = cm.getSelection();
          replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split("\n");
          cm.replaceSelections(replaceWithStr);
        } else {
          cm.replaceRange(replaceWithStr, curStart, curEnd);
        }
        if (vim2.visualMode) {
          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;
          cm.setCursor(curStart);
          exitVisualMode(cm, false);
        } else {
          cm.setCursor(offsetCursor(curEnd, 0, -1));
        }
      }
    },
    incrementNumberToken: function(cm, actionArgs) {
      var cur = cm.getCursor();
      var lineStr = cm.getLine(cur.line);
      var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
      var match;
      var start;
      var end;
      var numberStr;
      while ((match = re.exec(lineStr)) !== null) {
        start = match.index;
        end = start + match[0].length;
        if (cur.ch < end)
          break;
      }
      if (!actionArgs.backtrack && end <= cur.ch)
        return;
      if (match) {
        var baseStr = match[2] || match[4];
        var digits = match[3] || match[5];
        var increment = actionArgs.increase ? 1 : -1;
        var base = { "0b": 2, "0": 8, "": 10, "0x": 16 }[baseStr.toLowerCase()];
        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;
        numberStr = number.toString(base);
        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join("0") : "";
        if (numberStr.charAt(0) === "-") {
          numberStr = "-" + baseStr + zeroPadding + numberStr.substr(1);
        } else {
          numberStr = baseStr + zeroPadding + numberStr;
        }
        var from = new Pos2(cur.line, start);
        var to = new Pos2(cur.line, end);
        cm.replaceRange(numberStr, from, to);
      } else {
        return;
      }
      cm.setCursor(new Pos2(cur.line, start + numberStr.length - 1));
    },
    repeatLastEdit: function(cm, actionArgs, vim2) {
      var lastEditInputState = vim2.lastEditInputState;
      if (!lastEditInputState) {
        return;
      }
      var repeat = actionArgs.repeat;
      if (repeat && actionArgs.repeatIsExplicit) {
        vim2.lastEditInputState.repeatOverride = repeat;
      } else {
        repeat = vim2.lastEditInputState.repeatOverride || repeat;
      }
      repeatLastEdit(cm, vim2, repeat, false);
    },
    indent: function(cm, actionArgs) {
      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
    },
    exitInsertMode
  };
  function defineAction(name, fn2) {
    actions[name] = fn2;
  }
  function clipCursorToContent(cm, cur) {
    var vim2 = cm.state.vim;
    var includeLineBreak = vim2.insertMode || vim2.visualMode;
    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());
    var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;
    var ch = Math.min(Math.max(0, cur.ch), maxCh);
    return new Pos2(line, ch);
  }
  function copyArgs(args) {
    var ret = {};
    for (var prop in args) {
      if (args.hasOwnProperty(prop)) {
        ret[prop] = args[prop];
      }
    }
    return ret;
  }
  function offsetCursor(cur, offsetLine, offsetCh) {
    if (typeof offsetLine === "object") {
      offsetCh = offsetLine.ch;
      offsetLine = offsetLine.line;
    }
    return new Pos2(cur.line + offsetLine, cur.ch + offsetCh);
  }
  function commandMatches(keys, keyMap, context, inputState) {
    var match, partial = [], full = [];
    for (var i = 0; i < keyMap.length; i++) {
      var command2 = keyMap[i];
      if (context == "insert" && command2.context != "insert" || command2.context && command2.context != context || inputState.operator && command2.type == "action" || !(match = commandMatch(keys, command2.keys))) {
        continue;
      }
      if (match == "partial") {
        partial.push(command2);
      }
      if (match == "full") {
        full.push(command2);
      }
    }
    return {
      partial: partial.length && partial,
      full: full.length && full
    };
  }
  function commandMatch(pressed, mapped) {
    if (mapped.slice(-11) == "<character>") {
      var prefixLen = mapped.length - 11;
      var pressedPrefix = pressed.slice(0, prefixLen);
      var mappedPrefix = mapped.slice(0, prefixLen);
      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? "full" : mappedPrefix.indexOf(pressedPrefix) == 0 ? "partial" : false;
    } else {
      return pressed == mapped ? "full" : mapped.indexOf(pressed) == 0 ? "partial" : false;
    }
  }
  function lastChar(keys) {
    var match = /^.*(<[^>]+>)$/.exec(keys);
    var selectedCharacter = match ? match[1] : keys.slice(-1);
    if (selectedCharacter.length > 1) {
      switch (selectedCharacter) {
        case "<CR>":
          selectedCharacter = "\n";
          break;
        case "<Space>":
          selectedCharacter = " ";
          break;
        default:
          selectedCharacter = "";
          break;
      }
    }
    return selectedCharacter;
  }
  function repeatFn(cm, fn2, repeat) {
    return function() {
      for (var i = 0; i < repeat; i++) {
        fn2(cm);
      }
    };
  }
  function copyCursor(cur) {
    return new Pos2(cur.line, cur.ch);
  }
  function cursorEqual(cur1, cur2) {
    return cur1.ch == cur2.ch && cur1.line == cur2.line;
  }
  function cursorIsBefore(cur1, cur2) {
    if (cur1.line < cur2.line) {
      return true;
    }
    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
      return true;
    }
    return false;
  }
  function cursorMin(cur1, cur2) {
    if (arguments.length > 2) {
      cur2 = cursorMin.apply(void 0, Array.prototype.slice.call(arguments, 1));
    }
    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
  }
  function cursorMax(cur1, cur2) {
    if (arguments.length > 2) {
      cur2 = cursorMax.apply(void 0, Array.prototype.slice.call(arguments, 1));
    }
    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
  }
  function cursorIsBetween(cur1, cur2, cur3) {
    var cur1before2 = cursorIsBefore(cur1, cur2);
    var cur2before3 = cursorIsBefore(cur2, cur3);
    return cur1before2 && cur2before3;
  }
  function lineLength(cm, lineNum) {
    return cm.getLine(lineNum).length;
  }
  function trim(s) {
    if (s.trim) {
      return s.trim();
    }
    return s.replace(/^\s+|\s+$/g, "");
  }
  function escapeRegex(s) {
    return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
  }
  function extendLineToColumn(cm, lineNum, column) {
    var endCh = lineLength(cm, lineNum);
    var spaces = new Array(column - endCh + 1).join(" ");
    cm.setCursor(new Pos2(lineNum, endCh));
    cm.replaceRange(spaces, cm.getCursor());
  }
  function selectBlock(cm, selectionEnd) {
    var selections = [], ranges = cm.listSelections();
    var head = copyCursor(cm.clipPos(selectionEnd));
    var isClipped = !cursorEqual(selectionEnd, head);
    var curHead = cm.getCursor("head");
    var primIndex = getIndex(ranges, curHead);
    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
    var max = ranges.length - 1;
    var index = max - primIndex > primIndex ? max : 0;
    var base = ranges[index].anchor;
    var firstLine = Math.min(base.line, head.line);
    var lastLine = Math.max(base.line, head.line);
    var baseCh = base.ch, headCh = head.ch;
    var dir = ranges[index].head.ch - baseCh;
    var newDir = headCh - baseCh;
    if (dir > 0 && newDir <= 0) {
      baseCh++;
      if (!isClipped) {
        headCh--;
      }
    } else if (dir < 0 && newDir >= 0) {
      baseCh--;
      if (!wasClipped) {
        headCh++;
      }
    } else if (dir < 0 && newDir == -1) {
      baseCh--;
      headCh++;
    }
    for (var line = firstLine; line <= lastLine; line++) {
      var range = { anchor: new Pos2(line, baseCh), head: new Pos2(line, headCh) };
      selections.push(range);
    }
    cm.setSelections(selections);
    selectionEnd.ch = headCh;
    base.ch = baseCh;
    return base;
  }
  function selectForInsert(cm, head, height) {
    var sel = [];
    for (var i = 0; i < height; i++) {
      var lineHead = offsetCursor(head, i, 0);
      sel.push({ anchor: lineHead, head: lineHead });
    }
    cm.setSelections(sel, 0);
  }
  function getIndex(ranges, cursor, end) {
    for (var i = 0; i < ranges.length; i++) {
      var atAnchor = end != "head" && cursorEqual(ranges[i].anchor, cursor);
      var atHead = end != "anchor" && cursorEqual(ranges[i].head, cursor);
      if (atAnchor || atHead) {
        return i;
      }
    }
    return -1;
  }
  function getSelectedAreaRange(cm, vim2) {
    var lastSelection = vim2.lastSelection;
    var getCurrentSelectedAreaRange = function() {
      var selections = cm.listSelections();
      var start = selections[0];
      var end = selections[selections.length - 1];
      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
      return [selectionStart, selectionEnd];
    };
    var getLastSelectedAreaRange = function() {
      var selectionStart = cm.getCursor();
      var selectionEnd = cm.getCursor();
      var block = lastSelection.visualBlock;
      if (block) {
        var width = block.width;
        var height = block.height;
        selectionEnd = new Pos2(selectionStart.line + height, selectionStart.ch + width);
        var selections = [];
        for (var i = selectionStart.line; i < selectionEnd.line; i++) {
          var anchor = new Pos2(i, selectionStart.ch);
          var head = new Pos2(i, selectionEnd.ch);
          var range = { anchor, head };
          selections.push(range);
        }
        cm.setSelections(selections);
      } else {
        var start = lastSelection.anchorMark.find();
        var end = lastSelection.headMark.find();
        var line = end.line - start.line;
        var ch = end.ch - start.ch;
        selectionEnd = { line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch };
        if (lastSelection.visualLine) {
          selectionStart = new Pos2(selectionStart.line, 0);
          selectionEnd = new Pos2(selectionEnd.line, lineLength(cm, selectionEnd.line));
        }
        cm.setSelection(selectionStart, selectionEnd);
      }
      return [selectionStart, selectionEnd];
    };
    if (!vim2.visualMode) {
      return getLastSelectedAreaRange();
    } else {
      return getCurrentSelectedAreaRange();
    }
  }
  function updateLastSelection(cm, vim2) {
    var anchor = vim2.sel.anchor;
    var head = vim2.sel.head;
    if (vim2.lastPastedText) {
      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim2.lastPastedText.length);
      vim2.lastPastedText = null;
    }
    vim2.lastSelection = {
      "anchorMark": cm.setBookmark(anchor),
      "headMark": cm.setBookmark(head),
      "anchor": copyCursor(anchor),
      "head": copyCursor(head),
      "visualMode": vim2.visualMode,
      "visualLine": vim2.visualLine,
      "visualBlock": vim2.visualBlock
    };
  }
  function expandSelection(cm, start, end) {
    var sel = cm.state.vim.sel;
    var head = sel.head;
    var anchor = sel.anchor;
    var tmp;
    if (cursorIsBefore(end, start)) {
      tmp = end;
      end = start;
      start = tmp;
    }
    if (cursorIsBefore(head, anchor)) {
      head = cursorMin(start, head);
      anchor = cursorMax(anchor, end);
    } else {
      anchor = cursorMin(start, anchor);
      head = cursorMax(head, end);
      head = offsetCursor(head, 0, -1);
      if (head.ch == -1 && head.line != cm.firstLine()) {
        head = new Pos2(head.line - 1, lineLength(cm, head.line - 1));
      }
    }
    return [anchor, head];
  }
  function updateCmSelection(cm, sel, mode) {
    var vim2 = cm.state.vim;
    sel = sel || vim2.sel;
    var mode = mode || vim2.visualLine ? "line" : vim2.visualBlock ? "block" : "char";
    var cmSel = makeCmSelection(cm, sel, mode);
    cm.setSelections(cmSel.ranges, cmSel.primary);
  }
  function makeCmSelection(cm, sel, mode, exclusive) {
    var head = copyCursor(sel.head);
    var anchor = copyCursor(sel.anchor);
    if (mode == "char") {
      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
      head = offsetCursor(sel.head, 0, headOffset);
      anchor = offsetCursor(sel.anchor, 0, anchorOffset);
      return {
        ranges: [{ anchor, head }],
        primary: 0
      };
    } else if (mode == "line") {
      if (!cursorIsBefore(sel.head, sel.anchor)) {
        anchor.ch = 0;
        var lastLine = cm.lastLine();
        if (head.line > lastLine) {
          head.line = lastLine;
        }
        head.ch = lineLength(cm, head.line);
      } else {
        head.ch = 0;
        anchor.ch = lineLength(cm, anchor.line);
      }
      return {
        ranges: [{ anchor, head }],
        primary: 0
      };
    } else if (mode == "block") {
      var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;
      if (fromCh < toCh) {
        toCh += 1;
      } else {
        fromCh += 1;
      }
      var height = bottom - top + 1;
      var primary = head.line == top ? 0 : height - 1;
      var ranges = [];
      for (var i = 0; i < height; i++) {
        ranges.push({
          anchor: new Pos2(top + i, fromCh),
          head: new Pos2(top + i, toCh)
        });
      }
      return {
        ranges,
        primary
      };
    }
  }
  function getHead(cm) {
    var cur = cm.getCursor("head");
    if (cm.getSelection().length == 1) {
      cur = cursorMin(cur, cm.getCursor("anchor"));
    }
    return cur;
  }
  function exitVisualMode(cm, moveHead) {
    var vim2 = cm.state.vim;
    if (moveHead !== false) {
      cm.setCursor(clipCursorToContent(cm, vim2.sel.head));
    }
    updateLastSelection(cm, vim2);
    vim2.visualMode = false;
    vim2.visualLine = false;
    vim2.visualBlock = false;
    if (!vim2.insertMode)
      CodeMirror2.signal(cm, "vim-mode-change", { mode: "normal" });
  }
  function clipToLine(cm, curStart, curEnd) {
    var selection = cm.getRange(curStart, curEnd);
    if (/\n\s*$/.test(selection)) {
      var lines = selection.split("\n");
      lines.pop();
      var line;
      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
        curEnd.line--;
        curEnd.ch = 0;
      }
      if (line) {
        curEnd.line--;
        curEnd.ch = lineLength(cm, curEnd.line);
      } else {
        curEnd.ch = 0;
      }
    }
  }
  function expandSelectionToLine(_cm, curStart, curEnd) {
    curStart.ch = 0;
    curEnd.ch = 0;
    curEnd.line++;
  }
  function findFirstNonWhiteSpaceCharacter(text) {
    if (!text) {
      return 0;
    }
    var firstNonWS = text.search(/\S/);
    return firstNonWS == -1 ? text.length : firstNonWS;
  }
  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
    var cur = getHead(cm);
    var line = cm.getLine(cur.line);
    var idx = cur.ch;
    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];
    while (!test(line.charAt(idx))) {
      idx++;
      if (idx >= line.length) {
        return null;
      }
    }
    if (bigWord) {
      test = bigWordCharTest[0];
    } else {
      test = wordCharTest[0];
      if (!test(line.charAt(idx))) {
        test = wordCharTest[1];
      }
    }
    var end = idx, start = idx;
    while (test(line.charAt(end)) && end < line.length) {
      end++;
    }
    while (test(line.charAt(start)) && start >= 0) {
      start--;
    }
    start++;
    if (inclusive) {
      var wordEnd = end;
      while (/\s/.test(line.charAt(end)) && end < line.length) {
        end++;
      }
      if (wordEnd == end) {
        var wordStart = start;
        while (/\s/.test(line.charAt(start - 1)) && start > 0) {
          start--;
        }
        if (!start) {
          start = wordStart;
        }
      }
    }
    return { start: new Pos2(cur.line, start), end: new Pos2(cur.line, end) };
  }
  function expandTagUnderCursor(cm, head, inclusive) {
    var cur = head;
    if (!CodeMirror2.findMatchingTag || !CodeMirror2.findEnclosingTag) {
      return { start: cur, end: cur };
    }
    var tags2 = CodeMirror2.findMatchingTag(cm, head) || CodeMirror2.findEnclosingTag(cm, head);
    if (!tags2 || !tags2.open || !tags2.close) {
      return { start: cur, end: cur };
    }
    if (inclusive) {
      return { start: tags2.open.from, end: tags2.close.to };
    }
    return { start: tags2.open.to, end: tags2.close.from };
  }
  function recordJumpPosition(cm, oldCur, newCur) {
    if (!cursorEqual(oldCur, newCur)) {
      vimGlobalState.jumpList.add(cm, oldCur, newCur);
    }
  }
  function recordLastCharacterSearch(increment, args) {
    vimGlobalState.lastCharacterSearch.increment = increment;
    vimGlobalState.lastCharacterSearch.forward = args.forward;
    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
  }
  var symbolToMode = {
    "(": "bracket",
    ")": "bracket",
    "{": "bracket",
    "}": "bracket",
    "[": "section",
    "]": "section",
    "*": "comment",
    "/": "comment",
    "m": "method",
    "M": "method",
    "#": "preprocess"
  };
  var findSymbolModes = {
    bracket: {
      isComplete: function(state) {
        if (state.nextCh === state.symb) {
          state.depth++;
          if (state.depth >= 1)
            return true;
        } else if (state.nextCh === state.reverseSymb) {
          state.depth--;
        }
        return false;
      }
    },
    section: {
      init: function(state) {
        state.curMoveThrough = true;
        state.symb = (state.forward ? "]" : "[") === state.symb ? "{" : "}";
      },
      isComplete: function(state) {
        return state.index === 0 && state.nextCh === state.symb;
      }
    },
    comment: {
      isComplete: function(state) {
        var found = state.lastCh === "*" && state.nextCh === "/";
        state.lastCh = state.nextCh;
        return found;
      }
    },
    method: {
      init: function(state) {
        state.symb = state.symb === "m" ? "{" : "}";
        state.reverseSymb = state.symb === "{" ? "}" : "{";
      },
      isComplete: function(state) {
        if (state.nextCh === state.symb)
          return true;
        return false;
      }
    },
    preprocess: {
      init: function(state) {
        state.index = 0;
      },
      isComplete: function(state) {
        if (state.nextCh === "#") {
          var token = state.lineText.match(/^#(\w+)/)[1];
          if (token === "endif") {
            if (state.forward && state.depth === 0) {
              return true;
            }
            state.depth++;
          } else if (token === "if") {
            if (!state.forward && state.depth === 0) {
              return true;
            }
            state.depth--;
          }
          if (token === "else" && state.depth === 0)
            return true;
        }
        return false;
      }
    }
  };
  function findSymbol(cm, repeat, forward, symb) {
    var cur = copyCursor(cm.getCursor());
    var increment = forward ? 1 : -1;
    var endLine = forward ? cm.lineCount() : -1;
    var curCh = cur.ch;
    var line = cur.line;
    var lineText = cm.getLine(line);
    var state = {
      lineText,
      nextCh: lineText.charAt(curCh),
      lastCh: null,
      index: curCh,
      symb,
      reverseSymb: (forward ? { ")": "(", "}": "{" } : { "(": ")", "{": "}" })[symb],
      forward,
      depth: 0,
      curMoveThrough: false
    };
    var mode = symbolToMode[symb];
    if (!mode)
      return cur;
    var init = findSymbolModes[mode].init;
    var isComplete = findSymbolModes[mode].isComplete;
    if (init) {
      init(state);
    }
    while (line !== endLine && repeat) {
      state.index += increment;
      state.nextCh = state.lineText.charAt(state.index);
      if (!state.nextCh) {
        line += increment;
        state.lineText = cm.getLine(line) || "";
        if (increment > 0) {
          state.index = 0;
        } else {
          var lineLen = state.lineText.length;
          state.index = lineLen > 0 ? lineLen - 1 : 0;
        }
        state.nextCh = state.lineText.charAt(state.index);
      }
      if (isComplete(state)) {
        cur.line = line;
        cur.ch = state.index;
        repeat--;
      }
    }
    if (state.nextCh || state.curMoveThrough) {
      return new Pos2(line, state.index);
    }
    return cur;
  }
  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
    var lineNum = cur.line;
    var pos = cur.ch;
    var line = cm.getLine(lineNum);
    var dir = forward ? 1 : -1;
    var charTests = bigWord ? bigWordCharTest : wordCharTest;
    if (emptyLineIsWord && line == "") {
      lineNum += dir;
      line = cm.getLine(lineNum);
      if (!isLine(cm, lineNum)) {
        return null;
      }
      pos = forward ? 0 : line.length;
    }
    while (true) {
      if (emptyLineIsWord && line == "") {
        return { from: 0, to: 0, line: lineNum };
      }
      var stop = dir > 0 ? line.length : -1;
      var wordStart = stop, wordEnd = stop;
      while (pos != stop) {
        var foundWord = false;
        for (var i = 0; i < charTests.length && !foundWord; ++i) {
          if (charTests[i](line.charAt(pos))) {
            wordStart = pos;
            while (pos != stop && charTests[i](line.charAt(pos))) {
              pos += dir;
            }
            wordEnd = pos;
            foundWord = wordStart != wordEnd;
            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {
              continue;
            } else {
              return {
                from: Math.min(wordStart, wordEnd + 1),
                to: Math.max(wordStart, wordEnd),
                line: lineNum
              };
            }
          }
        }
        if (!foundWord) {
          pos += dir;
        }
      }
      lineNum += dir;
      if (!isLine(cm, lineNum)) {
        return null;
      }
      line = cm.getLine(lineNum);
      pos = dir > 0 ? 0 : line.length;
    }
  }
  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
    var curStart = copyCursor(cur);
    var words = [];
    if (forward && !wordEnd || !forward && wordEnd) {
      repeat++;
    }
    var emptyLineIsWord = !(forward && wordEnd);
    for (var i = 0; i < repeat; i++) {
      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
      if (!word) {
        var eodCh = lineLength(cm, cm.lastLine());
        words.push(forward ? { line: cm.lastLine(), from: eodCh, to: eodCh } : { line: 0, from: 0, to: 0 });
        break;
      }
      words.push(word);
      cur = new Pos2(word.line, forward ? word.to - 1 : word.from);
    }
    var shortCircuit = words.length != repeat;
    var firstWord = words[0];
    var lastWord = words.pop();
    if (forward && !wordEnd) {
      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
        lastWord = words.pop();
      }
      return new Pos2(lastWord.line, lastWord.from);
    } else if (forward && wordEnd) {
      return new Pos2(lastWord.line, lastWord.to - 1);
    } else if (!forward && wordEnd) {
      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
        lastWord = words.pop();
      }
      return new Pos2(lastWord.line, lastWord.to);
    } else {
      return new Pos2(lastWord.line, lastWord.from);
    }
  }
  function moveToEol(cm, head, motionArgs, vim2, keepHPos) {
    var cur = head;
    var retval = new Pos2(cur.line + motionArgs.repeat - 1, Infinity);
    var end = cm.clipPos(retval);
    end.ch--;
    if (!keepHPos) {
      vim2.lastHPos = Infinity;
      vim2.lastHSPos = cm.charCoords(end, "div").left;
    }
    return retval;
  }
  function moveToCharacter(cm, repeat, forward, character) {
    var cur = cm.getCursor();
    var start = cur.ch;
    var idx;
    for (var i = 0; i < repeat; i++) {
      var line = cm.getLine(cur.line);
      idx = charIdxInLine(start, line, character, forward, true);
      if (idx == -1) {
        return null;
      }
      start = idx;
    }
    return new Pos2(cm.getCursor().line, idx);
  }
  function moveToColumn(cm, repeat) {
    var line = cm.getCursor().line;
    return clipCursorToContent(cm, new Pos2(line, repeat - 1));
  }
  function updateMark(cm, vim2, markName, pos) {
    if (!inArray(markName, validMarks)) {
      return;
    }
    if (vim2.marks[markName]) {
      vim2.marks[markName].clear();
    }
    vim2.marks[markName] = cm.setBookmark(pos);
  }
  function charIdxInLine(start, line, character, forward, includeChar) {
    var idx;
    if (forward) {
      idx = line.indexOf(character, start + 1);
      if (idx != -1 && !includeChar) {
        idx -= 1;
      }
    } else {
      idx = line.lastIndexOf(character, start - 1);
      if (idx != -1 && !includeChar) {
        idx += 1;
      }
    }
    return idx;
  }
  function findParagraph(cm, head, repeat, dir, inclusive) {
    var line = head.line;
    var min = cm.firstLine();
    var max = cm.lastLine();
    var start, end, i = line;
    function isEmpty(i2) {
      return !cm.getLine(i2);
    }
    function isBoundary(i2, dir2, any) {
      if (any) {
        return isEmpty(i2) != isEmpty(i2 + dir2);
      }
      return !isEmpty(i2) && isEmpty(i2 + dir2);
    }
    if (dir) {
      while (min <= i && i <= max && repeat > 0) {
        if (isBoundary(i, dir)) {
          repeat--;
        }
        i += dir;
      }
      return new Pos2(i, 0);
    }
    var vim2 = cm.state.vim;
    if (vim2.visualLine && isBoundary(line, 1, true)) {
      var anchor = vim2.sel.anchor;
      if (isBoundary(anchor.line, -1, true)) {
        if (!inclusive || anchor.line != line) {
          line += 1;
        }
      }
    }
    var startState = isEmpty(line);
    for (i = line; i <= max && repeat; i++) {
      if (isBoundary(i, 1, true)) {
        if (!inclusive || isEmpty(i) != startState) {
          repeat--;
        }
      }
    }
    end = new Pos2(i, 0);
    if (i > max && !startState) {
      startState = true;
    } else {
      inclusive = false;
    }
    for (i = line; i > min; i--) {
      if (!inclusive || isEmpty(i) == startState || i == line) {
        if (isBoundary(i, -1, true)) {
          break;
        }
      }
    }
    start = new Pos2(i, 0);
    return { start, end };
  }
  function getSentence(cm, cur, repeat, dir, inclusive) {
    function nextChar(curr) {
      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {
        curr.line = null;
      } else {
        curr.pos += curr.dir;
      }
    }
    function forward(cm2, ln2, pos, dir2) {
      var line = cm2.getLine(ln2);
      var curr = {
        line,
        ln: ln2,
        pos,
        dir: dir2
      };
      if (curr.line === "") {
        return { ln: curr.ln, pos: curr.pos };
      }
      var lastSentencePos = curr.pos;
      nextChar(curr);
      while (curr.line !== null) {
        lastSentencePos = curr.pos;
        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
          if (!inclusive) {
            return { ln: curr.ln, pos: curr.pos + 1 };
          } else {
            nextChar(curr);
            while (curr.line !== null) {
              if (isWhiteSpaceString(curr.line[curr.pos])) {
                lastSentencePos = curr.pos;
                nextChar(curr);
              } else {
                break;
              }
            }
            return { ln: curr.ln, pos: lastSentencePos + 1 };
          }
        }
        nextChar(curr);
      }
      return { ln: curr.ln, pos: lastSentencePos + 1 };
    }
    function reverse(cm2, ln2, pos, dir2) {
      var line = cm2.getLine(ln2);
      var curr = {
        line,
        ln: ln2,
        pos,
        dir: dir2
      };
      if (curr.line === "") {
        return { ln: curr.ln, pos: curr.pos };
      }
      var lastSentencePos = curr.pos;
      nextChar(curr);
      while (curr.line !== null) {
        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {
          lastSentencePos = curr.pos;
        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {
          if (!inclusive) {
            return { ln: curr.ln, pos: lastSentencePos };
          } else {
            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {
              return { ln: curr.ln, pos: curr.pos + 1 };
            } else {
              return { ln: curr.ln, pos: lastSentencePos };
            }
          }
        }
        nextChar(curr);
      }
      curr.line = line;
      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {
        return { ln: curr.ln, pos: curr.pos };
      } else {
        return { ln: curr.ln, pos: lastSentencePos };
      }
    }
    var curr_index = {
      ln: cur.line,
      pos: cur.ch
    };
    while (repeat > 0) {
      if (dir < 0) {
        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
      } else {
        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
      }
      repeat--;
    }
    return new Pos2(curr_index.ln, curr_index.pos);
  }
  function findSentence(cm, cur, repeat, dir) {
    function nextChar(cm2, idx) {
      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
        idx.ln += idx.dir;
        if (!isLine(cm2, idx.ln)) {
          idx.line = null;
          idx.ln = null;
          idx.pos = null;
          return;
        }
        idx.line = cm2.getLine(idx.ln);
        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;
      } else {
        idx.pos += idx.dir;
      }
    }
    function forward(cm2, ln2, pos, dir2) {
      var line = cm2.getLine(ln2);
      var stop = line === "";
      var curr = {
        line,
        ln: ln2,
        pos,
        dir: dir2
      };
      var last_valid = {
        ln: curr.ln,
        pos: curr.pos
      };
      var skip_empty_lines = curr.line === "";
      nextChar(cm2, curr);
      while (curr.line !== null) {
        last_valid.ln = curr.ln;
        last_valid.pos = curr.pos;
        if (curr.line === "" && !skip_empty_lines) {
          return { ln: curr.ln, pos: curr.pos };
        } else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
          return { ln: curr.ln, pos: curr.pos };
        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
          stop = true;
        }
        nextChar(cm2, curr);
      }
      var line = cm2.getLine(last_valid.ln);
      last_valid.pos = 0;
      for (var i = line.length - 1; i >= 0; --i) {
        if (!isWhiteSpaceString(line[i])) {
          last_valid.pos = i;
          break;
        }
      }
      return last_valid;
    }
    function reverse(cm2, ln2, pos, dir2) {
      var line = cm2.getLine(ln2);
      var curr = {
        line,
        ln: ln2,
        pos,
        dir: dir2
      };
      var last_valid = {
        ln: curr.ln,
        pos: null
      };
      var skip_empty_lines = curr.line === "";
      nextChar(cm2, curr);
      while (curr.line !== null) {
        if (curr.line === "" && !skip_empty_lines) {
          if (last_valid.pos !== null) {
            return last_valid;
          } else {
            return { ln: curr.ln, pos: curr.pos };
          }
        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
          return last_valid;
        } else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
          skip_empty_lines = false;
          last_valid = { ln: curr.ln, pos: curr.pos };
        }
        nextChar(cm2, curr);
      }
      var line = cm2.getLine(last_valid.ln);
      last_valid.pos = 0;
      for (var i = 0; i < line.length; ++i) {
        if (!isWhiteSpaceString(line[i])) {
          last_valid.pos = i;
          break;
        }
      }
      return last_valid;
    }
    var curr_index = {
      ln: cur.line,
      pos: cur.ch
    };
    while (repeat > 0) {
      if (dir < 0) {
        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
      } else {
        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
      }
      repeat--;
    }
    return new Pos2(curr_index.ln, curr_index.pos);
  }
  function selectCompanionObject(cm, head, symb, inclusive) {
    var cur = head, start, end;
    var bracketRegexp = {
      "(": /[()]/,
      ")": /[()]/,
      "[": /[[\]]/,
      "]": /[[\]]/,
      "{": /[{}]/,
      "}": /[{}]/,
      "<": /[<>]/,
      ">": /[<>]/
    }[symb];
    var openSym = {
      "(": "(",
      ")": "(",
      "[": "[",
      "]": "[",
      "{": "{",
      "}": "{",
      "<": "<",
      ">": "<"
    }[symb];
    var curChar = cm.getLine(cur.line).charAt(cur.ch);
    var offset = curChar === openSym ? 1 : 0;
    start = cm.scanForBracket(new Pos2(cur.line, cur.ch + offset), -1, void 0, { "bracketRegex": bracketRegexp });
    end = cm.scanForBracket(new Pos2(cur.line, cur.ch + offset), 1, void 0, { "bracketRegex": bracketRegexp });
    if (!start || !end) {
      return { start: cur, end: cur };
    }
    start = start.pos;
    end = end.pos;
    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    if (inclusive) {
      end.ch += 1;
    } else {
      start.ch += 1;
    }
    return { start, end };
  }
  function findBeginningAndEnd(cm, head, symb, inclusive) {
    var cur = copyCursor(head);
    var line = cm.getLine(cur.line);
    var chars = line.split("");
    var start, end, i, len;
    var firstIndex = chars.indexOf(symb);
    if (cur.ch < firstIndex) {
      cur.ch = firstIndex;
    } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
      end = cur.ch;
      --cur.ch;
    }
    if (chars[cur.ch] == symb && !end) {
      start = cur.ch + 1;
    } else {
      for (i = cur.ch; i > -1 && !start; i--) {
        if (chars[i] == symb) {
          start = i + 1;
        }
      }
    }
    if (start && !end) {
      for (i = start, len = chars.length; i < len && !end; i++) {
        if (chars[i] == symb) {
          end = i;
        }
      }
    }
    if (!start || !end) {
      return { start: cur, end: cur };
    }
    if (inclusive) {
      --start;
      ++end;
    }
    return {
      start: new Pos2(cur.line, start),
      end: new Pos2(cur.line, end)
    };
  }
  defineOption("pcre", true, "boolean");
  function SearchState2() {
  }
  SearchState2.prototype = {
    getQuery: function() {
      return vimGlobalState.query;
    },
    setQuery: function(query) {
      vimGlobalState.query = query;
    },
    getOverlay: function() {
      return this.searchOverlay;
    },
    setOverlay: function(overlay) {
      this.searchOverlay = overlay;
    },
    isReversed: function() {
      return vimGlobalState.isReversed;
    },
    setReversed: function(reversed) {
      vimGlobalState.isReversed = reversed;
    },
    getScrollbarAnnotate: function() {
      return this.annotate;
    },
    setScrollbarAnnotate: function(annotate) {
      this.annotate = annotate;
    }
  };
  function getSearchState(cm) {
    var vim2 = cm.state.vim;
    return vim2.searchState_ || (vim2.searchState_ = new SearchState2());
  }
  function splitBySlash(argString) {
    return splitBySeparator(argString, "/");
  }
  function findUnescapedSlashes(argString) {
    return findUnescapedSeparators(argString, "/");
  }
  function splitBySeparator(argString, separator) {
    var slashes = findUnescapedSeparators(argString, separator) || [];
    if (!slashes.length)
      return [];
    var tokens = [];
    if (slashes[0] !== 0)
      return;
    for (var i = 0; i < slashes.length; i++) {
      if (typeof slashes[i] == "number")
        tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));
    }
    return tokens;
  }
  function findUnescapedSeparators(str, separator) {
    if (!separator)
      separator = "/";
    var escapeNextChar = false;
    var slashes = [];
    for (var i = 0; i < str.length; i++) {
      var c = str.charAt(i);
      if (!escapeNextChar && c == separator) {
        slashes.push(i);
      }
      escapeNextChar = !escapeNextChar && c == "\\";
    }
    return slashes;
  }
  function translateRegex(str) {
    var specials = "|(){";
    var unescape = "}";
    var escapeNextChar = false;
    var out = [];
    for (var i = -1; i < str.length; i++) {
      var c = str.charAt(i) || "";
      var n = str.charAt(i + 1) || "";
      var specialComesNext = n && specials.indexOf(n) != -1;
      if (escapeNextChar) {
        if (c !== "\\" || !specialComesNext) {
          out.push(c);
        }
        escapeNextChar = false;
      } else {
        if (c === "\\") {
          escapeNextChar = true;
          if (n && unescape.indexOf(n) != -1) {
            specialComesNext = true;
          }
          if (!specialComesNext || n === "\\") {
            out.push(c);
          }
        } else {
          out.push(c);
          if (specialComesNext && n !== "\\") {
            out.push("\\");
          }
        }
      }
    }
    return out.join("");
  }
  var charUnescapes = { "\\n": "\n", "\\r": "\r", "\\t": "	" };
  function translateRegexReplace(str) {
    var escapeNextChar = false;
    var out = [];
    for (var i = -1; i < str.length; i++) {
      var c = str.charAt(i) || "";
      var n = str.charAt(i + 1) || "";
      if (charUnescapes[c + n]) {
        out.push(charUnescapes[c + n]);
        i++;
      } else if (escapeNextChar) {
        out.push(c);
        escapeNextChar = false;
      } else {
        if (c === "\\") {
          escapeNextChar = true;
          if (isNumber(n) || n === "$") {
            out.push("$");
          } else if (n !== "/" && n !== "\\") {
            out.push("\\");
          }
        } else {
          if (c === "$") {
            out.push("$");
          }
          out.push(c);
          if (n === "/") {
            out.push("\\");
          }
        }
      }
    }
    return out.join("");
  }
  var unescapes = { "\\/": "/", "\\\\": "\\", "\\n": "\n", "\\r": "\r", "\\t": "	", "\\&": "&" };
  function unescapeRegexReplace(str) {
    var stream = new CodeMirror2.StringStream(str);
    var output = [];
    while (!stream.eol()) {
      while (stream.peek() && stream.peek() != "\\") {
        output.push(stream.next());
      }
      var matched = false;
      for (var matcher in unescapes) {
        if (stream.match(matcher, true)) {
          matched = true;
          output.push(unescapes[matcher]);
          break;
        }
      }
      if (!matched) {
        output.push(stream.next());
      }
    }
    return output.join("");
  }
  function parseQuery(query, ignoreCase, smartCase) {
    var lastSearchRegister = vimGlobalState.registerController.getRegister("/");
    lastSearchRegister.setText(query);
    if (query instanceof RegExp) {
      return query;
    }
    var slashes = findUnescapedSlashes(query);
    var regexPart;
    var forceIgnoreCase;
    if (!slashes.length) {
      regexPart = query;
    } else {
      regexPart = query.substring(0, slashes[0]);
      var flagsPart = query.substring(slashes[0]);
      forceIgnoreCase = flagsPart.indexOf("i") != -1;
    }
    if (!regexPart) {
      return null;
    }
    if (!getOption("pcre")) {
      regexPart = translateRegex(regexPart);
    }
    if (smartCase) {
      ignoreCase = /^[^A-Z]*$/.test(regexPart);
    }
    var regexp = new RegExp(
      regexPart,
      ignoreCase || forceIgnoreCase ? "im" : "m"
    );
    return regexp;
  }
  function dom(n) {
    if (typeof n === "string")
      n = document.createElement(n);
    for (var a, i = 1; i < arguments.length; i++) {
      if (!(a = arguments[i]))
        continue;
      if (typeof a !== "object")
        a = document.createTextNode(a);
      if (a.nodeType)
        n.appendChild(a);
      else
        for (var key in a) {
          if (!Object.prototype.hasOwnProperty.call(a, key))
            continue;
          if (key[0] === "$")
            n.style[key.slice(1)] = a[key];
          else
            n.setAttribute(key, a[key]);
        }
    }
    return n;
  }
  function showConfirm(cm, template) {
    var pre = dom("div", { $color: "red", $whiteSpace: "pre", class: "cm-vim-message" }, template);
    if (cm.openNotification) {
      cm.openNotification(pre, { bottom: true, duration: 5e3 });
    } else {
      alert(pre.innerText);
    }
  }
  function makePrompt(prefix, desc) {
    return dom(
      document.createDocumentFragment(),
      dom(
        "span",
        { $fontFamily: "monospace", $whiteSpace: "pre" },
        prefix,
        dom("input", {
          type: "text",
          autocorrect: "off",
          autocapitalize: "off",
          spellcheck: "false"
        })
      ),
      desc && dom("span", { $color: "#888" }, desc)
    );
  }
  function showPrompt(cm, options2) {
    var template = makePrompt(options2.prefix, options2.desc);
    if (cm.openDialog) {
      cm.openDialog(template, options2.onClose, {
        onKeyDown: options2.onKeyDown,
        onKeyUp: options2.onKeyUp,
        bottom: true,
        selectValueOnOpen: false,
        value: options2.value
      });
    } else {
      var shortText = "";
      if (typeof options2.prefix != "string" && options2.prefix)
        shortText += options2.prefix.textContent;
      if (options2.desc)
        shortText += " " + options2.desc;
      options2.onClose(prompt(shortText, ""));
    }
  }
  function regexEqual(r1, r2) {
    if (r1 instanceof RegExp && r2 instanceof RegExp) {
      var props = ["global", "multiline", "ignoreCase", "source"];
      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        if (r1[prop] !== r2[prop]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
    if (!rawQuery) {
      return;
    }
    var state = getSearchState(cm);
    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
    if (!query) {
      return;
    }
    highlightSearchMatches(cm, query);
    if (regexEqual(query, state.getQuery())) {
      return query;
    }
    state.setQuery(query);
    return query;
  }
  function searchOverlay(query) {
    if (query.source.charAt(0) == "^") {
      var matchSol = true;
    }
    return {
      token: function(stream) {
        if (matchSol && !stream.sol()) {
          stream.skipToEnd();
          return;
        }
        var match = stream.match(query, false);
        if (match) {
          if (match[0].length == 0) {
            stream.next();
            return "searching";
          }
          if (!stream.sol()) {
            stream.backUp(1);
            if (!query.exec(stream.next() + match[0])) {
              stream.next();
              return null;
            }
          }
          stream.match(query);
          return "searching";
        }
        while (!stream.eol()) {
          stream.next();
          if (stream.match(query, false))
            break;
        }
      },
      query
    };
  }
  var highlightTimeout = 0;
  function highlightSearchMatches(cm, query) {
    clearTimeout(highlightTimeout);
    highlightTimeout = setTimeout(function() {
      if (!cm.state.vim)
        return;
      var searchState2 = getSearchState(cm);
      var overlay = searchState2.getOverlay();
      if (!overlay || query != overlay.query) {
        if (overlay) {
          cm.removeOverlay(overlay);
        }
        overlay = searchOverlay(query);
        cm.addOverlay(overlay);
        if (cm.showMatchesOnScrollbar) {
          if (searchState2.getScrollbarAnnotate()) {
            searchState2.getScrollbarAnnotate().clear();
          }
          searchState2.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
        }
        searchState2.setOverlay(overlay);
      }
    }, 50);
  }
  function findNext2(cm, prev, query, repeat) {
    if (repeat === void 0) {
      repeat = 1;
    }
    return cm.operation(function() {
      var pos = cm.getCursor();
      var cursor = cm.getSearchCursor(query, pos);
      for (var i = 0; i < repeat; i++) {
        var found = cursor.find(prev);
        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {
          var lastEndPos = prev ? cursor.from() : cursor.to();
          found = cursor.find(prev);
          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {
            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)
              found = cursor.find(prev);
          }
        }
        if (!found) {
          cursor = cm.getSearchCursor(
            query,
            prev ? new Pos2(cm.lastLine()) : new Pos2(cm.firstLine(), 0)
          );
          if (!cursor.find(prev)) {
            return;
          }
        }
      }
      return cursor.from();
    });
  }
  function findNextFromAndToInclusive(cm, prev, query, repeat, vim2) {
    if (repeat === void 0) {
      repeat = 1;
    }
    return cm.operation(function() {
      var pos = cm.getCursor();
      var cursor = cm.getSearchCursor(query, pos);
      var found = cursor.find(!prev);
      if (!vim2.visualMode && found && cursorEqual(cursor.from(), pos)) {
        cursor.find(!prev);
      }
      for (var i = 0; i < repeat; i++) {
        found = cursor.find(prev);
        if (!found) {
          cursor = cm.getSearchCursor(
            query,
            prev ? new Pos2(cm.lastLine()) : new Pos2(cm.firstLine(), 0)
          );
          if (!cursor.find(prev)) {
            return;
          }
        }
      }
      return [cursor.from(), cursor.to()];
    });
  }
  function clearSearchHighlight(cm) {
    var state = getSearchState(cm);
    cm.removeOverlay(getSearchState(cm).getOverlay());
    state.setOverlay(null);
    if (state.getScrollbarAnnotate()) {
      state.getScrollbarAnnotate().clear();
      state.setScrollbarAnnotate(null);
    }
  }
  function isInRange(pos, start, end) {
    if (typeof pos != "number") {
      pos = pos.line;
    }
    if (start instanceof Array) {
      return inArray(pos, start);
    } else {
      if (typeof end == "number") {
        return pos >= start && pos <= end;
      } else {
        return pos == start;
      }
    }
  }
  function getUserVisibleLines(cm) {
    var scrollInfo = cm.getScrollInfo();
    var occludeToleranceTop = 6;
    var occludeToleranceBottom = 10;
    var from = cm.coordsChar({ left: 0, top: occludeToleranceTop + scrollInfo.top }, "local");
    var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
    var to = cm.coordsChar({ left: 0, top: bottomY }, "local");
    return { top: from.line, bottom: to.line };
  }
  function getMarkPos(cm, vim2, markName) {
    if (markName == "'" || markName == "`") {
      return vimGlobalState.jumpList.find(cm, -1) || new Pos2(0, 0);
    } else if (markName == ".") {
      return getLastEditPos(cm);
    }
    var mark = vim2.marks[markName];
    return mark && mark.find();
  }
  function getLastEditPos(cm) {
    var done = cm.doc.history.done;
    for (var i = done.length; i--; ) {
      if (done[i].changes) {
        return copyCursor(done[i].changes[0].to);
      }
    }
  }
  var ExCommandDispatcher = function() {
    this.buildCommandMap_();
  };
  ExCommandDispatcher.prototype = {
    processCommand: function(cm, input, opt_params) {
      var that = this;
      cm.operation(function() {
        cm.curOp.isVimOp = true;
        that._processCommand(cm, input, opt_params);
      });
    },
    _processCommand: function(cm, input, opt_params) {
      var vim2 = cm.state.vim;
      var commandHistoryRegister = vimGlobalState.registerController.getRegister(":");
      var previousCommand = commandHistoryRegister.toString();
      if (vim2.visualMode) {
        exitVisualMode(cm);
      }
      var inputStream = new CodeMirror2.StringStream(input);
      commandHistoryRegister.setText(input);
      var params = opt_params || {};
      params.input = input;
      try {
        this.parseInput_(cm, inputStream, params);
      } catch (e) {
        showConfirm(cm, e.toString());
        throw e;
      }
      var command2;
      var commandName;
      if (!params.commandName) {
        if (params.line !== void 0) {
          commandName = "move";
        }
      } else {
        command2 = this.matchCommand_(params.commandName);
        if (command2) {
          commandName = command2.name;
          if (command2.excludeFromCommandHistory) {
            commandHistoryRegister.setText(previousCommand);
          }
          this.parseCommandArgs_(inputStream, params, command2);
          if (command2.type == "exToKey") {
            for (var i = 0; i < command2.toKeys.length; i++) {
              vimApi.handleKey(cm, command2.toKeys[i], "mapping");
            }
            return;
          } else if (command2.type == "exToEx") {
            this.processCommand(cm, command2.toInput);
            return;
          }
        }
      }
      if (!commandName) {
        showConfirm(cm, 'Not an editor command ":' + input + '"');
        return;
      }
      try {
        exCommands[commandName](cm, params);
        if ((!command2 || !command2.possiblyAsync) && params.callback) {
          params.callback();
        }
      } catch (e) {
        showConfirm(cm, e.toString());
        throw e;
      }
    },
    parseInput_: function(cm, inputStream, result) {
      inputStream.eatWhile(":");
      if (inputStream.eat("%")) {
        result.line = cm.firstLine();
        result.lineEnd = cm.lastLine();
      } else {
        result.line = this.parseLineSpec_(cm, inputStream);
        if (result.line !== void 0 && inputStream.eat(",")) {
          result.lineEnd = this.parseLineSpec_(cm, inputStream);
        }
      }
      var commandMatch2 = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
      if (commandMatch2) {
        result.commandName = commandMatch2[1];
      } else {
        result.commandName = inputStream.match(/.*/)[0];
      }
      return result;
    },
    parseLineSpec_: function(cm, inputStream) {
      var numberMatch = inputStream.match(/^(\d+)/);
      if (numberMatch) {
        return parseInt(numberMatch[1], 10) - 1;
      }
      switch (inputStream.next()) {
        case ".":
          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
        case "$":
          return this.parseLineSpecOffset_(inputStream, cm.lastLine());
        case "'":
          var markName = inputStream.next();
          var markPos = getMarkPos(cm, cm.state.vim, markName);
          if (!markPos)
            throw new Error("Mark not set");
          return this.parseLineSpecOffset_(inputStream, markPos.line);
        case "-":
        case "+":
          inputStream.backUp(1);
          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
        default:
          inputStream.backUp(1);
          return void 0;
      }
    },
    parseLineSpecOffset_: function(inputStream, line) {
      var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
      if (offsetMatch) {
        var offset = parseInt(offsetMatch[2], 10);
        if (offsetMatch[1] == "-") {
          line -= offset;
        } else {
          line += offset;
        }
      }
      return line;
    },
    parseCommandArgs_: function(inputStream, params, command2) {
      if (inputStream.eol()) {
        return;
      }
      params.argString = inputStream.match(/.*/)[0];
      var delim = command2.argDelimiter || /\s+/;
      var args = trim(params.argString).split(delim);
      if (args.length && args[0]) {
        params.args = args;
      }
    },
    matchCommand_: function(commandName) {
      for (var i = commandName.length; i > 0; i--) {
        var prefix = commandName.substring(0, i);
        if (this.commandMap_[prefix]) {
          var command2 = this.commandMap_[prefix];
          if (command2.name.indexOf(commandName) === 0) {
            return command2;
          }
        }
      }
      return null;
    },
    buildCommandMap_: function() {
      this.commandMap_ = {};
      for (var i = 0; i < defaultExCommandMap.length; i++) {
        var command2 = defaultExCommandMap[i];
        var key = command2.shortName || command2.name;
        this.commandMap_[key] = command2;
      }
    },
    map: function(lhs, rhs, ctx) {
      if (lhs != ":" && lhs.charAt(0) == ":") {
        if (ctx) {
          throw Error("Mode not supported for ex mappings");
        }
        var commandName = lhs.substring(1);
        if (rhs != ":" && rhs.charAt(0) == ":") {
          this.commandMap_[commandName] = {
            name: commandName,
            type: "exToEx",
            toInput: rhs.substring(1),
            user: true
          };
        } else {
          this.commandMap_[commandName] = {
            name: commandName,
            type: "exToKey",
            toKeys: rhs,
            user: true
          };
        }
      } else {
        if (rhs != ":" && rhs.charAt(0) == ":") {
          var mapping = {
            keys: lhs,
            type: "keyToEx",
            exArgs: { input: rhs.substring(1) }
          };
          if (ctx) {
            mapping.context = ctx;
          }
          defaultKeymap2.unshift(mapping);
        } else {
          var mapping = {
            keys: lhs,
            type: "keyToKey",
            toKeys: rhs
          };
          if (ctx) {
            mapping.context = ctx;
          }
          defaultKeymap2.unshift(mapping);
        }
      }
    },
    unmap: function(lhs, ctx) {
      if (lhs != ":" && lhs.charAt(0) == ":") {
        if (ctx) {
          throw Error("Mode not supported for ex mappings");
        }
        var commandName = lhs.substring(1);
        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
          delete this.commandMap_[commandName];
          return true;
        }
      } else {
        var keys = lhs;
        for (var i = 0; i < defaultKeymap2.length; i++) {
          if (keys == defaultKeymap2[i].keys && defaultKeymap2[i].context === ctx) {
            defaultKeymap2.splice(i, 1);
            return true;
          }
        }
      }
    }
  };
  var exCommands = {
    colorscheme: function(cm, params) {
      if (!params.args || params.args.length < 1) {
        showConfirm(cm, cm.getOption("theme"));
        return;
      }
      cm.setOption("theme", params.args[0]);
    },
    map: function(cm, params, ctx) {
      var mapArgs = params.args;
      if (!mapArgs || mapArgs.length < 2) {
        if (cm) {
          showConfirm(cm, "Invalid mapping: " + params.input);
        }
        return;
      }
      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
    },
    imap: function(cm, params) {
      this.map(cm, params, "insert");
    },
    nmap: function(cm, params) {
      this.map(cm, params, "normal");
    },
    vmap: function(cm, params) {
      this.map(cm, params, "visual");
    },
    unmap: function(cm, params, ctx) {
      var mapArgs = params.args;
      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {
        if (cm) {
          showConfirm(cm, "No such mapping: " + params.input);
        }
      }
    },
    move: function(cm, params) {
      commandDispatcher.processCommand(cm, cm.state.vim, {
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: {
          forward: false,
          explicitRepeat: true,
          linewise: true
        },
        repeatOverride: params.line + 1
      });
    },
    set: function(cm, params) {
      var setArgs = params.args;
      var setCfg = params.setCfg || {};
      if (!setArgs || setArgs.length < 1) {
        if (cm) {
          showConfirm(cm, "Invalid mapping: " + params.input);
        }
        return;
      }
      var expr = setArgs[0].split("=");
      var optionName = expr[0];
      var value = expr[1];
      var forceGet = false;
      if (optionName.charAt(optionName.length - 1) == "?") {
        if (value) {
          throw Error("Trailing characters: " + params.argString);
        }
        optionName = optionName.substring(0, optionName.length - 1);
        forceGet = true;
      }
      if (value === void 0 && optionName.substring(0, 2) == "no") {
        optionName = optionName.substring(2);
        value = false;
      }
      var optionIsBoolean = options[optionName] && options[optionName].type == "boolean";
      if (optionIsBoolean && value == void 0) {
        value = true;
      }
      if (!optionIsBoolean && value === void 0 || forceGet) {
        var oldValue = getOption(optionName, cm, setCfg);
        if (oldValue instanceof Error) {
          showConfirm(cm, oldValue.message);
        } else if (oldValue === true || oldValue === false) {
          showConfirm(cm, " " + (oldValue ? "" : "no") + optionName);
        } else {
          showConfirm(cm, "  " + optionName + "=" + oldValue);
        }
      } else {
        var setOptionReturn = setOption(optionName, value, cm, setCfg);
        if (setOptionReturn instanceof Error) {
          showConfirm(cm, setOptionReturn.message);
        }
      }
    },
    setlocal: function(cm, params) {
      params.setCfg = { scope: "local" };
      this.set(cm, params);
    },
    setglobal: function(cm, params) {
      params.setCfg = { scope: "global" };
      this.set(cm, params);
    },
    registers: function(cm, params) {
      var regArgs = params.args;
      var registers = vimGlobalState.registerController.registers;
      var regInfo = "----------Registers----------\n\n";
      if (!regArgs) {
        for (var registerName in registers) {
          var text = registers[registerName].toString();
          if (text.length) {
            regInfo += '"' + registerName + "    " + text + "\n";
          }
        }
      } else {
        var registerName;
        regArgs = regArgs.join("");
        for (var i = 0; i < regArgs.length; i++) {
          registerName = regArgs.charAt(i);
          if (!vimGlobalState.registerController.isValidRegister(registerName)) {
            continue;
          }
          var register = registers[registerName] || new Register();
          regInfo += '"' + registerName + "    " + register.toString() + "\n";
        }
      }
      showConfirm(cm, regInfo);
    },
    sort: function(cm, params) {
      var reverse, ignoreCase, unique, number, pattern;
      function parseArgs() {
        if (params.argString) {
          var args = new CodeMirror2.StringStream(params.argString);
          if (args.eat("!")) {
            reverse = true;
          }
          if (args.eol()) {
            return;
          }
          if (!args.eatSpace()) {
            return "Invalid arguments";
          }
          var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
          if (!opts && !args.eol()) {
            return "Invalid arguments";
          }
          if (opts[1]) {
            ignoreCase = opts[1].indexOf("i") != -1;
            unique = opts[1].indexOf("u") != -1;
            var decimal = opts[1].indexOf("d") != -1 || opts[1].indexOf("n") != -1 && 1;
            var hex = opts[1].indexOf("x") != -1 && 1;
            var octal = opts[1].indexOf("o") != -1 && 1;
            if (decimal + hex + octal > 1) {
              return "Invalid arguments";
            }
            number = decimal && "decimal" || hex && "hex" || octal && "octal";
          }
          if (opts[2]) {
            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? "i" : "");
          }
        }
      }
      var err = parseArgs();
      if (err) {
        showConfirm(cm, err + ": " + params.argString);
        return;
      }
      var lineStart = params.line || cm.firstLine();
      var lineEnd = params.lineEnd || params.line || cm.lastLine();
      if (lineStart == lineEnd) {
        return;
      }
      var curStart = new Pos2(lineStart, 0);
      var curEnd = new Pos2(lineEnd, lineLength(cm, lineEnd));
      var text = cm.getRange(curStart, curEnd).split("\n");
      var numberRegex2 = pattern ? pattern : number == "decimal" ? /(-?)([\d]+)/ : number == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : number == "octal" ? /([0-7]+)/ : null;
      var radix = number == "decimal" ? 10 : number == "hex" ? 16 : number == "octal" ? 8 : null;
      var numPart = [], textPart = [];
      if (number || pattern) {
        for (var i = 0; i < text.length; i++) {
          var matchPart = pattern ? text[i].match(pattern) : null;
          if (matchPart && matchPart[0] != "") {
            numPart.push(matchPart);
          } else if (!pattern && numberRegex2.exec(text[i])) {
            numPart.push(text[i]);
          } else {
            textPart.push(text[i]);
          }
        }
      } else {
        textPart = text;
      }
      function compareFn(a, b) {
        if (reverse) {
          var tmp;
          tmp = a;
          a = b;
          b = tmp;
        }
        if (ignoreCase) {
          a = a.toLowerCase();
          b = b.toLowerCase();
        }
        var anum = number && numberRegex2.exec(a);
        var bnum = number && numberRegex2.exec(b);
        if (!anum) {
          return a < b ? -1 : 1;
        }
        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
        return anum - bnum;
      }
      function comparePatternFn(a, b) {
        if (reverse) {
          var tmp;
          tmp = a;
          a = b;
          b = tmp;
        }
        if (ignoreCase) {
          a[0] = a[0].toLowerCase();
          b[0] = b[0].toLowerCase();
        }
        return a[0] < b[0] ? -1 : 1;
      }
      numPart.sort(pattern ? comparePatternFn : compareFn);
      if (pattern) {
        for (var i = 0; i < numPart.length; i++) {
          numPart[i] = numPart[i].input;
        }
      } else if (!number) {
        textPart.sort(compareFn);
      }
      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);
      if (unique) {
        var textOld = text;
        var lastLine;
        text = [];
        for (var i = 0; i < textOld.length; i++) {
          if (textOld[i] != lastLine) {
            text.push(textOld[i]);
          }
          lastLine = textOld[i];
        }
      }
      cm.replaceRange(text.join("\n"), curStart, curEnd);
    },
    vglobal: function(cm, params) {
      this.global(cm, params);
    },
    global: function(cm, params) {
      var argString = params.argString;
      if (!argString) {
        showConfirm(cm, "Regular Expression missing from global");
        return;
      }
      var inverted = params.commandName[0] === "v";
      var lineStart = params.line !== void 0 ? params.line : cm.firstLine();
      var lineEnd = params.lineEnd || params.line || cm.lastLine();
      var tokens = splitBySlash(argString);
      var regexPart = argString, cmd2;
      if (tokens.length) {
        regexPart = tokens[0];
        cmd2 = tokens.slice(1, tokens.length).join("/");
      }
      if (regexPart) {
        try {
          updateSearchQuery(
            cm,
            regexPart,
            true,
            true
          );
        } catch (e) {
          showConfirm(cm, "Invalid regex: " + regexPart);
          return;
        }
      }
      var query = getSearchState(cm).getQuery();
      var matchedLines = [];
      for (var i = lineStart; i <= lineEnd; i++) {
        var line = cm.getLineHandle(i);
        var matched = query.test(line.text);
        if (matched !== inverted) {
          matchedLines.push(cmd2 ? line : line.text);
        }
      }
      if (!cmd2) {
        showConfirm(cm, matchedLines.join("\n"));
        return;
      }
      var index = 0;
      var nextCommand = function() {
        if (index < matchedLines.length) {
          var line2 = matchedLines[index++];
          var lineNum = cm.getLineNumber(line2);
          if (lineNum == null) {
            nextCommand();
            return;
          }
          var command2 = lineNum + 1 + cmd2;
          exCommandDispatcher.processCommand(cm, command2, {
            callback: nextCommand
          });
        }
      };
      nextCommand();
    },
    substitute: function(cm, params) {
      if (!cm.getSearchCursor) {
        throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
      }
      var argString = params.argString;
      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
      var regexPart, replacePart = "", trailing, flagsPart, count;
      var confirm = false;
      var global = false;
      if (tokens.length) {
        regexPart = tokens[0];
        if (getOption("pcre") && regexPart !== "") {
          regexPart = new RegExp(regexPart).source;
        }
        replacePart = tokens[1];
        if (replacePart !== void 0) {
          if (getOption("pcre")) {
            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g, "$1$$&"));
          } else {
            replacePart = translateRegexReplace(replacePart);
          }
          vimGlobalState.lastSubstituteReplacePart = replacePart;
        }
        trailing = tokens[2] ? tokens[2].split(" ") : [];
      } else {
        if (argString && argString.length) {
          showConfirm(cm, "Substitutions should be of the form :s/pattern/replace/");
          return;
        }
      }
      if (trailing) {
        flagsPart = trailing[0];
        count = parseInt(trailing[1]);
        if (flagsPart) {
          if (flagsPart.indexOf("c") != -1) {
            confirm = true;
          }
          if (flagsPart.indexOf("g") != -1) {
            global = true;
          }
          if (getOption("pcre")) {
            regexPart = regexPart + "/" + flagsPart;
          } else {
            regexPart = regexPart.replace(/\//g, "\\/") + "/" + flagsPart;
          }
        }
      }
      if (regexPart) {
        try {
          updateSearchQuery(
            cm,
            regexPart,
            true,
            true
          );
        } catch (e) {
          showConfirm(cm, "Invalid regex: " + regexPart);
          return;
        }
      }
      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
      if (replacePart === void 0) {
        showConfirm(cm, "No previous substitute regular expression");
        return;
      }
      var state = getSearchState(cm);
      var query = state.getQuery();
      var lineStart = params.line !== void 0 ? params.line : cm.getCursor().line;
      var lineEnd = params.lineEnd || lineStart;
      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
        lineEnd = Infinity;
      }
      if (count) {
        lineStart = lineEnd;
        lineEnd = lineStart + count - 1;
      }
      var startPos = clipCursorToContent(cm, new Pos2(lineStart, 0));
      var cursor = cm.getSearchCursor(query, startPos);
      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
    },
    redo: CodeMirror2.commands.redo,
    undo: CodeMirror2.commands.undo,
    write: function(cm) {
      if (CodeMirror2.commands.save) {
        CodeMirror2.commands.save(cm);
      } else if (cm.save) {
        cm.save();
      }
    },
    nohlsearch: function(cm) {
      clearSearchHighlight(cm);
    },
    yank: function(cm) {
      var cur = copyCursor(cm.getCursor());
      var line = cur.line;
      var lineText = cm.getLine(line);
      vimGlobalState.registerController.pushText(
        "0",
        "yank",
        lineText,
        true,
        true
      );
    },
    delmarks: function(cm, params) {
      if (!params.argString || !trim(params.argString)) {
        showConfirm(cm, "Argument required");
        return;
      }
      var state = cm.state.vim;
      var stream = new CodeMirror2.StringStream(trim(params.argString));
      while (!stream.eol()) {
        stream.eatSpace();
        var count = stream.pos;
        if (!stream.match(/[a-zA-Z]/, false)) {
          showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
          return;
        }
        var sym = stream.next();
        if (stream.match("-", true)) {
          if (!stream.match(/[a-zA-Z]/, false)) {
            showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
            return;
          }
          var startMark = sym;
          var finishMark = stream.next();
          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {
            var start = startMark.charCodeAt(0);
            var finish = finishMark.charCodeAt(0);
            if (start >= finish) {
              showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
              return;
            }
            for (var j = 0; j <= finish - start; j++) {
              var mark = String.fromCharCode(start + j);
              delete state.marks[mark];
            }
          } else {
            showConfirm(cm, "Invalid argument: " + startMark + "-");
            return;
          }
        } else {
          delete state.marks[sym];
        }
      }
    }
  };
  var exCommandDispatcher = new ExCommandDispatcher();
  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {
    cm.state.vim.exMode = true;
    var done = false;
    var lastPos, modifiedLineNumber, joined;
    function replaceAll2() {
      cm.operation(function() {
        while (!done) {
          replace();
          next();
        }
        stop();
      });
    }
    function replace() {
      var text = cm.getRange(searchCursor.from(), searchCursor.to());
      var newText = text.replace(query, replaceWith);
      var unmodifiedLineNumber = searchCursor.to().line;
      searchCursor.replace(newText);
      modifiedLineNumber = searchCursor.to().line;
      lineEnd += modifiedLineNumber - unmodifiedLineNumber;
      joined = modifiedLineNumber < unmodifiedLineNumber;
    }
    function findNextValidMatch() {
      var lastMatchTo = lastPos && copyCursor(searchCursor.to());
      var match = searchCursor.findNext();
      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {
        match = searchCursor.findNext();
      }
      return match;
    }
    function next() {
      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {
        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {
          continue;
        }
        cm.scrollIntoView(searchCursor.from(), 30);
        cm.setSelection(searchCursor.from(), searchCursor.to());
        lastPos = searchCursor.from();
        done = false;
        return;
      }
      done = true;
    }
    function stop(close) {
      if (close) {
        close();
      }
      cm.focus();
      if (lastPos) {
        cm.setCursor(lastPos);
        var vim2 = cm.state.vim;
        vim2.exMode = false;
        vim2.lastHPos = vim2.lastHSPos = lastPos.ch;
      }
      if (callback) {
        callback();
      }
    }
    function onPromptKeyDown(e, _value, close) {
      CodeMirror2.e_stop(e);
      var keyName = CodeMirror2.keyName(e);
      switch (keyName) {
        case "Y":
          replace();
          next();
          break;
        case "N":
          next();
          break;
        case "A":
          var savedCallback = callback;
          callback = void 0;
          cm.operation(replaceAll2);
          callback = savedCallback;
          break;
        case "L":
          replace();
        case "Q":
        case "Esc":
        case "Ctrl-C":
        case "Ctrl-[":
          stop(close);
          break;
      }
      if (done) {
        stop(close);
      }
      return true;
    }
    next();
    if (done) {
      showConfirm(cm, "No matches for " + query.source);
      return;
    }
    if (!confirm) {
      replaceAll2();
      if (callback) {
        callback();
      }
      return;
    }
    showPrompt(cm, {
      prefix: dom("span", "replace with ", dom("strong", replaceWith), " (y/n/a/q/l)"),
      onKeyDown: onPromptKeyDown
    });
  }
  CodeMirror2.keyMap.vim = {
    attach: attachVimMap,
    detach: detachVimMap,
    call: cmKey
  };
  function exitInsertMode(cm) {
    var vim2 = cm.state.vim;
    var macroModeState = vimGlobalState.macroModeState;
    var insertModeChangeRegister = vimGlobalState.registerController.getRegister(".");
    var isPlaying = macroModeState.isPlaying;
    var lastChange = macroModeState.lastInsertModeChanges;
    if (!isPlaying) {
      cm.off("change", onChange);
      CodeMirror2.off(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
    }
    if (!isPlaying && vim2.insertModeRepeat > 1) {
      repeatLastEdit(
        cm,
        vim2,
        vim2.insertModeRepeat - 1,
        true
      );
      vim2.lastEditInputState.repeatOverride = vim2.insertModeRepeat;
    }
    delete vim2.insertModeRepeat;
    vim2.insertMode = false;
    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);
    cm.setOption("keyMap", "vim");
    cm.setOption("disableInput", true);
    cm.toggleOverwrite(false);
    insertModeChangeRegister.setText(lastChange.changes.join(""));
    CodeMirror2.signal(cm, "vim-mode-change", { mode: "normal" });
    if (macroModeState.isRecording) {
      logInsertModeChange(macroModeState);
    }
  }
  function _mapCommand(command2) {
    defaultKeymap2.unshift(command2);
  }
  function mapCommand(keys, type, name, args, extra) {
    var command2 = { keys, type };
    command2[type] = name;
    command2[type + "Args"] = args;
    for (var key in extra)
      command2[key] = extra[key];
    _mapCommand(command2);
  }
  defineOption("insertModeEscKeysTimeout", 200, "number");
  CodeMirror2.keyMap["vim-insert"] = {
    fallthrough: ["default"],
    attach: attachVimMap,
    detach: detachVimMap,
    call: cmKey
  };
  CodeMirror2.keyMap["vim-replace"] = {
    "Backspace": "goCharLeft",
    fallthrough: ["vim-insert"],
    attach: attachVimMap,
    detach: detachVimMap,
    call: cmKey
  };
  function executeMacroRegister(cm, vim2, macroModeState, registerName) {
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (registerName == ":") {
      if (register.keyBuffer[0]) {
        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
      }
      macroModeState.isPlaying = false;
      return;
    }
    var keyBuffer = register.keyBuffer;
    var imc = 0;
    macroModeState.isPlaying = true;
    macroModeState.replaySearchQueries = register.searchQueries.slice(0);
    for (var i = 0; i < keyBuffer.length; i++) {
      var text = keyBuffer[i];
      var match, key;
      while (text) {
        match = /<\w+-.+?>|<\w+>|./.exec(text);
        key = match[0];
        text = text.substring(match.index + key.length);
        vimApi.handleKey(cm, key, "macro");
        if (vim2.insertMode) {
          var changes = register.insertModeChanges[imc++].changes;
          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;
          repeatInsertModeChanges(cm, changes, 1);
          exitInsertMode(cm);
        }
      }
    }
    macroModeState.isPlaying = false;
  }
  function logKey(macroModeState, key) {
    if (macroModeState.isPlaying) {
      return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register) {
      register.pushText(key);
    }
  }
  function logInsertModeChange(macroModeState) {
    if (macroModeState.isPlaying) {
      return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register && register.pushInsertModeChanges) {
      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
    }
  }
  function logSearchQuery(macroModeState, query) {
    if (macroModeState.isPlaying) {
      return;
    }
    var registerName = macroModeState.latestRegister;
    var register = vimGlobalState.registerController.getRegister(registerName);
    if (register && register.pushSearchQuery) {
      register.pushSearchQuery(query);
    }
  }
  function onChange(cm, changeObj) {
    var macroModeState = vimGlobalState.macroModeState;
    var lastChange = macroModeState.lastInsertModeChanges;
    if (!macroModeState.isPlaying) {
      while (changeObj) {
        lastChange.expectCursorActivityForChange = true;
        if (lastChange.ignoreCount > 1) {
          lastChange.ignoreCount--;
        } else if (changeObj.origin == "+input" || changeObj.origin == "paste" || changeObj.origin === void 0) {
          var selectionCount = cm.listSelections().length;
          if (selectionCount > 1)
            lastChange.ignoreCount = selectionCount;
          var text = changeObj.text.join("\n");
          if (lastChange.maybeReset) {
            lastChange.changes = [];
            lastChange.maybeReset = false;
          }
          if (text) {
            if (cm.state.overwrite && !/\n/.test(text)) {
              lastChange.changes.push([text]);
            } else {
              lastChange.changes.push(text);
            }
          }
        }
        changeObj = changeObj.next;
      }
    }
  }
  function onCursorActivity(cm) {
    var vim2 = cm.state.vim;
    if (vim2.insertMode) {
      var macroModeState = vimGlobalState.macroModeState;
      if (macroModeState.isPlaying) {
        return;
      }
      var lastChange = macroModeState.lastInsertModeChanges;
      if (lastChange.expectCursorActivityForChange) {
        lastChange.expectCursorActivityForChange = false;
      } else {
        lastChange.maybeReset = true;
      }
    } else if (!cm.curOp.isVimOp) {
      handleExternalSelection(cm, vim2);
    }
  }
  function handleExternalSelection(cm, vim2) {
    var anchor = cm.getCursor("anchor");
    var head = cm.getCursor("head");
    if (vim2.visualMode && !cm.somethingSelected()) {
      exitVisualMode(cm, false);
    } else if (!vim2.visualMode && !vim2.insertMode && cm.somethingSelected()) {
      vim2.visualMode = true;
      vim2.visualLine = false;
      CodeMirror2.signal(cm, "vim-mode-change", { mode: "visual" });
    }
    if (vim2.visualMode) {
      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
      head = offsetCursor(head, 0, headOffset);
      anchor = offsetCursor(anchor, 0, anchorOffset);
      vim2.sel = {
        anchor,
        head
      };
      updateMark(cm, vim2, "<", cursorMin(head, anchor));
      updateMark(cm, vim2, ">", cursorMax(head, anchor));
    } else if (!vim2.insertMode) {
      vim2.lastHPos = cm.getCursor().ch;
    }
  }
  function InsertModeKey(keyName) {
    this.keyName = keyName;
  }
  function onKeyEventTargetKeyDown(e) {
    var macroModeState = vimGlobalState.macroModeState;
    var lastChange = macroModeState.lastInsertModeChanges;
    var keyName = CodeMirror2.keyName(e);
    if (!keyName) {
      return;
    }
    function onKeyFound() {
      if (lastChange.maybeReset) {
        lastChange.changes = [];
        lastChange.maybeReset = false;
      }
      lastChange.changes.push(new InsertModeKey(keyName));
      return true;
    }
    if (keyName.indexOf("Delete") != -1 || keyName.indexOf("Backspace") != -1) {
      CodeMirror2.lookupKey(keyName, "vim-insert", onKeyFound);
    }
  }
  function repeatLastEdit(cm, vim2, repeat, repeatForInsert) {
    var macroModeState = vimGlobalState.macroModeState;
    macroModeState.isPlaying = true;
    var isAction = !!vim2.lastEditActionCommand;
    var cachedInputState = vim2.inputState;
    function repeatCommand() {
      if (isAction) {
        commandDispatcher.processAction(cm, vim2, vim2.lastEditActionCommand);
      } else {
        commandDispatcher.evalInput(cm, vim2);
      }
    }
    function repeatInsert(repeat2) {
      if (macroModeState.lastInsertModeChanges.changes.length > 0) {
        repeat2 = !vim2.lastEditActionCommand ? 1 : repeat2;
        var changeObject = macroModeState.lastInsertModeChanges;
        repeatInsertModeChanges(cm, changeObject.changes, repeat2);
      }
    }
    vim2.inputState = vim2.lastEditInputState;
    if (isAction && vim2.lastEditActionCommand.interlaceInsertRepeat) {
      for (var i = 0; i < repeat; i++) {
        repeatCommand();
        repeatInsert(1);
      }
    } else {
      if (!repeatForInsert) {
        repeatCommand();
      }
      repeatInsert(repeat);
    }
    vim2.inputState = cachedInputState;
    if (vim2.insertMode && !repeatForInsert) {
      exitInsertMode(cm);
    }
    macroModeState.isPlaying = false;
  }
  function repeatInsertModeChanges(cm, changes, repeat) {
    function keyHandler(binding) {
      if (typeof binding == "string") {
        CodeMirror2.commands[binding](cm);
      } else {
        binding(cm);
      }
      return true;
    }
    var head = cm.getCursor("head");
    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
    if (visualBlock) {
      selectForInsert(cm, head, visualBlock + 1);
      repeat = cm.listSelections().length;
      cm.setCursor(head);
    }
    for (var i = 0; i < repeat; i++) {
      if (visualBlock) {
        cm.setCursor(offsetCursor(head, i, 0));
      }
      for (var j = 0; j < changes.length; j++) {
        var change = changes[j];
        if (change instanceof InsertModeKey) {
          CodeMirror2.lookupKey(change.keyName, "vim-insert", keyHandler);
        } else if (typeof change == "string") {
          cm.replaceSelection(change);
        } else {
          var start = cm.getCursor();
          var end = offsetCursor(start, 0, change[0].length);
          cm.replaceRange(change[0], start, end);
          cm.setCursor(end);
        }
      }
    }
    if (visualBlock) {
      cm.setCursor(offsetCursor(head, 0, 1));
    }
  }
  function cloneVimState(state) {
    var n = new state.constructor();
    Object.keys(state).forEach(function(key) {
      var o = state[key];
      if (Array.isArray(o))
        o = o.slice();
      else if (o && typeof o == "object" && o.constructor != Object)
        o = cloneVimState(o);
      n[key] = o;
    });
    if (state.sel) {
      n.sel = {
        head: state.sel.head && copyCursor(state.sel.head),
        anchor: state.sel.anchor && copyCursor(state.sel.anchor)
      };
    }
    return n;
  }
  function multiSelectHandleKey(cm, key, origin) {
    var isHandled = false;
    var vim2 = vimApi.maybeInitVimState_(cm);
    var visualBlock = vim2.visualBlock || vim2.wasInVisualBlock;
    var wasMultiselect = cm.isInMultiSelectMode();
    if (vim2.wasInVisualBlock && !wasMultiselect) {
      vim2.wasInVisualBlock = false;
    } else if (wasMultiselect && vim2.visualBlock) {
      vim2.wasInVisualBlock = true;
    }
    if (key == "<Esc>" && !vim2.insertMode && !vim2.visualMode && wasMultiselect && vim2.status == "<Esc>") {
      clearInputState(cm);
    } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {
      isHandled = vimApi.handleKey(cm, key, origin);
    } else {
      var old = cloneVimState(vim2);
      cm.operation(function() {
        cm.curOp.isVimOp = true;
        cm.forEachSelection(function() {
          var head = cm.getCursor("head");
          var anchor = cm.getCursor("anchor");
          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
          head = offsetCursor(head, 0, headOffset);
          anchor = offsetCursor(anchor, 0, anchorOffset);
          cm.state.vim.sel.head = head;
          cm.state.vim.sel.anchor = anchor;
          isHandled = vimApi.handleKey(cm, key, origin);
          if (cm.virtualSelection) {
            cm.state.vim = cloneVimState(old);
          }
        });
        if (cm.curOp.cursorActivity && !isHandled)
          cm.curOp.cursorActivity = false;
        cm.state.vim = vim2;
      }, true);
    }
    if (isHandled && !vim2.visualMode && !vim2.insert && vim2.visualMode != cm.somethingSelected()) {
      handleExternalSelection(cm, vim2);
    }
    return isHandled;
  }
  resetVimGlobalState();
  return vimApi;
}
function indexFromPos(doc, pos) {
  var ch = pos.ch;
  var lineNumber = pos.line + 1;
  if (lineNumber < 1) {
    lineNumber = 1;
    ch = 0;
  }
  if (lineNumber > doc.lines) {
    lineNumber = doc.lines;
    ch = Number.MAX_VALUE;
  }
  var line = doc.line(lineNumber);
  return Math.min(line.from + Math.max(0, ch), line.to);
}
function posFromIndex(doc, offset) {
  let line = doc.lineAt(offset);
  return { line: line.number - 1, ch: offset - line.from };
}
var Pos = class {
  constructor(line, ch) {
    this.line = line;
    this.ch = ch;
  }
};
function on(emitter, type, f) {
  if (emitter.addEventListener) {
    emitter.addEventListener(type, f, false);
  } else {
    var map = emitter._handlers || (emitter._handlers = {});
    map[type] = (map[type] || []).concat(f);
  }
}
function off(emitter, type, f) {
  if (emitter.removeEventListener) {
    emitter.removeEventListener(type, f, false);
  } else {
    var map = emitter._handlers, arr = map && map[type];
    if (arr) {
      var index = arr.indexOf(f);
      if (index > -1) {
        map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
      }
    }
  }
}
function signal(emitter, type, ...args) {
  var _a;
  var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];
  if (!handlers)
    return;
  for (var i = 0; i < handlers.length; ++i) {
    handlers[i](...args);
  }
}
function signalTo(handlers, ...args) {
  if (!handlers)
    return;
  for (var i = 0; i < handlers.length; ++i) {
    handlers[i](...args);
  }
}
var specialKey = {
  Return: "CR",
  Backspace: "BS",
  "Delete": "Del",
  Escape: "Esc",
  Insert: "Ins",
  ArrowLeft: "Left",
  ArrowRight: "Right",
  ArrowUp: "Up",
  ArrowDown: "Down",
  Enter: "CR",
  " ": "Space"
};
var ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1, CapsLock: 1, AltGraph: 1 };
var wordChar;
try {
  wordChar = new RegExp("[\\w\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_2) {
  wordChar = /[\w]/;
}
function dispatchChange(cm, transaction) {
  var view = cm.cm6;
  var type = "input.type.compose";
  if (cm.curOp) {
    if (!cm.curOp.lastChange)
      type = "input.type.compose.start";
  }
  if (transaction.annotations) {
    try {
      transaction.annotations.some(function(note) {
        if (note.value == "input")
          note.value = type;
      });
    } catch (e) {
      console.error(e);
    }
  } else {
    transaction.userEvent = type;
  }
  return view.dispatch(transaction);
}
function runHistoryCommand(cm, revert) {
  var _a;
  if (cm.curOp) {
    cm.curOp.$changeStart = void 0;
  }
  (revert ? undo : redo)(cm.cm6);
  let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;
  if (changeStartIndex != null) {
    cm.cm6.dispatch({ selection: { anchor: changeStartIndex } });
  }
}
var CodeMirror = class {
  constructor(cm6) {
    this.state = {};
    this.marks = /* @__PURE__ */ Object.create(null);
    this.$mid = 0;
    this.options = {};
    this._handlers = {};
    this.doc = {
      history: {
        done: [
          {
            changes: [
              {
                cm: this,
                get to() {
                  return this.cm.posFromIndex(this.cm.$lastChangeEndOffset);
                }
              }
            ]
          }
        ]
      }
    };
    this.$lastChangeEndOffset = 0;
    this.virtualSelection = null;
    this.cm6 = cm6;
    this.onChange = this.onChange.bind(this);
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  openDialog(template, callback, options) {
    return openDialog(this, template, callback, options);
  }
  openNotification(template, options) {
    return openNotification(this, template, options);
  }
  on(type, f) {
    on(this, type, f);
  }
  off(type, f) {
    off(this, type, f);
  }
  signal(type, e, handlers) {
    signal(this, type, e, handlers);
  }
  indexFromPos(pos) {
    return indexFromPos(this.cm6.state.doc, pos);
  }
  posFromIndex(offset) {
    return posFromIndex(this.cm6.state.doc, offset);
  }
  foldCode(pos) {
    let view = this.cm6;
    let ranges = view.state.selection.ranges;
    let doc = this.cm6.state.doc;
    let index = indexFromPos(doc, pos);
    let tmpRanges = EditorSelection.create([EditorSelection.range(index, index)], 0).ranges;
    view.state.selection.ranges = tmpRanges;
    foldCode(view);
    view.state.selection.ranges = ranges;
  }
  firstLine() {
    return 0;
  }
  lastLine() {
    return this.cm6.state.doc.lines - 1;
  }
  lineCount() {
    return this.cm6.state.doc.lines;
  }
  setCursor(line, ch) {
    if (typeof line === "object") {
      ch = line.ch;
      line = line.line;
    }
    var offset = indexFromPos(this.cm6.state.doc, { line, ch });
    this.cm6.dispatch({ selection: { anchor: offset } }, { scrollIntoView: !this.curOp });
    if (this.curOp && !this.curOp.isVimOp)
      this.onBeforeEndOperation();
  }
  getCursor(p3) {
    var sel = this.cm6.state.selection.main;
    var offset = p3 == "head" || !p3 ? sel.head : p3 == "anchor" ? sel.anchor : p3 == "start" ? sel.from : p3 == "end" ? sel.to : null;
    if (offset == null)
      throw new Error("Invalid cursor type");
    return this.posFromIndex(offset);
  }
  listSelections() {
    var doc = this.cm6.state.doc;
    return this.cm6.state.selection.ranges.map((r) => {
      return {
        anchor: posFromIndex(doc, r.anchor),
        head: posFromIndex(doc, r.head)
      };
    });
  }
  setSelections(p3, primIndex) {
    var doc = this.cm6.state.doc;
    var ranges = p3.map((x) => {
      return EditorSelection.range(indexFromPos(doc, x.anchor), indexFromPos(doc, x.head));
    });
    this.cm6.dispatch({
      selection: EditorSelection.create(ranges, primIndex)
    });
  }
  setSelection(anchor, head, options) {
    var doc = this.cm6.state.doc;
    var ranges = [EditorSelection.range(indexFromPos(doc, anchor), indexFromPos(doc, head))];
    this.cm6.dispatch({
      selection: EditorSelection.create(ranges, 0)
    });
    if (options && options.origin == "*mouse") {
      this.onBeforeEndOperation();
    }
  }
  getLine(row) {
    var doc = this.cm6.state.doc;
    if (row < 0 || row >= doc.lines)
      return "";
    return this.cm6.state.doc.line(row + 1).text;
  }
  getLineHandle(row) {
    return { text: this.getLine(row), row };
  }
  getLineNumber(handle) {
    return handle.row;
  }
  getRange(s, e) {
    var doc = this.cm6.state.doc;
    return this.cm6.state.sliceDoc(indexFromPos(doc, s), indexFromPos(doc, e));
  }
  replaceRange(text, s, e) {
    if (!e)
      e = s;
    var doc = this.cm6.state.doc;
    var from = indexFromPos(doc, s);
    var to = indexFromPos(doc, e);
    dispatchChange(this, { changes: { from, to, insert: text } });
  }
  replaceSelection(text) {
    dispatchChange(this, this.cm6.state.replaceSelection(text));
  }
  replaceSelections(replacements) {
    var ranges = this.cm6.state.selection.ranges;
    var changes = ranges.map((r, i) => {
      return { from: r.from, to: r.to, insert: replacements[i] || "" };
    });
    dispatchChange(this, { changes });
  }
  getSelection() {
    return this.getSelections().join("\n");
  }
  getSelections() {
    var cm = this.cm6;
    return cm.state.selection.ranges.map((r) => cm.state.sliceDoc(r.from, r.to));
  }
  somethingSelected() {
    return this.cm6.state.selection.ranges.some((r) => !r.empty);
  }
  getInputField() {
    return this.cm6.contentDOM;
  }
  clipPos(p3) {
    var doc = this.cm6.state.doc;
    var ch = p3.ch;
    var lineNumber = p3.line + 1;
    if (lineNumber < 1) {
      lineNumber = 1;
      ch = 0;
    }
    if (lineNumber > doc.lines) {
      lineNumber = doc.lines;
      ch = Number.MAX_VALUE;
    }
    var line = doc.line(lineNumber);
    ch = Math.min(Math.max(0, ch), line.to - line.from);
    return new Pos(lineNumber - 1, ch);
  }
  getValue() {
    return this.cm6.state.doc.toString();
  }
  setValue(text) {
    var cm = this.cm6;
    return cm.dispatch({
      changes: { from: 0, to: cm.state.doc.length, insert: text },
      selection: EditorSelection.range(0, 0)
    });
  }
  focus() {
    return this.cm6.focus();
  }
  blur() {
    return this.cm6.contentDOM.blur();
  }
  defaultTextHeight() {
    return this.cm6.defaultLineHeight;
  }
  findMatchingBracket(pos) {
    var state = this.cm6.state;
    var offset = indexFromPos(state.doc, pos);
    var m2 = matchBrackets(state, offset + 1, -1);
    if (m2 && m2.end) {
      return { to: posFromIndex(state.doc, m2.end.from) };
    }
    m2 = matchBrackets(state, offset, 1);
    if (m2 && m2.end) {
      return { to: posFromIndex(state.doc, m2.end.from) };
    }
    return { to: void 0 };
  }
  scanForBracket(pos, dir, style, config) {
    return scanForBracket(this, pos, dir, style, config);
  }
  indentLine(line, more) {
    if (more)
      this.indentMore();
    else
      this.indentLess();
  }
  indentMore() {
    indentMore(this.cm6);
  }
  indentLess() {
    indentLess(this.cm6);
  }
  execCommand(name) {
    if (name == "indentAuto")
      CodeMirror.commands.indentAuto(this);
    else if (name == "goLineLeft")
      cursorLineBoundaryBackward(this.cm6);
    else if (name == "goLineRight") {
      cursorLineBoundaryForward(this.cm6);
      cursorCharBackward(this.cm6);
    } else
      console.log(name + " is not implemented");
  }
  setBookmark(cursor, options) {
    var assoc = (options === null || options === void 0 ? void 0 : options.insertLeft) ? 1 : -1;
    var offset = this.indexFromPos(cursor);
    var bm = new Marker(this, offset, assoc);
    return bm;
  }
  addOverlay({ query }) {
    let cm6Query = new SearchQuery({
      regexp: true,
      search: query.source,
      caseSensitive: !/i/.test(query.flags)
    });
    if (cm6Query.valid) {
      cm6Query.forVim = true;
      this.cm6Query = cm6Query;
      let effect = setSearchQuery.of(cm6Query);
      this.cm6.dispatch({ effects: effect });
      return cm6Query;
    }
  }
  removeOverlay(overlay) {
    if (!this.cm6Query)
      return;
    this.cm6Query.forVim = false;
    let effect = setSearchQuery.of(this.cm6Query);
    this.cm6.dispatch({ effects: effect });
  }
  getSearchCursor(query, pos) {
    var cm = this;
    var last = null;
    var lastCM5Result = null;
    if (pos.ch == void 0)
      pos.ch = Number.MAX_VALUE;
    var firstOffset = indexFromPos(cm.cm6.state.doc, pos);
    var source = query.source.replace(/(\\.|{(?:\d+(?:,\d*)?|,\d+)})|[{}]/g, function(a, b) {
      if (!b)
        return "\\" + a;
      return b;
    });
    function rCursor(doc, from = 0, to = doc.length) {
      return new RegExpCursor(doc, source, { ignoreCase: query.ignoreCase }, from, to);
    }
    function nextMatch(from) {
      var doc = cm.cm6.state.doc;
      if (from > doc.length)
        return null;
      let res = rCursor(doc, from).next();
      return res.done ? null : res.value;
    }
    var ChunkSize = 1e4;
    function prevMatchInRange(from, to) {
      var doc = cm.cm6.state.doc;
      for (let size = 1; ; size++) {
        let start = Math.max(from, to - size * ChunkSize);
        let cursor = rCursor(doc, start, to), range = null;
        while (!cursor.next().done)
          range = cursor.value;
        if (range && (start == from || range.from > start + 10))
          return range;
        if (start == from)
          return null;
      }
    }
    return {
      findNext: function() {
        return this.find(false);
      },
      findPrevious: function() {
        return this.find(true);
      },
      find: function(back) {
        var doc = cm.cm6.state.doc;
        if (back) {
          let endAt = last ? last.from == last.to ? last.to - 1 : last.from : firstOffset;
          last = prevMatchInRange(0, endAt);
        } else {
          let startFrom = last ? last.from == last.to ? last.to + 1 : last.to : firstOffset;
          last = nextMatch(startFrom);
        }
        lastCM5Result = last && {
          from: posFromIndex(doc, last.from),
          to: posFromIndex(doc, last.to),
          match: last.match
        };
        return last && last.match;
      },
      from: function() {
        return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from;
      },
      to: function() {
        return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to;
      },
      replace: function(text) {
        if (last) {
          dispatchChange(cm, {
            changes: { from: last.from, to: last.to, insert: text }
          });
          last.to = last.from + text.length;
          if (lastCM5Result) {
            lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);
          }
        }
      }
    };
  }
  findPosV(start, amount, unit, goalColumn) {
    let { cm6 } = this;
    const doc = cm6.state.doc;
    let pixels = unit == "page" ? cm6.dom.clientHeight : 0;
    const startOffset = indexFromPos(doc, start);
    let range = EditorSelection.range(startOffset, startOffset, goalColumn);
    let count = Math.round(Math.abs(amount));
    for (let i = 0; i < count; i++) {
      if (unit == "page") {
        range = cm6.moveVertically(range, amount > 0, pixels);
      } else if (unit == "line") {
        range = cm6.moveVertically(range, amount > 0);
      }
    }
    let pos = posFromIndex(doc, range.head);
    if (amount < 0 && range.head == 0 && goalColumn != 0 && start.line == 0 && start.ch != 0 || amount > 0 && range.head == doc.length && pos.ch != goalColumn && start.line == pos.line) {
      pos.hitSide = true;
    }
    return pos;
  }
  charCoords(pos, mode) {
    var rect = this.cm6.contentDOM.getBoundingClientRect();
    var offset = indexFromPos(this.cm6.state.doc, pos);
    var coords = this.cm6.coordsAtPos(offset);
    var d2 = -rect.top;
    return { left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left, top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d2, bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d2 };
  }
  coordsChar(coords, mode) {
    var rect = this.cm6.contentDOM.getBoundingClientRect();
    var offset = this.cm6.posAtCoords({ x: coords.left + rect.left, y: coords.top + rect.top }) || 0;
    return posFromIndex(this.cm6.state.doc, offset);
  }
  getScrollInfo() {
    var scroller = this.cm6.scrollDOM;
    return {
      left: scroller.scrollLeft,
      top: scroller.scrollTop,
      height: scroller.scrollHeight,
      width: scroller.scrollWidth,
      clientHeight: scroller.clientHeight,
      clientWidth: scroller.clientWidth
    };
  }
  scrollTo(x, y2) {
    if (x != null)
      this.cm6.scrollDOM.scrollLeft = x;
    if (y2 != null)
      this.cm6.scrollDOM.scrollTop = y2;
  }
  scrollIntoView(pos, margin) {
    if (pos) {
      var offset = this.indexFromPos(pos);
      this.cm6.dispatch({
        effects: EditorView.scrollIntoView(offset)
      });
    } else {
      this.cm6.dispatch({ scrollIntoView: true, userEvent: "scroll" });
    }
  }
  getWrapperElement() {
    return this.cm6.dom;
  }
  getMode() {
    return { name: this.getOption("mode") };
  }
  setSize(w2, h3) {
    this.cm6.dom.style.width = w2 + 4 + "px";
    this.cm6.dom.style.height = h3 + "px";
    this.refresh();
  }
  refresh() {
    this.cm6.measure();
  }
  destroy() {
    this.removeOverlay();
  }
  onChange(update) {
    for (let i in this.marks) {
      let m2 = this.marks[i];
      m2.update(update.changes);
    }
    if (this.virtualSelection) {
      this.virtualSelection.ranges = this.virtualSelection.ranges.map((range) => range.map(update.changes));
    }
    var curOp = this.curOp = this.curOp || {};
    update.changes.iterChanges((fromA, toA, fromB, toB, text) => {
      if (curOp.$changeStart == null || curOp.$changeStart > fromB)
        curOp.$changeStart = fromB;
      this.$lastChangeEndOffset = toB;
      var change = { text: text.toJSON() };
      if (!curOp.lastChange) {
        curOp.lastChange = curOp.change = change;
      } else {
        curOp.lastChange.next = curOp.lastChange = change;
      }
    }, true);
    if (!curOp.changeHandlers)
      curOp.changeHandlers = this._handlers["change"] && this._handlers["change"].slice();
  }
  onSelectionChange() {
    var curOp = this.curOp = this.curOp || {};
    if (!curOp.cursorActivityHandlers)
      curOp.cursorActivityHandlers = this._handlers["cursorActivity"] && this._handlers["cursorActivity"].slice();
    this.curOp.cursorActivity = true;
  }
  operation(fn2) {
    if (!this.curOp)
      this.curOp = { $d: 0 };
    this.curOp.$d++;
    try {
      var result = fn2();
    } finally {
      if (this.curOp) {
        this.curOp.$d--;
        if (!this.curOp.$d)
          this.onBeforeEndOperation();
      }
    }
    return result;
  }
  onBeforeEndOperation() {
    var op = this.curOp;
    var scrollIntoView = false;
    if (op) {
      if (op.change) {
        signalTo(op.changeHandlers, this, op.change);
      }
      if (op && op.cursorActivity) {
        signalTo(op.cursorActivityHandlers, this, null);
        if (op.isVimOp)
          scrollIntoView = true;
      }
      this.curOp = null;
    }
    if (scrollIntoView)
      this.scrollIntoView();
  }
  moveH(increment, unit) {
    if (unit == "char") {
      var cur = this.getCursor();
      this.setCursor(cur.line, cur.ch + increment);
    }
  }
  setOption(name, val) {
    switch (name) {
      case "keyMap":
        this.state.keyMap = val;
        break;
    }
  }
  getOption(name) {
    switch (name) {
      case "firstLineNumber":
        return 1;
      case "tabSize":
        return this.cm6.state.tabSize || 4;
      case "readonly":
        return this.cm6.state.readOnly;
      case "indentWithTabs":
        return this.cm6.state.facet(indentUnit) == "	";
      case "indentUnit":
        return this.cm6.state.facet(indentUnit).length || 2;
      case "keyMap":
        return this.state.keyMap || "vim";
    }
  }
  toggleOverwrite(on3) {
    this.state.overwrite = on3;
  }
  getTokenTypeAt(pos) {
    var _a;
    var offset = this.indexFromPos(pos);
    var tree = ensureSyntaxTree(this.cm6.state, offset);
    var node = tree === null || tree === void 0 ? void 0 : tree.resolve(offset);
    var type = ((_a = node === null || node === void 0 ? void 0 : node.type) === null || _a === void 0 ? void 0 : _a.name) || "";
    if (/comment/i.test(type))
      return "comment";
    if (/string/i.test(type))
      return "string";
    return "";
  }
  overWriteSelection(text) {
    var doc = this.cm6.state.doc;
    var sel = this.cm6.state.selection;
    var ranges = sel.ranges.map((x) => {
      if (x.empty) {
        var ch = x.to < doc.length ? doc.sliceString(x.from, x.to + 1) : "";
        if (ch && !/\n/.test(ch))
          return EditorSelection.range(x.from, x.to + 1);
      }
      return x;
    });
    this.cm6.dispatch({
      selection: EditorSelection.create(ranges, sel.mainIndex)
    });
    this.replaceSelection(text);
  }
  isInMultiSelectMode() {
    return this.cm6.state.selection.ranges.length > 1;
  }
  virtualSelectionMode() {
    return !!this.virtualSelection;
  }
  forEachSelection(command2) {
    var selection = this.cm6.state.selection;
    this.virtualSelection = EditorSelection.create(selection.ranges, selection.mainIndex);
    for (var i = 0; i < this.virtualSelection.ranges.length; i++) {
      var range = this.virtualSelection.ranges[i];
      if (!range)
        continue;
      this.cm6.dispatch({ selection: EditorSelection.create([range]) });
      command2();
      this.virtualSelection.ranges[i] = this.cm6.state.selection.ranges[0];
    }
    this.cm6.dispatch({ selection: this.virtualSelection });
    this.virtualSelection = null;
  }
};
CodeMirror.Pos = Pos;
CodeMirror.StringStream = StringStream;
CodeMirror.commands = {
  cursorCharLeft: function(cm) {
    cursorCharLeft(cm.cm6);
  },
  redo: function(cm) {
    runHistoryCommand(cm, false);
  },
  undo: function(cm) {
    runHistoryCommand(cm, true);
  },
  newlineAndIndent: function(cm) {
    insertNewlineAndIndent({
      state: cm.cm6.state,
      dispatch: (tr) => {
        return dispatchChange(cm, tr);
      }
    });
  },
  indentAuto: function(cm) {
    indentSelection(cm.cm6);
  }
};
CodeMirror.defineOption = function(name, val, setter) {
};
CodeMirror.isWordChar = function(ch) {
  return wordChar.test(ch);
};
CodeMirror.keys = {
  Backspace: function(cm) {
    deleteCharBackward(cm.cm6);
  },
  Delete: function(cm) {
    deleteCharForward(cm.cm6);
  }
};
CodeMirror.keyMap = {};
CodeMirror.addClass = function() {
};
CodeMirror.rmClass = function() {
};
CodeMirror.e_preventDefault = function(e) {
  e.preventDefault();
};
CodeMirror.e_stop = function(e) {
  var _a, _b;
  (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);
  (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);
};
CodeMirror.keyName = function(e) {
  var key = e.key;
  if (ignoredKeys[key])
    return;
  if (key == "Escape")
    key = "Esc";
  if (key == " ")
    key = "Space";
  if (key.length > 1) {
    key = key.replace(/Numpad|Arrow/, "");
  }
  if (key.length == 1)
    key = key.toUpperCase();
  var name = "";
  if (e.ctrlKey) {
    name += "Ctrl-";
  }
  if (e.altKey) {
    name += "Alt-";
  }
  if ((name || key.length > 1) && e.shiftKey) {
    name += "Shift-";
  }
  name += key;
  return name;
};
CodeMirror.vimKey = function vimKey(e) {
  var key = e.key;
  if (ignoredKeys[key])
    return;
  if (key.length > 1 && key[0] == "n") {
    key = key.replace("Numpad", "");
  }
  key = specialKey[key] || key;
  var name = "";
  if (e.ctrlKey) {
    name += "C-";
  }
  if (e.altKey) {
    name += "A-";
  }
  if (e.metaKey) {
    name += "M-";
  }
  if ((name || key.length > 1) && e.shiftKey) {
    name += "S-";
  }
  name += key;
  if (name.length > 1) {
    name = "<" + name + ">";
  }
  return name;
};
CodeMirror.lookupKey = function lookupKey(key, map, handle) {
  var result = CodeMirror.keys[key];
  if (result)
    handle(result);
};
CodeMirror.on = on;
CodeMirror.off = off;
CodeMirror.signal = signal;
CodeMirror.findMatchingTag = findMatchingTag;
CodeMirror.findEnclosingTag = findEnclosingTag;
function dialogDiv(cm, template, bottom) {
  var dialog = document.createElement("div");
  dialog.appendChild(template);
  return dialog;
}
function closeNotification(cm, newVal) {
  if (cm.state.currentNotificationClose)
    cm.state.currentNotificationClose();
  cm.state.currentNotificationClose = newVal;
}
function openNotification(cm, template, options) {
  closeNotification(cm, close);
  var dialog = dialogDiv(cm, template, options && options.bottom);
  var closed = false;
  var doneTimer;
  var duration = options && typeof options.duration !== "undefined" ? options.duration : 5e3;
  function close() {
    if (closed)
      return;
    closed = true;
    clearTimeout(doneTimer);
    dialog.remove();
    hideDialog(cm, dialog);
  }
  dialog.onclick = function(e) {
    e.preventDefault();
    close();
  };
  showDialog(cm, dialog);
  if (duration)
    doneTimer = setTimeout(close, duration);
  return close;
}
function showDialog(cm, dialog) {
  var oldDialog = cm.state.dialog;
  cm.state.dialog = dialog;
  if (dialog && oldDialog !== dialog) {
    if (oldDialog && oldDialog.contains(document.activeElement))
      cm.focus();
    if (oldDialog && oldDialog.parentElement) {
      oldDialog.parentElement.replaceChild(dialog, oldDialog);
    } else if (oldDialog) {
      oldDialog.remove();
    }
    CodeMirror.signal(cm, "dialog");
  }
}
function hideDialog(cm, dialog) {
  if (cm.state.dialog == dialog) {
    cm.state.dialog = null;
    CodeMirror.signal(cm, "dialog");
  }
}
function openDialog(me, template, callback, options) {
  if (!options)
    options = {};
  closeNotification(me, void 0);
  var dialog = dialogDiv(me, template, options.bottom);
  var closed = false;
  showDialog(me, dialog);
  function close(newVal) {
    if (typeof newVal == "string") {
      inp.value = newVal;
    } else {
      if (closed)
        return;
      closed = true;
      hideDialog(me, dialog);
      if (!me.state.dialog)
        me.focus();
      if (options.onClose)
        options.onClose(dialog);
    }
  }
  var inp = dialog.getElementsByTagName("input")[0];
  if (inp) {
    if (options.value) {
      inp.value = options.value;
      if (options.selectValueOnOpen !== false)
        inp.select();
    }
    if (options.onInput)
      CodeMirror.on(inp, "input", function(e) {
        options.onInput(e, inp.value, close);
      });
    if (options.onKeyUp)
      CodeMirror.on(inp, "keyup", function(e) {
        options.onKeyUp(e, inp.value, close);
      });
    CodeMirror.on(inp, "keydown", function(e) {
      if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {
        return;
      }
      if (e.keyCode == 13)
        callback(inp.value);
      if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {
        inp.blur();
        CodeMirror.e_stop(e);
        close();
      }
    });
    if (options.closeOnBlur !== false)
      CodeMirror.on(inp, "blur", function() {
        setTimeout(function() {
          if (document.activeElement === inp)
            return;
          close();
        });
      });
    inp.focus();
  }
  return close;
}
var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };
function bracketRegex(config) {
  return config && config.bracketRegex || /[(){}[\]]/;
}
function scanForBracket(cm, where, dir, style, config) {
  var maxScanLen = config && config.maxScanLineLength || 1e4;
  var maxScanLines = config && config.maxScanLines || 1e3;
  var stack = [];
  var re = bracketRegex(config);
  var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
  for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
    var line = cm.getLine(lineNo);
    if (!line)
      continue;
    var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
    if (line.length > maxScanLen)
      continue;
    if (lineNo == where.line)
      pos = where.ch - (dir < 0 ? 1 : 0);
    for (; pos != end; pos += dir) {
      var ch = line.charAt(pos);
      if (re.test(ch)) {
        var match = matching[ch];
        if (match && match.charAt(1) == ">" == dir > 0)
          stack.push(ch);
        else if (!stack.length)
          return { pos: new Pos(lineNo, pos), ch };
        else
          stack.pop();
      }
    }
  }
  return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
}
function findMatchingTag(cm, pos) {
  var state = cm.cm6.state;
  var offset = cm.indexFromPos(pos);
  var m2 = matchBrackets(state, offset + 1, -1, { brackets: "\n\n" });
  if (m2) {
    if (!m2.end || !m2.start)
      return;
    return {
      open: convertRange(state.doc, m2.end),
      close: convertRange(state.doc, m2.start)
    };
  }
  m2 = matchBrackets(state, offset, 1, { brackets: "\n\n" });
  if (m2) {
    if (!m2.end || !m2.start)
      return;
    return {
      open: convertRange(state.doc, m2.start),
      close: convertRange(state.doc, m2.end)
    };
  }
}
function convertRange(doc, cm6Range) {
  return {
    from: posFromIndex(doc, cm6Range.from),
    to: posFromIndex(doc, cm6Range.to)
  };
}
function findEnclosingTag(cm, pos) {
  var state = cm.cm6.state;
  var offset = cm.indexFromPos(pos);
  var text = state.sliceDoc(0, offset);
  var i = offset;
  while (i > 0) {
    var m2 = matchBrackets(state, i, 1, { brackets: "\n\n" });
    if (m2 && m2.start && m2.end) {
      return {
        open: convertRange(state.doc, m2.start),
        close: convertRange(state.doc, m2.end)
      };
    }
    i = text.lastIndexOf(">", i - 1);
  }
}
var Marker = class {
  constructor(cm, offset, assoc) {
    this.cm = cm;
    this.id = cm.$mid++;
    this.offset = offset;
    this.assoc = assoc;
    cm.marks[this.id] = this;
  }
  clear() {
    delete this.cm.marks[this.id];
  }
  find() {
    if (this.offset == null)
      return null;
    return this.cm.posFromIndex(this.offset);
  }
  update(change) {
    if (this.offset != null)
      this.offset = change.mapPos(this.offset, this.assoc, MapMode.TrackDel);
  }
};
var Piece = class {
  constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {
    this.left = left;
    this.top = top;
    this.height = height;
    this.fontFamily = fontFamily;
    this.fontSize = fontSize;
    this.fontWeight = fontWeight;
    this.color = color;
    this.className = className;
    this.letter = letter;
    this.partial = partial;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    elt.style.height = this.height + "px";
    elt.style.lineHeight = this.height + "px";
    elt.style.fontFamily = this.fontFamily;
    elt.style.fontSize = this.fontSize;
    elt.style.fontWeight = this.fontWeight;
    elt.style.color = this.partial ? "transparent" : this.color;
    elt.className = this.className;
    elt.textContent = this.letter;
  }
  eq(p3) {
    return this.left == p3.left && this.top == p3.top && this.height == p3.height && this.fontFamily == p3.fontFamily && this.fontSize == p3.fontSize && this.fontWeight == p3.fontWeight && this.color == p3.color && this.className == p3.className && this.letter == p3.letter;
  }
};
var BlockCursorPlugin = class {
  constructor(view, cm) {
    this.view = view;
    this.rangePieces = [];
    this.cursors = [];
    this.cm = cm;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
    this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
    this.cursorLayer.className = "cm-cursorLayer cm-vimCursorLayer";
    this.cursorLayer.setAttribute("aria-hidden", "true");
    view.requestMeasure(this.measureReq);
    this.setBlinkRate();
  }
  setBlinkRate() {
    this.cursorLayer.style.animationDuration = 1200 + "ms";
  }
  update(update) {
    if (update.selectionSet || update.geometryChanged || update.viewportChanged) {
      this.view.requestMeasure(this.measureReq);
      this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    }
  }
  scheduleRedraw() {
    this.view.requestMeasure(this.measureReq);
  }
  readPos() {
    let { state } = this.view;
    let cursors = [];
    for (let r of state.selection.ranges) {
      let prim = r == state.selection.main;
      let piece = measureCursor(this.cm, this.view, r, prim);
      if (piece)
        cursors.push(piece);
    }
    return { cursors };
  }
  drawSel({ cursors }) {
    if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
      let oldCursors = this.cursorLayer.children;
      if (oldCursors.length !== cursors.length) {
        this.cursorLayer.textContent = "";
        for (const c of cursors)
          this.cursorLayer.appendChild(c.draw());
      } else {
        cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
      }
      this.cursors = cursors;
    }
  }
  destroy() {
    this.cursorLayer.remove();
  }
};
var themeSpec = {
  ".cm-vimMode .cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-fat-cursor": {
    position: "absolute",
    background: "#ff9696",
    border: "none",
    whiteSpace: "pre"
  },
  "&:not(.cm-focused) .cm-fat-cursor": {
    background: "none",
    outline: "solid 1px #ff9696"
  }
};
var hideNativeSelection = Prec.highest(EditorView.theme(themeSpec));
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
  return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
}
function measureCursor(cm, view, cursor, primary) {
  let head = cursor.head;
  let fatCursor = false;
  let hCoeff = 1;
  let vim2 = cm.state.vim;
  if (vim2 && (!vim2.insertMode || cm.state.overwrite)) {
    fatCursor = true;
    if (vim2.visualBlock && !primary)
      return null;
    if (cursor.anchor < cursor.head)
      head--;
    if (cm.state.overwrite)
      hCoeff = 0.2;
    else if (vim2.status)
      hCoeff = 0.5;
  }
  if (fatCursor) {
    let pos = view.coordsAtPos(head, cursor.assoc || 1);
    if (!pos)
      return null;
    let base = getBase(view);
    let domAtPos = view.domAtPos(head);
    let node = domAtPos ? domAtPos.node : view.contentDOM;
    while (domAtPos && domAtPos.node instanceof HTMLElement) {
      node = domAtPos.node;
      domAtPos = { node: domAtPos.node.childNodes[domAtPos.offset], offset: 0 };
    }
    if (!(node instanceof HTMLElement)) {
      node = node.parentNode;
    }
    let style = getComputedStyle(node);
    let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);
    if (!letter || letter == "\n" || letter == "\r")
      letter = "\xA0";
    let h3 = pos.bottom - pos.top;
    return new Piece(pos.left - base.left, pos.top - base.top + h3 * (1 - hCoeff), h3 * hCoeff, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? "cm-fat-cursor cm-cursor-primary" : "cm-fat-cursor cm-cursor-secondary", letter, hCoeff != 1);
  } else {
    return null;
  }
}
var Vim = initVim(CodeMirror);
var HighlightMargin = 250;
var vimStyle = EditorView.baseTheme({
  ".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)": {
    display: "none"
  },
  ".cm-vim-panel": {
    padding: "0px 10px",
    fontFamily: "monospace",
    minHeight: "1.3em"
  },
  ".cm-vim-panel input": {
    border: "none",
    outline: "none",
    backgroundColor: "inherit"
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" }
});
var vimPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.status = "";
    this.query = null;
    this.decorations = Decoration.none;
    this.view = view;
    const cm = this.cm = new CodeMirror(view);
    Vim.enterVimMode(this.cm);
    this.view.cm = this.cm;
    this.cm.state.vimPlugin = this;
    this.blockCursor = new BlockCursorPlugin(view, cm);
    this.updateClass();
    this.cm.on("vim-command-done", () => {
      if (cm.state.vim)
        cm.state.vim.status = "";
      this.blockCursor.scheduleRedraw();
      this.updateStatus();
    });
    this.cm.on("vim-mode-change", (e) => {
      cm.state.vim.mode = e.mode;
      if (e.subMode) {
        cm.state.vim.mode += " block";
      }
      cm.state.vim.status = "";
      this.blockCursor.scheduleRedraw();
      this.updateClass();
      this.updateStatus();
    });
    this.cm.on("dialog", () => {
      if (this.cm.state.statusbar) {
        this.updateStatus();
      } else {
        view.dispatch({
          effects: showVimPanel.of(!!this.cm.state.dialog)
        });
      }
    });
    this.dom = document.createElement("span");
    this.dom.style.cssText = "position: absolute; right: 10px; top: 1px";
  }
  update(update) {
    var _a;
    if ((update.viewportChanged || update.docChanged) && this.query) {
      this.highlight(this.query);
    }
    if (update.docChanged) {
      this.cm.onChange(update);
    }
    if (update.selectionSet) {
      this.cm.onSelectionChange();
    }
    if (update.viewportChanged)
      ;
    if (this.cm.curOp && !this.cm.curOp.isVimOp) {
      this.cm.onBeforeEndOperation();
    }
    if (update.transactions) {
      for (let tr of update.transactions)
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery)) {
            let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;
            if (!forVim) {
              this.highlight(null);
            } else {
              let query = effect.value.create();
              this.highlight(query);
            }
          }
        }
    }
    this.blockCursor.update(update);
  }
  updateClass() {
    const state = this.cm.state;
    if (!state.vim || state.vim.insertMode && !state.overwrite)
      this.view.scrollDOM.classList.remove("cm-vimMode");
    else
      this.view.scrollDOM.classList.add("cm-vimMode");
  }
  updateStatus() {
    let dom = this.cm.state.statusbar;
    if (!dom)
      return;
    let dialog = this.cm.state.dialog;
    let vim2 = this.cm.state.vim;
    if (dialog) {
      if (dialog.parentElement != dom) {
        dom.textContent = "";
        dom.appendChild(dialog);
      }
    } else {
      dom.textContent = `--${(vim2.mode || "normal").toUpperCase()}--`;
    }
    this.dom.textContent = vim2.status;
    dom.appendChild(this.dom);
  }
  destroy() {
    this.cm.state.vim = null;
    this.updateClass();
    this.blockCursor.destroy();
    delete this.view.cm;
  }
  highlight(query) {
    this.query = query;
    if (!query)
      return this.decorations = Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
      let { from, to } = ranges[i];
      while (i < l - 1 && to > ranges[i + 1].from - 2 * HighlightMargin)
        to = ranges[++i].to;
      query.highlight(view.state.doc, from, to, (from2, to2) => {
        builder.add(from2, to2, matchMark2);
      });
    }
    return this.decorations = builder.finish();
  }
}, {
  eventHandlers: {
    keydown: function(e, view) {
      const key = CodeMirror.vimKey(e);
      const cm = this.cm;
      if (!key)
        return;
      let vim2 = cm.state.vim;
      if (key == "<Esc>" && !vim2.insertMode && !vim2.visualMode && this.query) {
        const searchState2 = vim2.searchState_;
        if (searchState2) {
          cm.removeOverlay(searchState2.getOverlay());
          searchState2.setOverlay(null);
        }
      }
      cm.state.vim.status = (cm.state.vim.status || "") + key;
      let result = Vim.multiSelectHandleKey(cm, key, "user");
      if (!result && cm.state.vim.insertMode && cm.state.overwrite) {
        if (e.key && e.key.length == 1 && !/\n/.test(e.key)) {
          result = true;
          cm.overWriteSelection(e.key);
        } else if (e.key == "Backspace") {
          result = true;
          CodeMirror.commands.cursorCharLeft(cm);
        }
      }
      if (result) {
        CodeMirror.signal(this.cm, "vim-keypress", key);
        e.preventDefault();
        e.stopPropagation();
        this.blockCursor.scheduleRedraw();
      }
      this.updateStatus();
      return !!result;
    }
  },
  decorations: (v) => v.decorations
});
var matchMark2 = Decoration.mark({ class: "cm-searchMatch" });
var showVimPanel = StateEffect.define();
var vimPanelState = StateField.define({
  create: () => false,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(showVimPanel))
        value = e.value;
    return value;
  },
  provide: (f) => {
    return showPanel.from(f, (on3) => on3 ? createVimPanel : null);
  }
});
function createVimPanel(view) {
  let dom = document.createElement("div");
  dom.className = "cm-vim-panel";
  let cm = view.cm;
  if (cm.state.dialog) {
    dom.appendChild(cm.state.dialog);
  }
  return { top: false, dom };
}
function statusPanel(view) {
  let dom = document.createElement("div");
  dom.className = "cm-vim-panel";
  let cm = view.cm;
  cm.state.statusbar = dom;
  cm.state.vimPlugin.updateStatus();
  return { dom };
}
function vim(options = {}) {
  return [
    vimStyle,
    vimPlugin,
    hideNativeSelection,
    options.status ? showPanel.of(statusPanel) : vimPanelState
  ];
}

// node_modules/@codemirror/language-data/dist/index.js
function legacy(parser) {
  return new LanguageSupport(StreamLanguage.define(parser));
}
function sql(dialectName) {
  return import("./dist-2OVIBIGZ.js").then((m2) => m2.sql({ dialect: m2[dialectName] }));
}
var languages = [
  LanguageDescription.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./dist-3YB5THKY.js").then((m2) => m2.cpp());
    }
  }),
  LanguageDescription.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./dist-3YB5THKY.js").then((m2) => m2.cpp());
    }
  }),
  LanguageDescription.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return sql("Cassandra");
    }
  }),
  LanguageDescription.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./dist-FUU65KAZ.js").then((m2) => m2.css());
    }
  }),
  LanguageDescription.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./dist-R2LBW7AE.js").then((m2) => m2.html());
    }
  }),
  LanguageDescription.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./dist-FSRSSEEE.js").then((m2) => m2.java());
    }
  }),
  LanguageDescription.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./dist-Y5OEHM7J.js").then((m2) => m2.javascript());
    }
  }),
  LanguageDescription.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./dist-DNXRM2QD.js").then((m2) => m2.json());
    }
  }),
  LanguageDescription.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./dist-Y5OEHM7J.js").then((m2) => m2.javascript({ jsx: true }));
    }
  }),
  LanguageDescription.of({
    name: "MariaDB SQL",
    load() {
      return sql("MariaSQL");
    }
  }),
  LanguageDescription.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./dist-HY4QUI7Z.js").then((m2) => m2.markdown());
    }
  }),
  LanguageDescription.of({
    name: "MS SQL",
    load() {
      return sql("MSSQL");
    }
  }),
  LanguageDescription.of({
    name: "MySQL",
    load() {
      return sql("MySQL");
    }
  }),
  LanguageDescription.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./dist-SDDQY3NU.js").then((m2) => m2.php());
    }
  }),
  LanguageDescription.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return sql("PLSQL");
    }
  }),
  LanguageDescription.of({
    name: "PostgreSQL",
    load() {
      return sql("PostgreSQL");
    }
  }),
  LanguageDescription.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./dist-E7I4DPHR.js").then((m2) => m2.python());
    }
  }),
  LanguageDescription.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./dist-5T4QPKVI.js").then((m2) => m2.rust());
    }
  }),
  LanguageDescription.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return sql("StandardSQL");
    }
  }),
  LanguageDescription.of({
    name: "SQLite",
    load() {
      return sql("SQLite");
    }
  }),
  LanguageDescription.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./dist-Y5OEHM7J.js").then((m2) => m2.javascript({ jsx: true, typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts"],
    load() {
      return import("./dist-Y5OEHM7J.js").then((m2) => m2.javascript({ typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./dist-ZPMONHG2.js").then((m2) => m2.wast());
    }
  }),
  LanguageDescription.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./dist-KGAONKIN.js").then((m2) => m2.xml());
    }
  }),
  LanguageDescription.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-B5XM5SD5.js").then((m2) => legacy(m2.apl));
    }
  }),
  LanguageDescription.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-SZ3HUSQ7.js").then((m2) => legacy(m2.asciiArmor));
    }
  }),
  LanguageDescription.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-YDYE3SIO.js").then((m2) => legacy(m2.asn1({})));
    }
  }),
  LanguageDescription.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-FROQMMM3.js").then((m2) => legacy(m2.asterisk));
    }
  }),
  LanguageDescription.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-4DPB4BYE.js").then((m2) => legacy(m2.brainfuck));
    }
  }),
  LanguageDescription.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-UH7PFKKT.js").then((m2) => legacy(m2.cobol));
    }
  }),
  LanguageDescription.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-V22LWRO3.js").then((m2) => legacy(m2.csharp));
    }
  }),
  LanguageDescription.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-YOYBS3AF.js").then((m2) => legacy(m2.clojure));
    }
  }),
  LanguageDescription.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-YOYBS3AF.js").then((m2) => legacy(m2.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-SDXILMP5.js").then((m2) => legacy(m2.gss));
    }
  }),
  LanguageDescription.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-DU53OQX2.js").then((m2) => legacy(m2.cmake));
    }
  }),
  LanguageDescription.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-4REVC2JT.js").then((m2) => legacy(m2.coffeeScript));
    }
  }),
  LanguageDescription.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-XRI6TKOR.js").then((m2) => legacy(m2.commonLisp));
    }
  }),
  LanguageDescription.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-6KQRDSWW.js").then((m2) => legacy(m2.cypher));
    }
  }),
  LanguageDescription.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-5S4LQSUI.js").then((m2) => legacy(m2.cython));
    }
  }),
  LanguageDescription.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-XCK7HWP6.js").then((m2) => legacy(m2.crystal));
    }
  }),
  LanguageDescription.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-ILB4D4NX.js").then((m2) => legacy(m2.d));
    }
  }),
  LanguageDescription.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-V22LWRO3.js").then((m2) => legacy(m2.dart));
    }
  }),
  LanguageDescription.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-K2X2GIKE.js").then((m2) => legacy(m2.diff));
    }
  }),
  LanguageDescription.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-S7HTE7Q4.js").then((m2) => legacy(m2.dockerFile));
    }
  }),
  LanguageDescription.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-34LR3ZRW.js").then((m2) => legacy(m2.dtd));
    }
  }),
  LanguageDescription.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-IEEHPTV6.js").then((m2) => legacy(m2.dylan));
    }
  }),
  LanguageDescription.of({
    name: "EBNF",
    load() {
      return import("./ebnf-VQW3DLWF.js").then((m2) => legacy(m2.ebnf));
    }
  }),
  LanguageDescription.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-HPWZGLCI.js").then((m2) => legacy(m2.ecl));
    }
  }),
  LanguageDescription.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-YOYBS3AF.js").then((m2) => legacy(m2.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-SULXJSSU.js").then((m2) => legacy(m2.eiffel));
    }
  }),
  LanguageDescription.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-AVKAR5MU.js").then((m2) => legacy(m2.elm));
    }
  }),
  LanguageDescription.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-XCXDAUX2.js").then((m2) => legacy(m2.erlang));
    }
  }),
  LanguageDescription.of({
    name: "Esper",
    load() {
      return import("./sql-T2CF3LUS.js").then((m2) => legacy(m2.esper));
    }
  }),
  LanguageDescription.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-JO2FER46.js").then((m2) => legacy(m2.factor));
    }
  }),
  LanguageDescription.of({
    name: "FCL",
    load() {
      return import("./fcl-CI73S2FU.js").then((m2) => legacy(m2.fcl));
    }
  }),
  LanguageDescription.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-RZX7BXZN.js").then((m2) => legacy(m2.forth));
    }
  }),
  LanguageDescription.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-RP2AR2C7.js").then((m2) => legacy(m2.fortran));
    }
  }),
  LanguageDescription.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-3P3VY2I6.js").then((m2) => legacy(m2.fSharp));
    }
  }),
  LanguageDescription.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-FCOH5FKT.js").then((m2) => legacy(m2.gas));
    }
  }),
  LanguageDescription.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-ZKYVW7CM.js").then((m2) => legacy(m2.gherkin));
    }
  }),
  LanguageDescription.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./go-AAMFV3J6.js").then((m2) => legacy(m2.go));
    }
  }),
  LanguageDescription.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-PL3VF2ZF.js").then((m2) => legacy(m2.groovy));
    }
  }),
  LanguageDescription.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-C22PR4IH.js").then((m2) => legacy(m2.haskell));
    }
  }),
  LanguageDescription.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-KCWDR4QH.js").then((m2) => legacy(m2.haxe));
    }
  }),
  LanguageDescription.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-KCWDR4QH.js").then((m2) => legacy(m2.hxml));
    }
  }),
  LanguageDescription.of({
    name: "HTTP",
    load() {
      return import("./http-KIO7DPFJ.js").then((m2) => legacy(m2.http));
    }
  }),
  LanguageDescription.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-YHXXF4IT.js").then((m2) => legacy(m2.idl));
    }
  }),
  LanguageDescription.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-6VINJEKN.js").then((m2) => legacy(m2.jsonld));
    }
  }),
  LanguageDescription.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-M7NG4ZLH.js").then((m2) => legacy(m2.jinja2));
    }
  }),
  LanguageDescription.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-IXXBW24P.js").then((m2) => legacy(m2.julia));
    }
  }),
  LanguageDescription.of({
    name: "Kotlin",
    extensions: ["kt"],
    load() {
      return import("./clike-V22LWRO3.js").then((m2) => legacy(m2.kotlin));
    }
  }),
  LanguageDescription.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./css-SDXILMP5.js").then((m2) => legacy(m2.less));
    }
  }),
  LanguageDescription.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-TR3SBSOL.js").then((m2) => legacy(m2.liveScript));
    }
  }),
  LanguageDescription.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-CQ5Y7UD6.js").then((m2) => legacy(m2.lua));
    }
  }),
  LanguageDescription.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-2WKJZM5H.js").then((m2) => legacy(m2.mirc));
    }
  }),
  LanguageDescription.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-XTK7D37E.js").then((m2) => legacy(m2.mathematica));
    }
  }),
  LanguageDescription.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-7AMU3FV4.js").then((m2) => legacy(m2.modelica));
    }
  }),
  LanguageDescription.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-4Z6BANC4.js").then((m2) => legacy(m2.mumps));
    }
  }),
  LanguageDescription.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-CBJXSBNO.js").then((m2) => legacy(m2.mbox));
    }
  }),
  LanguageDescription.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-SMH37DKW.js").then((m2) => legacy(m2.nginx));
    }
  }),
  LanguageDescription.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-TVPTQHET.js").then((m2) => legacy(m2.nsis));
    }
  }),
  LanguageDescription.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-YE3FPYNT.js").then((m2) => legacy(m2.ntriples));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-V22LWRO3.js").then((m2) => legacy(m2.objectiveC));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-V22LWRO3.js").then((m2) => legacy(m2.objectiveCpp));
    }
  }),
  LanguageDescription.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-3P3VY2I6.js").then((m2) => legacy(m2.oCaml));
    }
  }),
  LanguageDescription.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-U5MQ6WBZ.js").then((m2) => legacy(m2.octave));
    }
  }),
  LanguageDescription.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-3RAT2LQ4.js").then((m2) => legacy(m2.oz));
    }
  }),
  LanguageDescription.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-R6EZCVRI.js").then((m2) => legacy(m2.pascal));
    }
  }),
  LanguageDescription.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-YZT2XQRH.js").then((m2) => legacy(m2.perl));
    }
  }),
  LanguageDescription.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-ISOQOXUU.js").then((m2) => legacy(m2.pig));
    }
  }),
  LanguageDescription.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-CVK6E537.js").then((m2) => legacy(m2.powerShell));
    }
  }),
  LanguageDescription.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-B3DTBR5H.js").then((m2) => legacy(m2.properties));
    }
  }),
  LanguageDescription.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-QKTMYFTR.js").then((m2) => legacy(m2.protobuf));
    }
  }),
  LanguageDescription.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-C3D6LJ44.js").then((m2) => legacy(m2.puppet));
    }
  }),
  LanguageDescription.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-AIBX277L.js").then((m2) => legacy(m2.q));
    }
  }),
  LanguageDescription.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-K3MNFF7P.js").then((m2) => legacy(m2.r));
    }
  }),
  LanguageDescription.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-L65OBDQ2.js").then((m2) => legacy(m2.rpmChanges));
    }
  }),
  LanguageDescription.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-L65OBDQ2.js").then((m2) => legacy(m2.rpmSpec));
    }
  }),
  LanguageDescription.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    load() {
      return import("./ruby-DFCIJKUY.js").then((m2) => legacy(m2.ruby));
    }
  }),
  LanguageDescription.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-6PSAJ24F.js").then((m2) => legacy(m2.sas));
    }
  }),
  LanguageDescription.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./sass-MYR7I3UT.js").then((m2) => legacy(m2.sass));
    }
  }),
  LanguageDescription.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-V22LWRO3.js").then((m2) => legacy(m2.scala));
    }
  }),
  LanguageDescription.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-V7OVPORT.js").then((m2) => legacy(m2.scheme));
    }
  }),
  LanguageDescription.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./css-SDXILMP5.js").then((m2) => legacy(m2.sCSS));
    }
  }),
  LanguageDescription.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-EYDYGBLR.js").then((m2) => legacy(m2.shell));
    }
  }),
  LanguageDescription.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-PF6SZL7M.js").then((m2) => legacy(m2.sieve));
    }
  }),
  LanguageDescription.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-GVUW4RCS.js").then((m2) => legacy(m2.smalltalk));
    }
  }),
  LanguageDescription.of({
    name: "Solr",
    load() {
      return import("./solr-FXKTTPPT.js").then((m2) => legacy(m2.solr));
    }
  }),
  LanguageDescription.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-3P3VY2I6.js").then((m2) => legacy(m2.sml));
    }
  }),
  LanguageDescription.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-T7BSKTQO.js").then((m2) => legacy(m2.sparql));
    }
  }),
  LanguageDescription.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-OR4G66SG.js").then((m2) => legacy(m2.spreadsheet));
    }
  }),
  LanguageDescription.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-V22LWRO3.js").then((m2) => legacy(m2.squirrel));
    }
  }),
  LanguageDescription.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-7ZKAU6QH.js").then((m2) => legacy(m2.stylus));
    }
  }),
  LanguageDescription.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-4IEMNPF2.js").then((m2) => legacy(m2.swift));
    }
  }),
  LanguageDescription.of({
    name: "sTeX",
    load() {
      return import("./stex-MOWFZZAX.js").then((m2) => legacy(m2.stex));
    }
  }),
  LanguageDescription.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-MOWFZZAX.js").then((m2) => legacy(m2.stex));
    }
  }),
  LanguageDescription.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-RBR4F2J2.js").then((m2) => legacy(m2.verilog));
    }
  }),
  LanguageDescription.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-ONPAKEVX.js").then((m2) => legacy(m2.tcl));
    }
  }),
  LanguageDescription.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-UHUW4Y7P.js").then((m2) => legacy(m2.textile));
    }
  }),
  LanguageDescription.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-RNLICTV5.js").then((m2) => legacy(m2.tiddlyWiki));
    }
  }),
  LanguageDescription.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-BS2WUGCV.js").then((m2) => legacy(m2.tiki));
    }
  }),
  LanguageDescription.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-N3XMM2QL.js").then((m2) => legacy(m2.toml));
    }
  }),
  LanguageDescription.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-TKUFALOK.js").then((m2) => legacy(m2.troff));
    }
  }),
  LanguageDescription.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-E3LHK5FT.js").then((m2) => legacy(m2.ttcn));
    }
  }),
  LanguageDescription.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-E7R6JSQT.js").then((m2) => legacy(m2.ttcnCfg));
    }
  }),
  LanguageDescription.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-7PSJBHG4.js").then((m2) => legacy(m2.turtle));
    }
  }),
  LanguageDescription.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-NZLP4PAD.js").then((m2) => legacy(m2.webIDL));
    }
  }),
  LanguageDescription.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-YZJSSA3E.js").then((m2) => legacy(m2.vb));
    }
  }),
  LanguageDescription.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-4NFGZSE7.js").then((m2) => legacy(m2.vbScript));
    }
  }),
  LanguageDescription.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-WZ23QDFN.js").then((m2) => legacy(m2.velocity));
    }
  }),
  LanguageDescription.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-RBR4F2J2.js").then((m2) => legacy(m2.verilog));
    }
  }),
  LanguageDescription.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-7ZEIBUMW.js").then((m2) => legacy(m2.vhdl));
    }
  }),
  LanguageDescription.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-AQNC7QCS.js").then((m2) => legacy(m2.xQuery));
    }
  }),
  LanguageDescription.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-LET7CB54.js").then((m2) => legacy(m2.yacas));
    }
  }),
  LanguageDescription.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./yaml-JOQUPJ36.js").then((m2) => legacy(m2.yaml));
    }
  }),
  LanguageDescription.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-2HSTNDGB.js").then((m2) => legacy(m2.z80));
    }
  }),
  LanguageDescription.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-2IXMTA5E.js").then((m2) => legacy(m2.mscgen));
    }
  }),
  LanguageDescription.of({
    name: "X\xF9",
    extensions: ["xu"],
    load() {
      return import("./mscgen-2IXMTA5E.js").then((m2) => legacy(m2.xu));
    }
  }),
  LanguageDescription.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-2IXMTA5E.js").then((m2) => legacy(m2.msgenny));
    }
  })
];

// node_modules/ink-mde/dist/ink.js
function nt(e, n, t) {
  let o = t.length, r = n.length, a = o, l = 0, i = 0, s = n[r - 1].nextSibling, c = null;
  for (; l < r || i < a; ) {
    if (n[l] === t[i]) {
      l++, i++;
      continue;
    }
    for (; n[r - 1] === t[a - 1]; )
      r--, a--;
    if (r === l) {
      const u2 = a < o ? i ? t[i - 1].nextSibling : t[a - i] : s;
      for (; i < a; )
        e.insertBefore(t[i++], u2);
    } else if (a === i)
      for (; l < r; )
        (!c || !c.has(n[l])) && n[l].remove(), l++;
    else if (n[l] === t[a - 1] && t[i] === n[r - 1]) {
      const u2 = n[--r].nextSibling;
      e.insertBefore(t[i++], n[l++].nextSibling), e.insertBefore(t[--a], u2), n[r] = t[a];
    } else {
      if (!c) {
        c = /* @__PURE__ */ new Map();
        let k2 = i;
        for (; k2 < a; )
          c.set(t[k2], k2++);
      }
      const u2 = c.get(n[l]);
      if (u2 != null)
        if (i < u2 && u2 < a) {
          let k2 = l, L = 1, H;
          for (; ++k2 < r && k2 < a && !((H = c.get(n[k2])) == null || H !== u2 + L); )
            L++;
          if (L > u2 - i) {
            const I = n[l];
            for (; i < u2; )
              e.insertBefore(t[i++], I);
          } else
            e.replaceChild(t[i++], n[l++]);
        } else
          l++;
      else
        n[l++].remove();
    }
  }
}
var le = "_$DX_DELEGATE";
function ot(e, n, t) {
  let o;
  return createRoot((r) => {
    o = r, n === document ? e() : p(n, e(), n.firstChild ? null : void 0, t);
  }), () => {
    o(), n.textContent = "";
  };
}
function h(e, n, t) {
  const o = document.createElement("template");
  o.innerHTML = e;
  let r = o.content.firstChild;
  return t && (r = r.firstChild), r;
}
function ke(e, n = window.document) {
  const t = n[le] || (n[le] = /* @__PURE__ */ new Set());
  for (let o = 0, r = e.length; o < r; o++) {
    const a = e[o];
    t.has(a) || (t.add(a), n.addEventListener(a, rt));
  }
}
function se(e, n, t) {
  t == null ? e.removeAttribute(n) : e.setAttribute(n, t);
}
function p(e, n, t, o) {
  if (t !== void 0 && !o && (o = []), typeof n != "function")
    return F(e, n, o, t);
  createRenderEffect((r) => F(e, n(), r, t), o);
}
function rt(e) {
  const n = `$$${e.type}`;
  let t = e.composedPath && e.composedPath()[0] || e.target;
  for (e.target !== t && Object.defineProperty(e, "target", {
    configurable: true,
    value: t
  }), Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return t || document;
    }
  }), sharedConfig.registry && !sharedConfig.done && (sharedConfig.done = true, document.querySelectorAll("[id^=pl-]").forEach((o) => o.remove())); t !== null; ) {
    const o = t[n];
    if (o && !t.disabled) {
      const r = t[`${n}Data`];
      if (r !== void 0 ? o.call(t, r, e) : o.call(t, e), e.cancelBubble)
        return;
    }
    t = t.host && t.host !== t && t.host instanceof Node ? t.host : t.parentNode;
  }
}
function F(e, n, t, o, r) {
  for (sharedConfig.context && !t && (t = [...e.childNodes]); typeof t == "function"; )
    t = t();
  if (n === t)
    return t;
  const a = typeof n, l = o !== void 0;
  if (e = l && t[0] && t[0].parentNode || e, a === "string" || a === "number") {
    if (sharedConfig.context)
      return t;
    if (a === "number" && (n = n.toString()), l) {
      let i = t[0];
      i && i.nodeType === 3 ? i.data = n : i = document.createTextNode(n), t = B(e, t, o, i);
    } else
      t !== "" && typeof t == "string" ? t = e.firstChild.data = n : t = e.textContent = n;
  } else if (n == null || a === "boolean") {
    if (sharedConfig.context)
      return t;
    t = B(e, t, o);
  } else {
    if (a === "function")
      return createRenderEffect(() => {
        let i = n();
        for (; typeof i == "function"; )
          i = i();
        t = F(e, i, t, o);
      }), () => t;
    if (Array.isArray(n)) {
      const i = [], s = t && Array.isArray(t);
      if (G(i, n, t, r))
        return createRenderEffect(() => t = F(e, i, t, o, true)), () => t;
      if (sharedConfig.context) {
        for (let c = 0; c < i.length; c++)
          if (i[c].parentNode)
            return t = i;
      }
      if (i.length === 0) {
        if (t = B(e, t, o), l)
          return t;
      } else
        s ? t.length === 0 ? ce(e, i, o) : nt(e, t, i) : (t && B(e), ce(e, i));
      t = i;
    } else if (n instanceof Node) {
      if (sharedConfig.context && n.parentNode)
        return t = l ? [n] : n;
      if (Array.isArray(t)) {
        if (l)
          return t = B(e, t, o, n);
        B(e, t, null, n);
      } else
        t == null || t === "" || !e.firstChild ? e.appendChild(n) : e.replaceChild(n, e.firstChild);
      t = n;
    }
  }
  return t;
}
function G(e, n, t, o) {
  let r = false;
  for (let a = 0, l = n.length; a < l; a++) {
    let i = n[a], s = t && t[a];
    if (i instanceof Node)
      e.push(i);
    else if (!(i == null || i === true || i === false))
      if (Array.isArray(i))
        r = G(e, i, s) || r;
      else if (typeof i == "function")
        if (o) {
          for (; typeof i == "function"; )
            i = i();
          r = G(e, Array.isArray(i) ? i : [i], s) || r;
        } else
          e.push(i), r = true;
      else {
        const c = String(i);
        s && s.nodeType === 3 && s.data === c ? e.push(s) : e.push(document.createTextNode(c));
      }
  }
  return r;
}
function ce(e, n, t) {
  for (let o = 0, r = n.length; o < r; o++)
    e.insertBefore(n[o], t);
}
function B(e, n, t, o) {
  if (t === void 0)
    return e.textContent = "";
  const r = o || document.createTextNode("");
  if (n.length) {
    let a = false;
    for (let l = n.length - 1; l >= 0; l--) {
      const i = n[l];
      if (r !== i) {
        const s = i.parentNode === e;
        !a && !l ? s ? e.replaceChild(r, i) : e.insertBefore(r, t) : s && i.remove();
      } else
        a = true;
    }
  } else
    e.insertBefore(r, t);
  return [r];
}
var _ = {
  array: "[object Array]",
  object: "[object Object]",
  string: "[object String]",
  undefined: "[object Undefined]",
  window: "[object Window]"
};
var it = (e) => {
  if (Object.prototype.toString.call(e) === _.object)
    return `[object ${e.constructor.name}]`;
};
var N = (e, n) => it(e) === n;
var at = (e, n) => {
  const t = /* @__PURE__ */ new WeakMap(), o = (r, a) => t.get(r) || (N(r, _.object) && t.set(r, true), N(a, _.undefined)) ? r : N(r, _.array) && N(a, _.array) ? [...a] : N(r, _.object) && N(a, _.object) ? Object.keys(r).reduce((l, i) => (Object.hasOwn(a, i) ? l[i] = o(r[i], a[i]) : l[i] = r[i], l), {}) : a;
  return o(e, n);
};
var V = (e, n) => at(e, n);
var E = ((e) => (e.Auto = "auto", e.Dark = "dark", e.Light = "light", e))(E || {});
var $ = ((e) => (e.Appearance = "appearance", e.Attribution = "attribution", e.Autocomplete = "autocomplete", e.Images = "images", e.ReadOnly = "readonly", e.Spellcheck = "spellcheck", e.Vim = "vim", e))($ || {});
var m = ((e) => (e.Bold = "bold", e.Code = "code", e.CodeBlock = "code_block", e.Heading = "heading", e.Image = "image", e.Italic = "italic", e.Link = "link", e.List = "list", e.OrderedList = "ordered_list", e.Quote = "quote", e.TaskList = "task_list", e))(m || {});
var R = ((e) => (e.Completion = "completion", e.Default = "default", e.Grammar = "grammar", e))(R || {});
var de = () => document.createElement("div");
var xe = () => window.matchMedia("(prefers-color-scheme: dark)").matches;
var lt = (e) => e === E.Dark ? true : e === E.Light ? false : xe();
var X = (e) => {
  const n = [
    { suffix: "border-radius", default: "0.25rem" },
    { suffix: "color", default: "currentColor" },
    { suffix: "flex-direction", default: "column" },
    { suffix: "font-family", default: "inherit" },
    { suffix: "block-background-color", default: "#121212", light: "#f5f5f5" },
    { suffix: "block-background-color-on-hover", default: "#0f0f0f", light: "#e0e0e0" },
    { suffix: "block-max-height", default: "20rem" },
    { suffix: "block-padding", default: "0.5rem" },
    { suffix: "code-background-color", default: "var(--ink-internal-block-background-color)" },
    { suffix: "code-color", default: "inherit" },
    { suffix: "code-font-family", default: "'Monaco', Courier, monospace" },
    { suffix: "editor-font-size", default: "1em" },
    { suffix: "editor-line-height", default: "2em" },
    { suffix: "editor-padding", default: "0.5rem" },
    { suffix: "inline-padding", default: "0.125rem" },
    { suffix: "modal-position", default: "fixed" },
    { suffix: "syntax-atom-color", default: "#d19a66" },
    { suffix: "syntax-comment-color", default: "#abb2bf" },
    { suffix: "syntax-comment-font-style", default: "italic" },
    { suffix: "syntax-emphasis-color", default: "inherit" },
    { suffix: "syntax-emphasis-font-style", default: "italic" },
    { suffix: "syntax-hashtag-background-color", default: "#222", light: "#eee" },
    { suffix: "syntax-hashtag-color", default: "inherit" },
    { suffix: "syntax-heading-color", default: "inherit" },
    { suffix: "syntax-heading-font-weight", default: "600" },
    { suffix: "syntax-heading1-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading1-font-size", default: "1.6em" },
    { suffix: "syntax-heading1-font-weight", default: "600" },
    { suffix: "syntax-heading2-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading2-font-size", default: "1.5em" },
    { suffix: "syntax-heading2-font-weight", default: "600" },
    { suffix: "syntax-heading3-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading3-font-size", default: "1.4em" },
    { suffix: "syntax-heading3-font-weight", default: "600" },
    { suffix: "syntax-heading4-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading4-font-size", default: "1.3em" },
    { suffix: "syntax-heading4-font-weight", default: "600" },
    { suffix: "syntax-heading5-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading5-font-size", default: "1.2em" },
    { suffix: "syntax-heading5-font-weight", default: "600" },
    { suffix: "syntax-heading6-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading6-font-size", default: "1.1em" },
    { suffix: "syntax-heading6-font-weight", default: "600" },
    { suffix: "syntax-highlight-background-color", default: "#555555" },
    { suffix: "syntax-keyword-color", default: "#c678dd" },
    { suffix: "syntax-link-color", default: "inherit" },
    { suffix: "syntax-meta-color", default: "#abb2bf" },
    { suffix: "syntax-monospace-color", default: "var(--ink-internal-code-color)" },
    { suffix: "syntax-monospace-font-family", default: "var(--ink-internal-code-font-family)" },
    { suffix: "syntax-name-color", default: "#d19a66" },
    { suffix: "syntax-name-label-color", default: "#abb2bf" },
    { suffix: "syntax-name-property-color", default: "#96c0d8" },
    { suffix: "syntax-name-property-definition-color", default: "#e06c75" },
    { suffix: "syntax-name-variable-color", default: "#e06c75" },
    { suffix: "syntax-name-variable-definition-color", default: "#e5c07b" },
    { suffix: "syntax-name-variable-local-color", default: "#d19a66" },
    { suffix: "syntax-name-variable-special-color", default: "inherit" },
    { suffix: "syntax-number-color", default: "#d19a66" },
    { suffix: "syntax-operator-color", default: "#96c0d8" },
    { suffix: "syntax-processing-instruction-color", default: "#444444", light: "#bbbbbb" },
    { suffix: "syntax-punctuation-color", default: "#abb2bf" },
    { suffix: "syntax-strikethrough-color", default: "inherit" },
    { suffix: "syntax-strikethrough-text-decoration", default: "line-through" },
    { suffix: "syntax-string-color", default: "#98c379" },
    { suffix: "syntax-string-special-color", default: "inherit" },
    { suffix: "syntax-strong-color", default: "inherit" },
    { suffix: "syntax-strong-font-weight", default: "600" },
    { suffix: "syntax-url-color", default: "#aaaaaa", light: "#666666" }
  ], t = !lt(e.options.interface.appearance);
  return n.map((o) => {
    const r = t && o.light ? o.light : o.default;
    return `--ink-internal-${o.suffix}: var(--ink-${o.suffix}, ${r});`;
  });
};
var fe = () => [
  EditorView.theme({}, { dark: true })
];
var ue = () => [
  EditorView.theme({}, { dark: false })
];
var st = class extends WidgetType {
  constructor() {
    super();
  }
  eq() {
    return true;
  }
  toDOM() {
    const n = document.createElement("div"), t = n.appendChild(document.createElement("span")), o = n.appendChild(document.createElement("a"));
    return n.setAttribute("aria-hidden", "true"), n.style.bottom = "0", n.style.fontSize = "0.75em", n.style.opacity = "0.5", n.style.position = "absolute", n.style.right = "0", t.innerText = "powered by ", o.href = "https://github.com/voracious/ink-mde", o.innerText = "ink-mde", o.rel = "noopener noreferrer", o.target = "_blank", o.style.color = "var(--ink-internal-color)", o.style.fontWeight = "600", o.style.textDecoration = "none", n;
  }
};
var ct = EditorView.baseTheme({
  ".cm-content": {
    paddingBottom: "2em"
  }
});
var dt = StateField.define({
  create(e) {
    return RangeSet.of(ge().range(e.doc.length));
  },
  update(e, n) {
    return RangeSet.of(ge().range(n.newDoc.length));
  },
  provide(e) {
    return EditorView.decorations.from(e);
  }
});
var ge = () => Decoration.widget({
  widget: new st(),
  side: 1,
  block: true
});
var ft = () => [
  ct,
  dt
];
var ut = class extends WidgetType {
  constructor({ url: n }) {
    super();
    __publicField(this, "url");
    this.url = n;
  }
  eq(n) {
    return n.url === this.url;
  }
  toDOM() {
    const n = document.createElement("div"), t = n.appendChild(document.createElement("div")), o = t.appendChild(document.createElement("figure")), r = o.appendChild(document.createElement("img"));
    return n.setAttribute("aria-hidden", "true"), n.className = "cm-image-container", t.className = "cm-image-backdrop", o.className = "cm-image-figure", r.className = "cm-image-img", r.src = this.url, n.style.paddingBottom = "0.5rem", n.style.paddingTop = "0.5rem", t.classList.add("cm-image-backdrop"), t.style.borderRadius = "var(--ink-internal-border-radius)", t.style.display = "flex", t.style.alignItems = "center", t.style.justifyContent = "center", t.style.overflow = "hidden", t.style.maxWidth = "100%", o.style.margin = "0", r.style.display = "block", r.style.maxHeight = "var(--ink-internal-block-max-height)", r.style.maxWidth = "100%", r.style.width = "100%", n;
  }
};
var gt = () => {
  const e = /!\[.*?\]\((?<url>.*?)\)/, n = (a) => Decoration.widget({
    widget: new ut(a),
    side: -1,
    block: true
  }), t = (a) => {
    const l = [];
    return syntaxTree(a).iterate({
      enter: ({ type: i, from: s, to: c }) => {
        if (i.name === "Image") {
          const u2 = e.exec(a.doc.sliceString(s, c));
          u2 && u2.groups && u2.groups.url && l.push(n({ url: u2.groups.url }).range(a.doc.lineAt(s).from));
        }
      }
    }), l.length > 0 ? RangeSet.of(l) : Decoration.none;
  }, o = EditorView.baseTheme({
    ".cm-image-backdrop": {
      backgroundColor: "var(--ink-internal-block-background-color)"
    }
  }), r = StateField.define({
    create(a) {
      return t(a);
    },
    update(a, l) {
      return l.docChanged ? t(l.state) : a.map(l.changes);
    },
    provide(a) {
      return EditorView.decorations.from(a);
    }
  });
  return [
    o,
    r
  ];
};
var pt = () => EditorView.contentAttributes.of({
  spellcheck: "true"
});
var mt = (e, n) => {
  const t = e.resolver(n);
  return e.compartment.of(t);
};
var ht = (e) => e.extensions.map((n) => mt(n, e.options));
var kt = (e, n) => {
  const t = e.resolver(n);
  return e.compartment.reconfigure(t);
};
var be = (e) => e.extensions.map((n) => kt(n, e.options));
var S = (e) => {
  const n = new Compartment(), t = bt[e];
  return {
    compartment: n,
    name: e,
    resolver: t
  };
};
var xt = () => [
  S($.Appearance),
  S($.Attribution),
  S($.Autocomplete),
  S($.Images),
  S($.ReadOnly),
  S($.Spellcheck),
  S($.Vim)
];
var bt = {
  appearance({ interface: { appearance: e } }) {
    return e === E.Dark ? fe() : e === E.Light ? ue() : xe() ? fe() : ue();
  },
  attribution(e) {
    return e.interface.attribution ? ft() : [];
  },
  autocomplete(e) {
    return e.interface.autocomplete ? closeBrackets() : [];
  },
  images(e) {
    return e.interface.images ? gt() : [];
  },
  readonly(e) {
    return e.interface.readonly ? EditorState.readOnly.of(true) : EditorState.readOnly.of(false);
  },
  spellcheck(e) {
    return e.interface.spellcheck ? pt() : [];
  },
  vim(e) {
    return e.vim ? vim() : [];
  }
};
var ve = () => ({
  editor: new EditorView(),
  extensions: xt(),
  options: {
    doc: "",
    files: {
      clipboard: false,
      dragAndDrop: false,
      handler: () => {
      },
      injectMarkup: true,
      types: ["image/*"]
    },
    hooks: {
      afterUpdate: () => {
      },
      beforeUpdate: () => {
      }
    },
    interface: {
      appearance: E.Auto,
      attribution: true,
      autocomplete: false,
      images: false,
      readonly: false,
      spellcheck: true,
      toolbar: false
    },
    plugins: [],
    selections: [],
    toolbar: {
      bold: true,
      code: true,
      codeBlock: true,
      heading: true,
      image: true,
      italic: true,
      link: true,
      list: true,
      orderedList: true,
      quote: true,
      taskList: true,
      upload: false
    },
    vim: false
  },
  root: de(),
  target: de()
});
var vt = (e) => V(ve(), e);
var yt = (e) => {
  const [n, t] = createSignal(vt({ options: e }));
  return [n, t];
};
var ye = (e) => {
  const n = e.map((t) => SelectionRange.fromJSON({ anchor: t.start, head: t.end }));
  return EditorSelection.create(n);
};
var wt = (e) => e.ranges.map((t) => ({
  end: t.anchor < t.head ? t.head : t.anchor,
  start: t.head < t.anchor ? t.head : t.anchor
}));
var w = (e) => ({ ...{
  block: false,
  line: false,
  multiline: false,
  nodes: [],
  prefix: "",
  prefixStates: [],
  suffix: ""
}, ...e });
var Ct = {
  [m.Bold]: w({
    nodes: ["StrongEmphasis"],
    prefix: "**",
    suffix: "**"
  }),
  [m.Code]: w({
    nodes: ["InlineCode"],
    prefix: "`",
    suffix: "`"
  }),
  [m.CodeBlock]: w({
    block: true,
    nodes: ["FencedCode"],
    prefix: "```\n",
    suffix: "\n```"
  }),
  [m.Heading]: w({
    multiline: true,
    nodes: ["ATXHeading1", "ATXHeading2", "ATXHeading3", "ATXHeading4", "ATXHeading5", "ATXHeading6"],
    prefix: "# ",
    prefixStates: ["# ", "## ", "### ", "#### ", "##### ", "###### ", ""]
  }),
  [m.Image]: w({
    nodes: ["Image"],
    prefix: "![](",
    suffix: ")"
  }),
  [m.Italic]: w({
    nodes: ["Emphasis"],
    prefix: "*",
    suffix: "*"
  }),
  [m.Link]: w({
    nodes: ["Link"],
    prefix: "[](",
    suffix: ")"
  }),
  [m.OrderedList]: w({
    line: true,
    multiline: true,
    nodes: ["OrderedList"],
    prefix: "1. "
  }),
  [m.Quote]: w({
    line: true,
    multiline: true,
    nodes: ["Blockquote"],
    prefix: "> "
  }),
  [m.TaskList]: w({
    line: true,
    multiline: true,
    nodes: ["BulletList"],
    prefix: "- [ ] "
  }),
  [m.List]: w({
    line: true,
    multiline: true,
    nodes: ["BulletList"],
    prefix: "- "
  })
};
var we = ([e, n], t) => {
  const { editor: o } = e(), r = o.lineBlockAt(t.start), a = o.lineBlockAt(t.end);
  return { start: r.from, end: a.to };
};
var Lt = ([e, n], t) => {
  const { editor: o } = e();
  let r = t.start;
  const a = [];
  for (; r <= t.end; ) {
    const l = o.lineBlockAt(r), i = Math.max(r, l.from), s = Math.min(r, l.to);
    a.push({ start: i, end: s }), r = l.to + 1;
  }
  return a;
};
var $t = ([e, n], t) => {
  var _a, _b;
  const { editor: o } = e(), r = ((_a = o.state.wordAt(t.start)) == null ? void 0 : _a.from) || t.start, a = ((_b = o.state.wordAt(t.end)) == null ? void 0 : _b.to) || t.end;
  return { start: r, end: a };
};
var Mt = ([e, n], t) => t || P([e, n]).pop() || { start: 0, end: 0 };
var Ce = ([e, n], t) => {
  const { editor: o } = e();
  return o.state.sliceDoc(t.start, t.end);
};
var Y = ([e, n], t, o) => St(e(), o).find(({ type: a }) => t.nodes.includes(a.name));
var St = ({ editor: { state: e } }, n) => {
  const t = [];
  return syntaxTree(e).iterate({
    from: n.start,
    to: n.end,
    enter: ({ type: o, from: r, to: a }) => {
      t.push({ type: o, from: r, to: a });
    }
  }), t;
};
var ee = ([e, n], t, o) => {
  const r = Ce([e, n], o), a = t.prefix.length, l = t.suffix.length * -1 || r.length, i = r.slice(a, l);
  T([e, n], i, o);
};
var _t = ([e, n], t, o) => {
  const r = we([e, n], o), a = Y([e, n], t, r);
  if (a) {
    const l = a.from, i = a.to;
    ee([e, n], t, { start: l, end: i });
  } else {
    const l = t.prefix, i = t.suffix;
    U([e, n], { before: l, after: i, selection: r });
  }
};
var At = ([e, n], t, o) => {
  Lt([e, n], o).forEach((a) => {
    Le([e, n], t, a);
  });
};
var Le = ([e, n], t, o) => {
  const r = we([e, n], o), a = Y([e, n], t, r), l = t.prefixStates.length > 0;
  if (a && l)
    t.prefixStates.find((i, s) => {
      const c = a.from, u2 = a.to, k2 = Ce([e, n], { start: c, end: u2 }), L = k2.startsWith(i);
      return L && T([e, n], k2.replace(new RegExp(`^${i}`), t.prefixStates[s + 1]), { start: c, end: u2 }), L;
    });
  else if (a) {
    const i = a.from, s = a.to;
    ee([e, n], t, { start: i, end: s });
  } else {
    const i = t.prefix, s = t.suffix;
    U([e, n], { before: i, after: s, selection: r });
  }
};
var Bt = ([e, n], t, o) => {
  const r = Y([e, n], t, o);
  if (r) {
    const a = r.from, l = r.to;
    ee([e, n], t, { start: a, end: l });
  } else {
    const { start: a, end: l } = $t([e, n], o), i = Array.isArray(t.prefix) ? t.prefix[0] : t.prefix, s = t.suffix;
    U([e, n], { before: i, after: s, selection: { start: a, end: l } });
  }
};
var Nt = ([e, n], t, o) => {
  const r = Ct[t], a = Mt([e, n], o);
  r.block ? _t([e, n], r, a) : r.multiline ? At([e, n], r, a) : r.line ? Le([e, n], r, a) : Bt([e, n], r, a);
};
var Dt = EditorView.baseTheme({
  ".cm-line": {
    fontFamily: "var(--ink-internal-font-family)"
  },
  ".cm-line.cm-codeblock": {
    backgroundColor: "var(--ink-internal-block-background-color)",
    fontFamily: "var(--ink-internal-code-font-family)",
    padding: "0 var(--ink-internal-block-padding)"
  },
  ".cm-line.cm-codeblock.cm-codeblock-open": {
    borderRadius: "var(--ink-internal-border-radius) var(--ink-internal-border-radius) 0 0",
    paddingTop: "var(--ink-internal-block-padding)"
  },
  ".cm-line.cm-codeblock.cm-codeblock-close": {
    borderRadius: "0 0 var(--ink-internal-border-radius) var(--ink-internal-border-radius)",
    paddingBottom: "var(--ink-internal-block-padding)"
  },
  ".cm-line .cm-code": {
    backgroundColor: "var(--ink-internal-block-background-color)",
    fontFamily: "var(--ink-internal-code-font-family)",
    padding: "var(--ink-internal-inline-padding) 0"
  },
  ".cm-line .cm-code.cm-code-open": {
    borderRadius: "var(--ink-internal-border-radius) 0 0 var(--ink-internal-border-radius)",
    paddingLeft: "var(--ink-internal-inline-padding)"
  },
  ".cm-line .cm-code.cm-code-close": {
    borderRadius: "0 var(--ink-internal-border-radius) var(--ink-internal-border-radius) 0",
    paddingRight: "var(--ink-internal-inline-padding)"
  }
});
var Et = [
  "CodeBlock",
  "FencedCode",
  "HTMLBlock",
  "CommentBlock"
];
var Tt = Decoration.line({ attributes: { class: "cm-codeblock" } });
var Ht = Decoration.line({ attributes: { class: "cm-codeblock-open" } });
var jt = Decoration.line({ attributes: { class: "cm-codeblock-close" } });
var zt = Decoration.mark({ attributes: { class: "cm-code" } });
var Vt = Decoration.mark({ attributes: { class: "cm-code cm-code-open" } });
var Ot = Decoration.mark({ attributes: { class: "cm-code cm-code-close" } });
var It = ViewPlugin.define((e) => ({
  update: () => Rt(e)
}), { decorations: (e) => e.update() });
var Rt = (e) => {
  const n = new RangeSetBuilder(), t = syntaxTree(e.state);
  for (const o of e.visibleRanges)
    for (let r = o.from; r < o.to; ) {
      const a = e.state.doc.lineAt(r);
      let l;
      t.iterate({
        enter({ type: i, from: s, to: c }) {
          if (i.name !== "Document")
            if (Et.includes(i.name)) {
              n.add(a.from, a.from, Tt);
              const u2 = e.state.doc.lineAt(s), k2 = e.state.doc.lineAt(c);
              return u2.number === a.number && n.add(a.from, a.from, Ht), k2.number === a.number && n.add(a.from, a.from, jt), false;
            } else
              i.name === "InlineCode" ? l = { from: s, to: c, innerFrom: s, innerTo: c } : i.name === "CodeMark" && (s === l.from ? (l.innerFrom = c, n.add(s, c, Vt)) : c === l.to && (l.innerTo = s, n.add(l.innerFrom, l.innerTo, zt), n.add(s, c, Ot)));
        },
        from: a.from,
        to: a.to
      }), r = a.to + 1;
    }
  return n.finish();
};
var Wt = () => [
  Dt,
  It
];
var Ft = [
  {
    key: "Tab",
    run: ({ state: e, dispatch: n }) => e.selection.ranges.some((t) => !t.empty) ? indentMore({ state: e, dispatch: n }) : (n(e.update(e.replaceSelection("  "), {
      scrollIntoView: true,
      annotations: Transaction.userEvent.of("input")
    })), true),
    shift: indentLess
  }
];
var Pt = () => keymap.of([
  ...Ft,
  ...defaultKeymap,
  ...historyKeymap
]);
var Ut = () => EditorView.lineWrapping;
var qt = () => {
  const e = EditorView.baseTheme({
    "&": {},
    ".cm-scroller": {
      lineHeight: "var(--ink-internal-editor-line-height)",
      fontFamily: "var(--ink-internal-font-family)",
      fontSize: "var(--ink-internal-editor-font-size)"
    },
    ".cm-line": {
      padding: "0"
    }
  }), n = syntaxHighlighting(HighlightStyle.define([
    {
      tag: tags.atom,
      color: "var(--ink-internal-syntax-atom-color)"
    },
    {
      tag: tags.meta,
      color: "var(--ink-internal-syntax-meta-color)"
    },
    {
      tag: tags.emphasis,
      color: "var(--ink-internal-syntax-emphasis-color)",
      fontStyle: "var(--ink-internal-syntax-emphasis-font-style)"
    },
    {
      tag: tags.strong,
      color: "var(--ink-internal-syntax-strong-color)",
      fontWeight: "var(--ink-internal-syntax-strong-font-weight)"
    },
    {
      tag: tags.strikethrough,
      color: "var(--ink-internal-syntax-strikethrough-color)",
      textDecoration: "var(--ink-internal-syntax-strikethrough-text-decoration)"
    },
    {
      tag: tags.comment,
      color: "var(--ink-internal-syntax-comment-color)",
      fontStyle: "var(--ink-internal-syntax-comment-font-style)"
    },
    {
      tag: tags.monospace,
      color: "var(--ink-internal-syntax-code-color)",
      fontFamily: "var(--ink-internal-syntax-code-font-family)"
    },
    {
      tag: tags.name,
      color: "var(--ink-internal-syntax-name-color)"
    },
    {
      tag: tags.labelName,
      color: "var(--ink-internal-syntax-name-label-color)"
    },
    {
      tag: tags.propertyName,
      color: "var(--ink-internal-syntax-name-property-color)"
    },
    {
      tag: tags.definition(tags.propertyName),
      color: "var(--ink-internal-syntax-name-property-definition-color)"
    },
    {
      tag: tags.variableName,
      color: "var(--ink-internal-syntax-name-variable-color)"
    },
    {
      tag: tags.definition(tags.variableName),
      color: "var(--ink-internal-syntax-name-variable-definition-color)"
    },
    {
      tag: tags.local(tags.variableName),
      color: "var(--ink-internal-syntax-name-variable-local-color)"
    },
    {
      tag: tags.special(tags.variableName),
      color: "var(--ink-internal-syntax-name-variable-special-color)"
    },
    {
      tag: tags.heading,
      color: "var(--ink-internal-syntax-heading-color)",
      fontWeight: "var(--ink-internal-syntax-heading-font-weight)"
    },
    {
      tag: tags.heading1,
      color: "var(--ink-internal-syntax-heading1-color)",
      fontSize: "var(--ink-internal-syntax-heading1-font-size)",
      fontWeight: "var(--ink-internal-syntax-heading1-font-weight)"
    },
    {
      tag: tags.heading2,
      color: "var(--ink-internal-syntax-heading2-color)",
      fontSize: "var(--ink-internal-syntax-heading2-font-size)",
      fontWeight: "var(--ink-internal-syntax-heading2-font-weight)"
    },
    {
      tag: tags.heading3,
      color: "var(--ink-internal-syntax-heading3-color)",
      fontSize: "var(--ink-internal-syntax-heading3-font-size)",
      fontWeight: "var(--ink-internal-syntax-heading3-font-weight)"
    },
    {
      tag: tags.heading4,
      color: "var(--ink-internal-syntax-heading4-color)",
      fontSize: "var(--ink-internal-syntax-heading4-font-size)",
      fontWeight: "var(--ink-internal-syntax-heading4-font-weight)"
    },
    {
      tag: tags.heading5,
      color: "var(--ink-internal-syntax-heading5-color)",
      fontSize: "var(--ink-internal-syntax-heading5-font-size)",
      fontWeight: "var(--ink-internal-syntax-heading5-font-weight)"
    },
    {
      tag: tags.heading6,
      color: "var(--ink-internal-syntax-heading6-color)",
      fontSize: "var(--ink-internal-syntax-heading6-font-size)",
      fontWeight: "var(--ink-internal-syntax-heading6-font-weight)"
    },
    {
      tag: tags.keyword,
      color: "var(--ink-internal-syntax-keyword-color)"
    },
    {
      tag: tags.number,
      color: "var(--ink-internal-syntax-number-color)"
    },
    {
      tag: tags.operator,
      color: "var(--ink-internal-syntax-operator-color)"
    },
    {
      tag: tags.punctuation,
      color: "var(--ink-internal-syntax-punctuation-color)"
    },
    {
      tag: tags.link,
      color: "var(--ink-internal-syntax-link-color)"
    },
    {
      tag: tags.url,
      color: "var(--ink-internal-syntax-url-color)"
    },
    {
      tag: tags.string,
      color: "var(--ink-internal-syntax-string-color)"
    },
    {
      tag: tags.special(tags.string),
      color: "var(--ink-internal-syntax-string-special-color)"
    },
    {
      tag: tags.processingInstruction,
      color: "var(--ink-internal-syntax-processing-instruction-color)"
    }
  ]));
  return [
    e,
    n
  ];
};
var Xt = (e) => {
  if (e.length > 0)
    return ye(e);
};
var $e = (e) => {
  const n = e.options.plugins.flatMap((r) => r.type === R.Completion ? r.value : []), t = e.options.plugins.flatMap((r) => r.type === R.Default ? r.value : []), o = e.options.plugins.flatMap((r) => r.type === R.Grammar ? r.value : []);
  return EditorState.create({
    doc: e.options.doc,
    selection: Xt(e.options.selections),
    extensions: [
      ...ht(e),
      autocompletion({
        defaultKeymap: true,
        icons: false,
        override: n,
        optionClass: () => "ink-tooltip-option"
      }),
      Wt(),
      history(),
      Pt(),
      Ut(),
      markdown({
        base: markdownLanguage,
        codeLanguages: languages,
        extensions: o
      }),
      qt(),
      ...t
    ]
  });
};
var Qt = ([e, n]) => {
  const { editor: t } = e();
  t.destroy();
};
var Gt = ([e, n]) => {
  const { editor: t } = e();
  return t.state.sliceDoc();
};
var K = ([e, n]) => {
  const { editor: t } = e();
  t.hasFocus || t.focus();
};
var Kt = ([e, n], t, o) => Nt([e, n], t, o);
var T = ([e, n], t, o, r = false) => {
  const { editor: a } = e();
  let l = o == null ? void 0 : o.start, i = (o == null ? void 0 : o.end) || (o == null ? void 0 : o.start);
  if (typeof l > "u") {
    const c = P([e, n]).pop();
    l = c.start, i = c.end;
  }
  const s = { changes: { from: l, to: i, insert: t } };
  if (r) {
    const c = l === i ? l + t.length : l, u2 = l + t.length;
    Object.assign(s, { selection: { anchor: c, head: u2 } });
  }
  a.dispatch(a.state.update(s));
};
var Zt = ([e, n], t) => {
  n(V(e(), { options: { doc: t } })), e().editor.setState($e(e()));
};
var Jt = (e) => ({
  destroy: Qt.bind(void 0, e),
  doc: Gt.bind(void 0, e),
  focus: K.bind(void 0, e),
  insert: T.bind(void 0, e),
  load: Zt.bind(void 0, e),
  reconfigure: Yt.bind(void 0, e),
  select: Me.bind(void 0, e),
  selections: P.bind(void 0, e),
  update: en.bind(void 0, e),
  wrap: U.bind(void 0, e)
});
var Yt = ([e, n], t) => {
  const o = be(n(V(e(), { options: t })));
  e().editor.dispatch({
    effects: o
  });
};
var Me = ([e, n], t) => {
  const { editor: o } = e();
  o.dispatch(o.state.update({
    selection: ye(t)
  }));
};
var P = ([e, n]) => {
  const { editor: t } = e();
  return wt(t.state.selection);
};
var en = ([e, n], t) => {
  const { editor: o } = e();
  o.dispatch(o.state.update({
    changes: {
      from: 0,
      to: o.state.doc.length,
      insert: t
    }
  }));
};
var U = ([e, n], { after: t, before: o, selection: r }) => {
  const { editor: a } = e(), l = r || P([e, n]).pop() || { start: 0, end: 0 }, i = a.state.sliceDoc(l.start, l.end);
  T([e, n], `${o}${i}${t}`, l), Me([e, n], [{ start: l.start + o.length, end: l.end + o.length }]);
};
var tn = `.ink-drop-zone{align-items:center;background-color:#00000080;color:var(--ink-internal-color);display:flex;inset:0;justify-content:center;position:var(--ink-internal-modal-position);z-index:100}.ink-drop-zone:not(.visible){display:none}.ink-drop-zone-modal{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);box-sizing:border-box;height:100%;max-height:20rem;max-width:40rem;padding:1rem;position:relative;width:100%}.ink-drop-zone-hide{cursor:pointer;height:1.75rem;position:absolute;right:.25rem;top:.25rem;width:1.75rem}.ink-drop-zone-hide svg{background-color:var(--ink-internal-block-background-color)}.ink-drop-zone-droppable-area{align-items:center;border:.2rem dashed var(--ink-internal-color);border-radius:.125rem;box-sizing:border-box;display:flex;flex-direction:column;font-size:1.25em;gap:1rem;height:100%;justify-content:center;padding:1rem;text-align:center}.ink-drop-zone-file-preview{align-items:center;display:flex;flex-wrap:wrap;gap:.5rem;max-width:25.5rem}.ink-drop-zone-file-preview-image{border:.125rem solid #222;border-radius:.125rem;box-sizing:border-box;height:6rem;object-fit:cover;padding:.5rem;width:6rem}
`;
var nn = h("<style></style>");
var on2 = h("<span>uploading files...</span>");
var rn = h('<div class="ink-drop-zone"><div class="ink-drop-zone-modal"><div class="ink-drop-zone-droppable-area"><div class="ink-drop-zone-file-preview"></div></div><div class="ink-drop-zone-hide"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div>');
var an = h('<img class="ink-drop-zone-file-preview-image">');
var ln = h("<span>drop files here</span>");
var sn = () => {
  const [e, n] = createSignal(0), [t, o] = createSignal([]), [r, a] = createSignal(false), [l, i] = createSignal(false), [s, c] = O(), u2 = () => {
    i(false);
  }, k2 = (g) => {
    if (s().options.files.dragAndDrop) {
      g.preventDefault(), g.stopPropagation();
      const v = g.dataTransfer;
      (v == null ? void 0 : v.files) ? oe(v.files) : (n(0), i(false), o([]));
    }
  }, L = (g) => {
    s().options.files.dragAndDrop && (g.preventDefault(), n(e() + 1), i(true));
  }, H = (g) => {
    s().options.files.dragAndDrop && (g.preventDefault(), n(e() - 1), e() === 0 && i(false));
  }, I = (g) => {
    s().options.files.dragAndDrop && (g.preventDefault(), i(true));
  }, te = (g) => {
    s().options.files.dragAndDrop && (g.preventDefault(), n(0), i(false));
  }, ne = (g) => {
    if (s().options.files.clipboard) {
      g.preventDefault();
      const v = g.clipboardData;
      (v == null ? void 0 : v.files) && v.files.length > 0 && oe(v.files);
    }
  }, oe = (g) => {
    Array.from(g).forEach((v) => {
      o([...t(), v]);
    }), a(true), i(true), Promise.resolve(s().options.files.handler(g)).then((v) => {
      if (s().options.files.injectMarkup && v) {
        const A = `![](${v})`;
        T([s, c], A);
      }
    }).finally(() => {
      n(0), a(false), i(false), o([]);
    });
  };
  return onMount(() => {
    document.addEventListener("dragenter", L), document.addEventListener("dragleave", H), document.addEventListener("dragover", I), document.addEventListener("drop", te), s().root.addEventListener("paste", ne);
  }), onCleanup(() => {
    document.removeEventListener("dragenter", L), document.removeEventListener("dragleave", H), document.removeEventListener("dragover", I), document.removeEventListener("drop", te), s().root.removeEventListener("paste", ne);
  }), [(() => {
    const g = nn.cloneNode(true);
    return p(g, tn), g;
  })(), (() => {
    const g = rn.cloneNode(true), v = g.firstChild, A = v.firstChild, _e = A.firstChild, Ae = A.nextSibling;
    return A.addEventListener("drop", k2), p(_e, createComponent(For, {
      get each() {
        return t().slice(0, 8);
      },
      children: (re) => (() => {
        const q = an.cloneNode(true);
        return createRenderEffect((j) => {
          const ie = re.name, ae = URL.createObjectURL(re);
          return ie !== j._v$ && se(q, "alt", j._v$ = ie), ae !== j._v$2 && se(q, "src", j._v$2 = ae), j;
        }, {
          _v$: void 0,
          _v$2: void 0
        }), q;
      })()
    })), p(A, createComponent(Show, {
      get when() {
        return r();
      },
      get fallback() {
        return ln.cloneNode(true);
      },
      get children() {
        return on2.cloneNode(true);
      }
    }), null), Ae.$$click = u2, createRenderEffect(() => g.classList.toggle("visible", !!l())), g;
  })()];
};
ke(["click"]);
var cn = (e) => {
  const n = new EditorView({
    dispatch: (t) => {
      const { options: o } = e;
      o.hooks.beforeUpdate(t.newDoc.toString()), n.update([t]), t.docChanged && o.hooks.afterUpdate(t.newDoc.toString());
    },
    state: $e(e)
  });
  return n;
};
var dn = () => {
  const [e, n] = O(), t = cn(e());
  return n(V(e(), {
    editor: t
  })), t.dom;
};
var fn = h('<button class="ink-button"></button>');
var y = (e) => (() => {
  const n = fn.cloneNode(true);
  return n.$$click = (t) => e.onclick(t), p(n, () => e.children), n;
})();
ke(["click"]);
var un = `.ink .ink-toolbar{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);bottom:.25rem;color:inherit;display:flex;gap:2rem;overflow:auto;padding:.25rem;position:sticky;top:.25rem;z-index:10}.ink .ink-toolbar-group{display:flex}.ink .ink-toolbar .ink-button{align-items:center;background:none;border:none;border-radius:var(--ink-internal-border-radius);color:inherit;cursor:pointer;display:flex;height:2.25rem;justify-content:center;padding:.4rem;width:2.25rem}.ink .ink-toolbar .ink-button:hover{background-color:var(--ink-internal-block-background-color-on-hover)}.ink .ink-toolbar .ink-button>*{align-items:center;display:flex;height:100%}
`;
var gn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4V10M6 16V10M6 10H14M14 10V4M14 10V16"></path></svg>');
var pn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M6.5 10H10.5C12.1569 10 13.5 11.3431 13.5 13C13.5 14.6569 12.1569 16 10.5 16H6.5V4H9.5C11.1569 4 12.5 5.34315 12.5 7C12.5 8.65686 11.1569 10 9.5 10"></path></svg>');
var mn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4L9 16M13 4H9M7 16H11"></path></svg>');
var hn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M2.00257 16H17.9955M2.00055 4H18M7 10H18.0659M2 8.5V11.4999C2.4 11.5 2.5 11.5 2.5 11.5V11V10.5M4 8.5V11.4999H4.5V11V10.5"></path></svg>');
var kn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 4L7 16"></path><path d="M5 7L2 10L5 13"></path><path d="M15 7L18 10L15 13"></path></svg>');
var xn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L8 6"></path></svg>');
var bn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16H17.8294"></path><path d="M2 16H4"></path><path d="M7 10H17.8294"></path><path d="M2 10H4"></path><path d="M7 4H17.8294"></path><path d="M2 4H4"></path></svg>');
var vn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16H18"></path><path d="M2 17.0242C2.48314 17.7569 3.94052 17.6154 3.99486 16.7919C4.05315 15.9169 3.1975 16.0044 2.99496 16.0044M2.0023 14.9758C2.48544 14.2431 3.94282 14.3846 3.99716 15.2081C4.05545 16.0831 3.1998 16.0002 2.99726 16.0002"></path><path d="M7 10H18"></path><path d="M2.00501 11.5H4M2.00193 8.97562C2.48449 8.24319 3.9401 8.38467 3.99437 9.20777C4.05259 10.0825 2.04342 10.5788 2 11.4996"></path><path d="M7 4H18"></path><path d="M2 5.5H4M2.99713 5.49952V2.5L2.215 2.93501"></path></svg>');
var yn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16H17.8294"></path><path d="M5 15L3 17L2 16"></path><path d="M7 10H17.8294"></path><path d="M5 9L3 11L2 10"></path><path d="M7 4H17.8294"></path><path d="M5 3L3 5L2 4"></path></svg>');
var wn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M9.12127 10.881C10.02 11.78 11.5237 11.7349 12.4771 10.7813L15.2546 8.00302C16.2079 7.04937 16.253 5.54521 15.3542 4.6462C14.4555 3.74719 12.9512 3.79174 11.9979 4.74539L10.3437 6.40007M10.8787 9.11903C9.97997 8.22002 8.47626 8.26509 7.52288 9.21874L4.74545 11.997C3.79208 12.9506 3.74701 14.4548 4.64577 15.3538C5.54452 16.2528 7.04876 16.2083 8.00213 15.2546L9.65633 13.5999"></path></svg>');
var Cn = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="4" width="16" height="12" rx="1"></rect><path d="M7.42659 7.67597L13.7751 13.8831M2.00208 12.9778L7.42844 7.67175"></path><path d="M11.9119 12.0599L14.484 9.54443L17.9973 12.9785"></path><path d="M10.9989 7.95832C11.551 7.95832 11.9986 7.52072 11.9986 6.98092C11.9986 6.44113 11.551 6.00354 10.9989 6.00354C10.4468 6.00354 9.99921 6.44113 9.99921 6.98092C9.99921 7.52072 10.4468 7.95832 10.9989 7.95832Z"></path></svg>');
var Ln = h('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13V4M10 4L13 7M10 4L7 7"></path><path d="M2 13V15C2 15.5523 2.44772 16 3 16H17C17.5523 16 18 15.5523 18 15V13"></path></svg>');
var $n = h('<div class="ink-toolbar"><style></style><div class="ink-toolbar-group"></div><div class="ink-toolbar-group"></div><div class="ink-toolbar-group"></div><div class="ink-toolbar-group"></div></div>');
var Mn = () => {
  const [e, n] = O(), t = (a) => {
    Kt([e, n], a), K([e, n]);
  }, o = document.createElement("input"), r = () => {
    o.click();
  };
  return o.style.display = "none", o.type = "file", o.onchange = (a) => {
    const l = a.target;
    (l == null ? void 0 : l.files) && Promise.resolve(e().options.files.handler(l.files)).then((i) => {
      const s = `![](${i})`;
      T([e, n], s), K([e, n]);
    });
  }, (() => {
    const a = $n.cloneNode(true), l = a.firstChild, i = l.nextSibling, s = i.nextSibling, c = s.nextSibling, u2 = c.nextSibling;
    return p(l, un), p(i, createComponent(Show, {
      get when() {
        return e().options.toolbar.heading;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.Heading),
          get children() {
            return gn.cloneNode(true);
          }
        });
      }
    }), null), p(i, createComponent(Show, {
      get when() {
        return e().options.toolbar.bold;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.Bold),
          get children() {
            return pn.cloneNode(true);
          }
        });
      }
    }), null), p(i, createComponent(Show, {
      get when() {
        return e().options.toolbar.italic;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.Italic),
          get children() {
            return mn.cloneNode(true);
          }
        });
      }
    }), null), p(s, createComponent(Show, {
      get when() {
        return e().options.toolbar.quote;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.Quote),
          get children() {
            return hn.cloneNode(true);
          }
        });
      }
    }), null), p(s, createComponent(Show, {
      get when() {
        return e().options.toolbar.codeBlock;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.CodeBlock),
          get children() {
            return kn.cloneNode(true);
          }
        });
      }
    }), null), p(s, createComponent(Show, {
      get when() {
        return e().options.toolbar.code;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.Code),
          get children() {
            return xn.cloneNode(true);
          }
        });
      }
    }), null), p(c, createComponent(Show, {
      get when() {
        return e().options.toolbar.list;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.List),
          get children() {
            return bn.cloneNode(true);
          }
        });
      }
    }), null), p(c, createComponent(Show, {
      get when() {
        return e().options.toolbar.orderedList;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.OrderedList),
          get children() {
            return vn.cloneNode(true);
          }
        });
      }
    }), null), p(c, createComponent(Show, {
      get when() {
        return e().options.toolbar.taskList;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.TaskList),
          get children() {
            return yn.cloneNode(true);
          }
        });
      }
    }), null), p(u2, createComponent(Show, {
      get when() {
        return e().options.toolbar.link;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.Link),
          get children() {
            return wn.cloneNode(true);
          }
        });
      }
    }), null), p(u2, createComponent(Show, {
      get when() {
        return e().options.toolbar.image;
      },
      get children() {
        return createComponent(y, {
          onclick: () => t(m.Image),
          get children() {
            return Cn.cloneNode(true);
          }
        });
      }
    }), null), p(u2, createComponent(Show, {
      get when() {
        return e().options.toolbar.upload;
      },
      get children() {
        return createComponent(y, {
          onclick: r,
          get children() {
            return [Ln.cloneNode(true), o];
          }
        });
      }
    }), null), a;
  })();
};
var Sn = `.ink{color:var(--ink-internal-color, inherit);display:flex;flex-direction:var(--ink-internal-flex-direction, column);gap:1rem;padding:var(--ink-internal-editor-padding, 0)}.ink .cm-tooltip{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);font-family:inherit;padding:.25rem}.ink .cm-tooltip.cm-tooltip-autocomplete ul{font-family:inherit}.ink .cm-tooltip.cm-tooltip-autocomplete ul li.ink-tooltip-option{border-radius:var(--ink-internal-border-radius);padding:.25rem}.ink .cm-tooltip.cm-tooltip-autocomplete ul li.ink-tooltip-option[aria-selected]{background-color:#96969640}.ink .cm-completionLabel{font-family:inherit}
`;
var _n = h("<style></style>");
var An = () => {
  const [e] = O(), [n, t] = createSignal(X(e()));
  return createEffect(() => {
    t(X(e()));
  }), onMount(() => {
    const o = window.matchMedia("(prefers-color-scheme: dark)"), r = (a) => {
      const {
        editor: l,
        root: i
      } = e();
      if (i.isConnected) {
        const s = be(e());
        l.dispatch({
          effects: s
        }), t(X(e()));
      } else
        o.removeEventListener("change", r);
    };
    o.addEventListener("change", r);
  }), (() => {
    const o = _n.cloneNode(true);
    return p(o, () => `.ink {
  ${n().join(`
  `)}
}`, null), p(o, Sn, null), o;
  })();
};
var Bn = h('<div class="ink"></div>');
var Nn = () => {
  const [e, n] = O(), t = (o) => {
    n(V(e(), {
      root: o
    }));
  };
  return (() => {
    const o = Bn.cloneNode(true);
    return t(o), p(o, createComponent(An, {}), null), p(o, createComponent(sn, {}), null), p(o, createComponent(Show, {
      get when() {
        return e().options.interface.toolbar;
      },
      get children() {
        return createComponent(Mn, {});
      }
    }), null), p(o, createComponent(dn, {}), null), o;
  })();
};
var pe = ve();
var Se = createContext([() => pe, (e) => typeof e == "function" ? e(pe) : e]);
var Dn = (e) => createComponent(Se.Provider, {
  get value() {
    return e.store;
  },
  get children() {
    return e.children;
  }
});
var O = () => useContext(Se);
var En = (e) => createComponent(Dn, {
  get store() {
    return e.store;
  },
  get children() {
    return createComponent(Nn, {
      get store() {
        return e.store;
      }
    });
  }
});
var qn = (e, n = {}) => {
  const t = yt(n);
  return ot(() => createComponent(En, {
    store: t
  }), e), Jt(t);
};

// node_modules/ink-mde/dist/vue/ink.js
var p2 = defineComponent({
  name: "Ink",
  emits: ["input", "update:modelValue"],
  props: {
    options: {
      type: Object
    },
    modelValue: {
      type: String
    },
    value: {
      type: String
    },
    version: {
      type: Number,
      default: () => 3,
      validator: (t) => [2, 3].includes(t)
    }
  },
  data() {
    return { instance: void 0 };
  },
  watch: {
    options: {
      deep: true,
      handler(t, e) {
        var s;
        (s = this.instance) == null || s.reconfigure(t);
      }
    },
    modelValue(t) {
      var e, s;
      ((e = this.instance) == null ? void 0 : e.doc()) !== t && ((s = this.instance) == null || s.update(t));
    },
    value(t) {
      var e, s;
      ((e = this.instance) == null ? void 0 : e.doc()) !== t && ((s = this.instance) == null || s.update(t));
    }
  },
  computed: {
    doc() {
      return (this.version === 3 ? this.modelValue : this.value) || "";
    }
  },
  methods: {
    focus() {
      var t;
      (t = this.instance) == null || t.focus();
    },
    select(t) {
      var e;
      (e = this.instance) == null || e.select(t);
    },
    selections() {
      var t;
      return (t = this.instance) == null ? void 0 : t.selections();
    }
  },
  mounted() {
    var t;
    this.instance = qn(this.$refs.ink, {
      ...this.options,
      doc: this.doc,
      hooks: {
        ...(t = this.options) == null ? void 0 : t.hooks,
        afterUpdate: (e) => {
          var s, i;
          this.version === 3 ? this.$emit("update:modelValue", e) : this.$emit("input", e), (i = (s = this.options) == null ? void 0 : s.hooks) != null && i.afterUpdate && this.options.hooks.afterUpdate(e);
        }
      }
    }), this.$refs.ink.addEventListener("input", (e) => {
      e.stopPropagation();
    }), this.instance.focus();
  }
});
var d = (t, e) => {
  const s = t.__vccOpts || t;
  for (const [i, n] of e)
    s[i] = n;
  return s;
};
var u = { ref: "ink" };
function h2(t, e, s, i, n, l) {
  return openBlock(), createElementBlock("div", u, null, 512);
}
var k = d(p2, [["render", h2]]);

// dep:ink-mde_vue
var ink_mde_vue_default = k;
export {
  ink_mde_vue_default as default
};
//# sourceMappingURL=ink-mde_vue.js.map
