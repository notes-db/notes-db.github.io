{
  "version": 3,
  "sources": ["../../solid-js/dist/dev.js", "../../crelt/index.es.js", "../../@codemirror/search/dist/index.js", "../../@codemirror/commands/dist/index.js", "../../@replit/codemirror-vim/dist/index.js", "../../@codemirror/language-data/dist/index.js", "../../ink-mde/dist/ink.js", "../../ink-mde/dist/vue/ink.js", "dep:ink-mde_vue"],
  "sourcesContent": ["let taskIdCounter = 1,\n    isCallbackScheduled = false,\n    isPerformingWork = false,\n    taskQueue = [],\n    currentTask = null,\n    shouldYieldToHost = null,\n    yieldInterval = 5,\n    deadline = 0,\n    maxYieldInterval = 300,\n    scheduleCallback = null,\n    scheduledCallback = null;\nconst maxSigned31BitInt = 1073741823;\nfunction setupScheduler() {\n  const channel = new MessageChannel(),\n        port = channel.port2;\n  scheduleCallback = () => port.postMessage(null);\n  channel.port1.onmessage = () => {\n    if (scheduledCallback !== null) {\n      const currentTime = performance.now();\n      deadline = currentTime + yieldInterval;\n      const hasTimeRemaining = true;\n      try {\n        const hasMoreWork = scheduledCallback(hasTimeRemaining, currentTime);\n        if (!hasMoreWork) {\n          scheduledCallback = null;\n        } else port.postMessage(null);\n      } catch (error) {\n        port.postMessage(null);\n        throw error;\n      }\n    }\n  };\n  if (navigator && navigator.scheduling && navigator.scheduling.isInputPending) {\n    const scheduling = navigator.scheduling;\n    shouldYieldToHost = () => {\n      const currentTime = performance.now();\n      if (currentTime >= deadline) {\n        if (scheduling.isInputPending()) {\n          return true;\n        }\n        return currentTime >= maxYieldInterval;\n      } else {\n        return false;\n      }\n    };\n  } else {\n    shouldYieldToHost = () => performance.now() >= deadline;\n  }\n}\nfunction enqueue(taskQueue, task) {\n  function findIndex() {\n    let m = 0;\n    let n = taskQueue.length - 1;\n    while (m <= n) {\n      const k = n + m >> 1;\n      const cmp = task.expirationTime - taskQueue[k].expirationTime;\n      if (cmp > 0) m = k + 1;else if (cmp < 0) n = k - 1;else return k;\n    }\n    return m;\n  }\n  taskQueue.splice(findIndex(), 0, task);\n}\nfunction requestCallback(fn, options) {\n  if (!scheduleCallback) setupScheduler();\n  let startTime = performance.now(),\n      timeout = maxSigned31BitInt;\n  if (options && options.timeout) timeout = options.timeout;\n  const newTask = {\n    id: taskIdCounter++,\n    fn,\n    startTime,\n    expirationTime: startTime + timeout\n  };\n  enqueue(taskQueue, newTask);\n  if (!isCallbackScheduled && !isPerformingWork) {\n    isCallbackScheduled = true;\n    scheduledCallback = flushWork;\n    scheduleCallback();\n  }\n  return newTask;\n}\nfunction cancelCallback(task) {\n  task.fn = null;\n}\nfunction flushWork(hasTimeRemaining, initialTime) {\n  isCallbackScheduled = false;\n  isPerformingWork = true;\n  try {\n    return workLoop(hasTimeRemaining, initialTime);\n  } finally {\n    currentTask = null;\n    isPerformingWork = false;\n  }\n}\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  currentTask = taskQueue[0] || null;\n  while (currentTask !== null) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      break;\n    }\n    const callback = currentTask.fn;\n    if (callback !== null) {\n      currentTask.fn = null;\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      callback(didUserCallbackTimeout);\n      currentTime = performance.now();\n      if (currentTask === taskQueue[0]) {\n        taskQueue.shift();\n      }\n    } else taskQueue.shift();\n    currentTask = taskQueue[0] || null;\n  }\n  return currentTask !== null;\n}\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nfunction nextHydrateContext() {\n  return { ...sharedConfig.context,\n    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,\n    count: 0\n  };\n}\n\nconst equalFn = (a, b) => a === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst $DEVCOMP = Symbol(\"solid-dev-component\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet ERROR = null;\nlet runEffects = runQueue;\nconst NOTPENDING = {};\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst [transPending, setTransPending] = /*@__PURE__*/createSignal(false);\nvar Owner = null;\nlet Transition = null;\nlet Scheduler = null;\nlet ExternalSourceFactory = null;\nlet Listener = null;\nlet Pending = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nlet rootCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener,\n        owner = Owner,\n        unowned = fn.length === 0,\n        root = unowned && !\"_SOLID_DEV_\" ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner || owner\n  },\n        updateFn = unowned ? () => fn(() => {\n    throw new Error(\"Dispose method must be an explicit argument to createRoot function\");\n  })  : () => fn(() => cleanNode(root));\n  {\n    if (owner) root.name = `${owner.name}-r${rootCount++}`;\n    globalThis._$afterCreateRoot && globalThis._$afterCreateRoot(root);\n  }\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s = {\n    value,\n    observers: null,\n    observerSlots: null,\n    pending: NOTPENDING,\n    comparator: options.equals || undefined\n  };\n  if (!options.internal) s.name = registerGraph(options.name || hashValue(value), s);\n  const setter = value => {\n    if (typeof value === \"function\") {\n      if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.pending !== NOTPENDING ? s.pending : s.tValue);else value = value(s.pending !== NOTPENDING ? s.pending : s.value);\n    }\n    return writeSignal(s, value);\n  };\n  return [readSignal.bind(s), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c = createComputation(fn, value, true, STALE, options );\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c = createComputation(fn, value, false, STALE, options );\n  if (Scheduler && Transition && Transition.running) Updates.push(c);else updateComputation(c);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c = createComputation(fn, value, false, STALE, options ),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  Effects ? Effects.push(c) : updateComputation(c);\n}\nfunction createReaction(onInvalidate, options) {\n  let fn;\n  const c = createComputation(() => {\n    fn ? fn() : untrack(onInvalidate);\n    fn = undefined;\n  }, undefined, false, 0, options ),\n        s = SuspenseContext && lookup(Owner, SuspenseContext.id);\n  if (s) c.suspense = s;\n  c.user = true;\n  return tracking => {\n    fn = tracking;\n    updateComputation(c);\n  };\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c = createComputation(fn, value, true, 0, options );\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.comparator = options.equals || undefined;\n  if (Scheduler && Transition && Transition.running) {\n    c.tState = STALE;\n    Updates.push(c);\n  } else updateComputation(c);\n  return readSignal.bind(c);\n}\nfunction createResource(source, fetcher, options) {\n  if (arguments.length === 2) {\n    if (typeof fetcher === \"object\") {\n      options = fetcher;\n      fetcher = source;\n      source = true;\n    }\n  } else if (arguments.length === 1) {\n    fetcher = source;\n    source = true;\n  }\n  options || (options = {});\n  const contexts = new Set(),\n        [value, setValue] = createSignal(options.initialValue),\n        [track, trigger] = createSignal(undefined, {\n    equals: false\n  }),\n        [loading, setLoading] = createSignal(false),\n        [error, setError] = createSignal();\n  let err = undefined,\n      pr = null,\n      initP = null,\n      id = null,\n      loadedUnderTransition = false,\n      scheduled = false,\n      resolved = (\"initialValue\" in options),\n      dynamic = typeof source === \"function\" && createMemo(source);\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    if (sharedConfig.load) initP = sharedConfig.load(id);\n  }\n  function loadEnd(p, v, e, key) {\n    if (pr === p) {\n      pr = null;\n      resolved = true;\n      if (initP && (p === initP || v === initP) && options.onHydrated) queueMicrotask(() => options.onHydrated(key, {\n        value: v\n      }));\n      initP = null;\n      setError(err = e);\n      if (Transition && p && loadedUnderTransition) {\n        Transition.promises.delete(p);\n        loadedUnderTransition = false;\n        runUpdates(() => {\n          Transition.running = true;\n          if (!Transition.promises.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n          completeLoad(v);\n        }, false);\n      } else completeLoad(v);\n    }\n    return v;\n  }\n  function completeLoad(v) {\n    batch(() => {\n      setValue(() => v);\n      setLoading(false);\n      for (const c of contexts.keys()) c.decrement();\n      contexts.clear();\n    });\n  }\n  function read() {\n    const c = SuspenseContext && lookup(Owner, SuspenseContext.id),\n          v = value();\n    if (err) throw err;\n    if (Listener && !Listener.user && c) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c.resolved && Transition) Transition.promises.add(pr);else if (!contexts.has(c)) {\n            c.increment();\n            contexts.add(c);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching && scheduled) return;\n    scheduled = false;\n    setError(err = undefined);\n    const lookup = dynamic ? dynamic() : source;\n    loadedUnderTransition = Transition && Transition.running;\n    if (lookup == null || lookup === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    if (Transition && pr) Transition.promises.delete(pr);\n    const p = initP || untrack(() => fetcher(lookup, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p !== \"object\" || !(\"then\" in p)) {\n      loadEnd(pr, p);\n      return p;\n    }\n    pr = p;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    batch(() => {\n      setLoading(true);\n      trigger();\n    });\n    return p.then(v => loadEnd(p, v, undefined, lookup), e => loadEnd(p, e, e));\n  }\n  Object.defineProperties(read, {\n    loading: {\n      get() {\n        return loading();\n      }\n    },\n    error: {\n      get() {\n        return error();\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved) return read();\n        if (err) throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic) createComputed(() => load(false));else load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction createDeferred(source, options) {\n  let t,\n      timeout = options ? options.timeoutMs : undefined;\n  const node = createComputation(() => {\n    if (!t || !t.fn) t = requestCallback(() => setDeferred(() => node.value), timeout !== undefined ? {\n      timeout\n    } : undefined);\n    return source();\n  }, undefined, true);\n  const [deferred, setDeferred] = createSignal(node.value, options);\n  updateComputation(node);\n  setDeferred(() => node.value);\n  return deferred;\n}\nfunction createSelector(source, fn = equalFn, options) {\n  const subs = new Map();\n  const node = createComputation(p => {\n    const v = source();\n    for (const key of subs.keys()) if (fn(key, v) !== fn(key, p)) {\n      const l = subs.get(key);\n      for (const c of l.values()) {\n        c.state = STALE;\n        if (c.pure) Updates.push(c);else Effects.push(c);\n      }\n    }\n    return v;\n  }, undefined, true, STALE, options );\n  updateComputation(node);\n  return key => {\n    let listener;\n    if (listener = Listener) {\n      let l;\n      if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));\n      onCleanup(() => {\n        l.delete(listener);\n        !l.size && subs.delete(key);\n      });\n    }\n    return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);\n  };\n}\nfunction batch(fn) {\n  if (Pending) return fn();\n  let result;\n  const q = Pending = [];\n  try {\n    result = fn();\n  } finally {\n    Pending = null;\n  }\n  runUpdates(() => {\n    for (let i = 0; i < q.length; i += 1) {\n      const data = q[i];\n      if (data.pending !== NOTPENDING) {\n        const pending = data.pending;\n        data.pending = NOTPENDING;\n        writeSignal(data, pending);\n      }\n    }\n  }, false);\n  return result;\n}\nfunction untrack(fn) {\n  let result,\n      listener = Listener;\n  Listener = null;\n  result = fn();\n  Listener = listener;\n  return result;\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return prevValue => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();\n    } else input = deps();\n    if (defer) {\n      defer = false;\n      return undefined;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null) console.warn(\"cleanups created outside a `createRoot` or `render` will never be run\");else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  return fn;\n}\nfunction onError(fn) {\n  ERROR || (ERROR = Symbol(\"error\"));\n  if (Owner === null) console.warn(\"error handlers created outside a `createRoot` or `render` will never be run\");else if (Owner.context === null) Owner.context = {\n    [ERROR]: [fn]\n  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction runWithOwner(o, fn) {\n  const prev = Owner;\n  Owner = o;\n  try {\n    return runUpdates(fn, true);\n  } finally {\n    Owner = prev;\n  }\n}\nfunction enableScheduling(scheduler = requestCallback) {\n  Scheduler = scheduler;\n}\nfunction startTransition(fn) {\n  if (Transition && Transition.running) {\n    fn();\n    return Transition.done;\n  }\n  const l = Listener;\n  const o = Owner;\n  return Promise.resolve().then(() => {\n    Listener = l;\n    Owner = o;\n    let t;\n    if (Scheduler || SuspenseContext) {\n      t = Transition || (Transition = {\n        sources: new Set(),\n        effects: [],\n        promises: new Set(),\n        disposed: new Set(),\n        queue: new Set(),\n        running: true\n      });\n      t.done || (t.done = new Promise(res => t.resolve = res));\n      t.running = true;\n    }\n    batch(fn);\n    Listener = Owner = null;\n    return t ? t.done : undefined;\n  });\n}\nfunction useTransition() {\n  return [transPending, startTransition];\n}\nfunction resumeEffects(e) {\n  Effects.push.apply(Effects, e);\n  e.length = 0;\n}\nfunction devComponent(Comp, props) {\n  const c = createComputation(() => untrack(() => {\n    Object.assign(Comp, {\n      [$DEVCOMP]: true\n    });\n    return Comp(props);\n  }), undefined, true);\n  c.pending = NOTPENDING;\n  c.observers = null;\n  c.observerSlots = null;\n  c.state = 0;\n  c.componentName = Comp.name;\n  updateComputation(c);\n  return c.tValue !== undefined ? c.tValue : c.value;\n}\nfunction hashValue(v) {\n  const s = new Set();\n  return `s${typeof v === \"string\" ? hash(v) : hash(JSON.stringify(v, (k, v) => {\n    if (typeof v === \"object\" && v != null) {\n      if (s.has(v)) return;\n      s.add(v);\n      const keys = Object.keys(v);\n      const desc = Object.getOwnPropertyDescriptors(v);\n      const newDesc = keys.reduce((memo, key) => {\n        const value = desc[key];\n        if (!value.get) memo[key] = value;\n        return memo;\n      }, {});\n      v = Object.create({}, newDesc);\n    }\n    if (typeof v === \"bigint\") {\n      return `${v.toString()}n`;\n    }\n    return v;\n  }) || \"\")}`;\n}\nfunction registerGraph(name, value) {\n  let tryName = name;\n  if (Owner) {\n    let i = 0;\n    Owner.sourceMap || (Owner.sourceMap = {});\n    while (Owner.sourceMap[tryName]) tryName = `${name}-${++i}`;\n    Owner.sourceMap[tryName] = value;\n  }\n  return tryName;\n}\nfunction serializeGraph(owner) {\n  owner || (owner = Owner);\n  if (!owner) return {};\n  return { ...serializeValues(owner.sourceMap),\n    ...(owner.owned ? serializeChildren(owner) : {})\n  };\n}\nfunction createContext(defaultValue) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== undefined ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children = createMemo(fn);\n  return createMemo(() => resolveChildren(children()));\n}\nlet SuspenseContext;\nfunction getSuspenseContext() {\n  return SuspenseContext || (SuspenseContext = createContext({}));\n}\nfunction enableExternalSource(factory) {\n  if (ExternalSourceFactory) {\n    const oldFactory = ExternalSourceFactory;\n    ExternalSourceFactory = (fn, trigger) => {\n      const oldSource = oldFactory(fn, trigger);\n      const source = factory(x => oldSource.track(x), trigger);\n      return {\n        track: x => source.track(x),\n        dispose() {\n          source.dispose();\n          oldSource.dispose();\n        }\n      };\n    };\n  } else {\n    ExternalSourceFactory = factory;\n  }\n}\nfunction readSignal() {\n  const runningTransition = Transition && Transition.running;\n  if (this.sources && (!runningTransition && this.state || runningTransition && this.tState)) {\n    const updates = Updates;\n    Updates = null;\n    !runningTransition && this.state === STALE || runningTransition && this.tState === STALE ? updateComputation(this) : lookUpstream(this);\n    Updates = updates;\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  if (runningTransition && Transition.sources.has(this)) return this.tValue;\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  if (Pending) {\n    if (node.pending === NOTPENDING) Pending.push(node);\n    node.pending = value;\n    return value;\n  }\n  if (node.comparator) {\n    if (Transition && Transition.running && Transition.sources.has(node)) {\n      if (node.comparator(node.tValue, value)) return value;\n    } else if (node.comparator(node.value, value)) return value;\n  }\n  let TransitionRunning = false;\n  if (Transition) {\n    TransitionRunning = Transition.running;\n    if (TransitionRunning || !isComp && Transition.sources.has(node)) {\n      Transition.sources.add(node);\n      node.tValue = value;\n    }\n    if (!TransitionRunning) node.value = value;\n  } else node.value = value;\n  if (node.observers && node.observers.length) {\n    runUpdates(() => {\n      for (let i = 0; i < node.observers.length; i += 1) {\n        const o = node.observers[i];\n        if (TransitionRunning && Transition.disposed.has(o)) continue;\n        if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {\n          if (o.pure) Updates.push(o);else Effects.push(o);\n          if (o.observers) markDownstream(o);\n        }\n        if (TransitionRunning) o.tState = STALE;else o.state = STALE;\n      }\n      if (Updates.length > 10e5) {\n        Updates = [];\n        if (\"_SOLID_DEV_\") throw new Error(\"Potential Infinite Loop Detected.\");\n        throw new Error();\n      }\n    }, false);\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn) return;\n  cleanNode(node);\n  const owner = Owner,\n        listener = Listener,\n        time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);\n  if (Transition && !Transition.running && Transition.sources.has(node)) {\n    queueMicrotask(() => {\n      runUpdates(() => {\n        Transition && (Transition.running = true);\n        runComputation(node, node.tValue, time);\n      }, false);\n    });\n  }\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.observers && node.observers.length) {\n      writeSignal(node, nextValue, true);\n    } else if (Transition && Transition.running && node.pure) {\n      Transition.sources.add(node);\n      node.tValue = nextValue;\n    } else node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c = {\n    fn,\n    state: state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Transition && Transition.running) {\n    c.state = 0;\n    c.tState = state;\n  }\n  if (Owner === null) console.warn(\"computations created outside a `createRoot` or `render` will never be disposed\");else if (Owner !== UNOWNED) {\n    if (Transition && Transition.running && Owner.pure) {\n      if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);\n    } else {\n      if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);\n    }\n    c.name = options && options.name || `${Owner.name || \"c\"}-${(Owner.owned || Owner.tOwned).length}`;\n  }\n  if (ExternalSourceFactory) {\n    const [track, trigger] = createSignal(undefined, {\n      equals: false\n    });\n    const ordinary = ExternalSourceFactory(c.fn, trigger);\n    onCleanup(() => ordinary.dispose());\n    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());\n    const inTransition = ExternalSourceFactory(c.fn, triggerInTransition);\n    c.fn = x => {\n      track();\n      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);\n    };\n  }\n  return c;\n}\nfunction runTop(node) {\n  const runningTransition = Transition && Transition.running;\n  if (!runningTransition && node.state === 0 || runningTransition && node.tState === 0) return;\n  if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (runningTransition && Transition.disposed.has(node)) return;\n    if (!runningTransition && node.state || runningTransition && node.tState) ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    node = ancestors[i];\n    if (runningTransition) {\n      let top = node,\n          prev = ancestors[i + 1];\n      while ((top = top.owner) && top !== prev) {\n        if (Transition.disposed.has(top)) return;\n      }\n    }\n    if (!runningTransition && node.state === STALE || runningTransition && node.tState === STALE) {\n      updateComputation(node);\n    } else if (!runningTransition && node.state === PENDING || runningTransition && node.tState === PENDING) {\n      const updates = Updates;\n      Updates = null;\n      lookUpstream(node, ancestors[0]);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates) return fn();\n  let wait = false;\n  if (!init) Updates = [];\n  if (Effects) wait = true;else Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!Updates) Effects = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);else runQueue(Updates);\n    Updates = null;\n  }\n  if (wait) return;\n  let res;\n  if (Transition && Transition.running) {\n    if (Transition.promises.size || Transition.queue.size) {\n      Transition.running = false;\n      Transition.effects.push.apply(Transition.effects, Effects);\n      Effects = null;\n      setTransPending(true);\n      return;\n    }\n    const sources = Transition.sources;\n    const disposed = Transition.disposed;\n    res = Transition.resolve;\n    for (const e of Effects) {\n      \"tState\" in e && (e.state = e.tState);\n      delete e.tState;\n    }\n    Transition = null;\n    batch(() => {\n      for (const d of disposed) cleanNode(d);\n      for (const v of sources) {\n        v.value = v.tValue;\n        if (v.owned) {\n          for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);\n        }\n        if (v.tOwned) v.owned = v.tOwned;\n        delete v.tValue;\n        delete v.tOwned;\n        v.tState = 0;\n      }\n      setTransPending(false);\n    });\n  }\n  if (Effects.length) batch(() => {\n    runEffects(Effects);\n    Effects = null;\n  });else {\n    Effects = null;\n    globalThis._$afterUpdate && globalThis._$afterUpdate();\n  }\n  if (res) res();\n}\nfunction runQueue(queue) {\n  for (let i = 0; i < queue.length; i++) runTop(queue[i]);\n}\nfunction scheduleQueue(queue) {\n  for (let i = 0; i < queue.length; i++) {\n    const item = queue[i];\n    const tasks = Transition.queue;\n    if (!tasks.has(item)) {\n      tasks.add(item);\n      Scheduler(() => {\n        tasks.delete(item);\n        runUpdates(() => {\n          Transition.running = true;\n          runTop(item);\n          if (!tasks.size) {\n            Effects.push.apply(Effects, Transition.effects);\n            Transition.effects = [];\n          }\n        }, false);\n        Transition && (Transition.running = false);\n      });\n    }\n  }\n}\nfunction runUserEffects(queue) {\n  let i,\n      userLength = 0;\n  for (i = 0; i < queue.length; i++) {\n    const e = queue[i];\n    if (!e.user) runTop(e);else queue[userLength++] = e;\n  }\n  if (sharedConfig.context) setHydrateContext();\n  const resume = queue.length;\n  for (i = 0; i < userLength; i++) runTop(queue[i]);\n  for (i = resume; i < queue.length; i++) runTop(queue[i]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition && Transition.running;\n  if (runningTransition) node.tState = 0;else node.state = 0;\n  for (let i = 0; i < node.sources.length; i += 1) {\n    const source = node.sources[i];\n    if (source.sources) {\n      if (!runningTransition && source.state === STALE || runningTransition && source.tState === STALE) {\n        if (source !== ignore) runTop(source);\n      } else if (!runningTransition && source.state === PENDING || runningTransition && source.tState === PENDING) lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition && Transition.running;\n  for (let i = 0; i < node.observers.length; i += 1) {\n    const o = node.observers[i];\n    if (!runningTransition && !o.state || runningTransition && !o.tState) {\n      if (runningTransition) o.tState = PENDING;else o.state = PENDING;\n      if (o.pure) Updates.push(o);else Effects.push(o);\n      o.observers && markDownstream(o);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(),\n            index = node.sourceSlots.pop(),\n            obs = source.observers;\n      if (obs && obs.length) {\n        const n = obs.pop(),\n              s = source.observerSlots.pop();\n        if (index < obs.length) {\n          n.sourceSlots[s] = index;\n          obs[index] = n;\n          source.observerSlots[index] = s;\n        }\n      }\n    }\n  }\n  if (Transition && Transition.running && node.pure) {\n    if (node.tOwned) {\n      for (i = 0; i < node.tOwned.length; i++) cleanNode(node.tOwned[i]);\n      delete node.tOwned;\n    }\n    reset(node, true);\n  } else if (node.owned) {\n    for (i = 0; i < node.owned.length; i++) cleanNode(node.owned[i]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i = 0; i < node.cleanups.length; i++) node.cleanups[i]();\n    node.cleanups = null;\n  }\n  if (Transition && Transition.running) node.tState = 0;else node.state = 0;\n  node.context = null;\n  delete node.sourceMap;\n}\nfunction reset(node, top) {\n  if (!top) {\n    node.tState = 0;\n    Transition.disposed.add(node);\n  }\n  if (node.owned) {\n    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);\n  }\n}\nfunction handleError(err) {\n  const fns = ERROR && lookup(Owner, ERROR);\n  if (!fns) throw err;\n  for (const f of fns) f(err);\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== undefined ? owner.context[key] : lookup(owner.owner, key) : undefined;\n}\nfunction resolveChildren(children) {\n  if (typeof children === \"function\" && !children.length) return resolveChildren(children());\n  if (Array.isArray(children)) {\n    const results = [];\n    for (let i = 0; i < children.length; i++) {\n      const result = resolveChildren(children[i]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children;\n}\nfunction createProvider(id) {\n  return function provider(props) {\n    let res;\n    createComputed(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }));\n    return res;\n  };\n}\nfunction hash(s) {\n  for (var i = 0, h = 9; i < s.length;) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);\n  return `${h ^ h >>> 9}`;\n}\nfunction serializeValues(sources = {}) {\n  const k = Object.keys(sources);\n  const result = {};\n  for (let i = 0; i < k.length; i++) {\n    const key = k[i];\n    result[key] = sources[key].value;\n  }\n  return result;\n}\nfunction serializeChildren(root) {\n  const result = {};\n  for (let i = 0, len = root.owned.length; i < len; i++) {\n    const node = root.owned[i];\n    result[node.componentName ? `${node.componentName}:${node.name}` : node.name] = { ...serializeValues(node.sourceMap),\n      ...(node.owned ? serializeChildren(node) : {})\n    };\n  }\n  return result;\n}\n\nfunction observable(input) {\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError(\"Expected the observer to be an object.\");\n      }\n      const handler = typeof observer === 'function' ? observer : observer.next && observer.next.bind(observer);\n      if (!handler) {\n        return {\n          unsubscribe() {}\n        };\n      }\n      const dispose = createRoot(disposer => {\n        createComputed(() => {\n          const v = input();\n          untrack(() => handler(v));\n        });\n        return disposer;\n      });\n      if (getOwner()) onCleanup(dispose);\n      return {\n        unsubscribe() {\n          dispose();\n        }\n      };\n    },\n    [Symbol.observable || \"@@observable\"]() {\n      return this;\n    }\n  };\n}\nfunction from(producer) {\n  const [s, set] = createSignal(undefined, {\n    equals: false\n  });\n  if (\"subscribe\" in producer) {\n    const unsub = producer.subscribe(v => set(() => v));\n    onCleanup(() => \"unsubscribe\" in unsub ? unsub.unsubscribe() : unsub());\n  } else {\n    const clean = producer(set);\n    onCleanup(clean);\n  }\n  return s;\n}\n\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i = 0; i < d.length; i++) d[i]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      len = 0,\n      indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [],\n        i,\n        j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length,\n          newIndices,\n          newIndicesNext,\n          temp,\n          tempdisposers,\n          tempIndexes,\n          start,\n          end,\n          newEnd,\n          item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      }\n      else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i = newIndices.get(item);\n          newIndicesNext[j] = i === undefined ? -1 : i;\n          newIndices.set(item, j);\n        }\n        for (i = start; i <= end; i++) {\n          item = items[i];\n          j = newIndices.get(item);\n          if (j !== undefined && j !== -1) {\n            temp[j] = mapped[i];\n            tempdisposers[j] = disposers[i];\n            indexes && (tempIndexes[j] = indexes[i]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else disposers[i]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction indexArray(list, mapFn, options = {}) {\n  let items = [],\n      mapped = [],\n      disposers = [],\n      signals = [],\n      len = 0,\n      i;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    const newItems = list() || [];\n    newItems[$TRACK];\n    return untrack(() => {\n      if (newItems.length === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          signals = [];\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot(disposer => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n        return mapped;\n      }\n      if (items[0] === FALLBACK) {\n        disposers[0]();\n        disposers = [];\n        items = [];\n        mapped = [];\n        len = 0;\n      }\n      for (i = 0; i < newItems.length; i++) {\n        if (i < items.length && items[i] !== newItems[i]) {\n          signals[i](() => newItems[i]);\n        } else if (i >= items.length) {\n          mapped[i] = createRoot(mapper);\n        }\n      }\n      for (; i < items.length; i++) {\n        disposers[i]();\n      }\n      len = signals.length = disposers.length = newItems.length;\n      items = newItems.slice(0);\n      return mapped = mapped.slice(0, len);\n    });\n    function mapper(disposer) {\n      disposers[i] = disposer;\n      const [s, set] = createSignal(newItems[i]);\n      signals[i] = set;\n      return mapFn(s, i);\n    }\n  };\n}\n\nlet hydrationEnabled = false;\nfunction enableHydration() {\n  hydrationEnabled = true;\n}\nfunction createComponent(Comp, props) {\n  if (hydrationEnabled) {\n    if (sharedConfig.context) {\n      const c = sharedConfig.context;\n      setHydrateContext(nextHydrateContext());\n      const r = devComponent(Comp, props || {}) ;\n      setHydrateContext(c);\n      return r;\n    }\n  }\n  return devComponent(Comp, props || {});\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY) return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s) {\n  return (s = typeof s === \"function\" ? s() : s) == null ? {} : s;\n}\nfunction mergeProps(...sources) {\n  return new Proxy({\n    get(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        const v = resolveSource(sources[i])[property];\n        if (v !== undefined) return v;\n      }\n    },\n    has(property) {\n      for (let i = sources.length - 1; i >= 0; i--) {\n        if (property in resolveSource(sources[i])) return true;\n      }\n      return false;\n    },\n    keys() {\n      const keys = [];\n      for (let i = 0; i < sources.length; i++) keys.push(...Object.keys(resolveSource(sources[i])));\n      return [...new Set(keys)];\n    }\n  }, propTraps);\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  const res = keys.map(k => {\n    const clone = {};\n    for (let i = 0; i < k.length; i++) {\n      const key = k[i];\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        }\n      });\n    }\n    return clone;\n  });\n  res.push(new Proxy({\n    get(property) {\n      return blocked.has(property) ? undefined : props[property];\n    },\n    has(property) {\n      return blocked.has(property) ? false : property in props;\n    },\n    keys() {\n      return Object.keys(props).filter(k => !blocked.has(k));\n    }\n  }, propTraps));\n  return res;\n}\nfunction lazy(fn) {\n  let comp;\n  let p;\n  const wrap = props => {\n    const ctx = sharedConfig.context;\n    if (ctx) {\n      const [s, set] = createSignal();\n      (p || (p = fn())).then(mod => {\n        setHydrateContext(ctx);\n        set(() => mod.default);\n        setHydrateContext();\n      });\n      comp = s;\n    } else if (!comp) {\n      const [s] = createResource(() => (p || (p = fn())).then(mod => mod.default));\n      comp = s;\n    } else {\n      const c = comp();\n      if (c) return c(props);\n    }\n    let Comp;\n    return createMemo(() => (Comp = comp()) && untrack(() => {\n      Object.assign(Comp, {\n        [$DEVCOMP]: true\n      });\n      if (!ctx) return Comp(props);\n      const c = sharedConfig.context;\n      setHydrateContext(ctx);\n      const r = Comp(props);\n      setHydrateContext(c);\n      return r;\n    }));\n  };\n  wrap.preload = () => p || ((p = fn()).then(mod => comp = () => mod.default), p);\n  return wrap;\n}\nlet counter = 0;\nfunction createUniqueId() {\n  const ctx = sharedConfig.context;\n  return ctx ? `${ctx.id}${ctx.count++}` : `cl-${counter++}`;\n}\n\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Index(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(indexArray(() => props.each, props.children, fallback ? fallback : undefined));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const condition = createMemo(() => props.when, undefined, {\n    equals: (a, b) => strictEqual ? a === b : !a === !b\n  });\n  return createMemo(() => {\n    const c = condition();\n    if (c) {\n      const child = props.children;\n      return (strictEqual = typeof child === \"function\" && child.length > 0) ? untrack(() => child(c)) : child;\n    }\n    return props.fallback;\n  });\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  const conditions = children(() => props.children),\n        evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds)) conds = [conds];\n    for (let i = 0; i < conds.length; i++) {\n      const c = conds[i].when;\n      if (c) return [i, c, conds[i]];\n    }\n    return [-1];\n  }, undefined, {\n    equals: (a, b) => a[0] === b[0] && (strictEqual ? a[1] === b[1] : !a[1] === !b[1]) && a[2] === b[2]\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0) return props.fallback;\n    const c = cond.children;\n    return (strictEqual = typeof c === \"function\" && c.length > 0) ? untrack(() => c(when)) : c;\n  });\n}\nfunction Match(props) {\n  return props;\n}\nlet Errors;\nconst NoErrors = {};\nfunction resetErrorBoundaries() {\n  Errors && [...Errors].forEach(fn => fn(NoErrors));\n}\nfunction ErrorBoundary(props) {\n  let err = NoErrors;\n  if (sharedConfig.context && sharedConfig.load) {\n    err = sharedConfig.load(sharedConfig.context.id + sharedConfig.context.count) || NoErrors;\n  }\n  const [errored, setErrored] = createSignal(err);\n  Errors || (Errors = new Set());\n  Errors.add(setErrored);\n  onCleanup(() => Errors.delete(setErrored));\n  return createMemo(() => {\n    let e;\n    if ((e = errored()) !== NoErrors) {\n      const f = props.fallback;\n      if ((typeof f !== \"function\" || f.length == 0)) console.error(e);\n      return typeof f === \"function\" && f.length ? untrack(() => f(e, () => setErrored(NoErrors))) : f;\n    }\n    onError(setErrored);\n    return props.children;\n  });\n}\n\nconst SuspenseListContext = createContext();\nfunction SuspenseList(props) {\n  let suspenseSetter, showContent, showFallback;\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) {\n    const [inFallback, setFallback] = createSignal(false);\n    suspenseSetter = setFallback;\n    [showContent, showFallback] = listContext.register(inFallback);\n  }\n  const [registry, setRegistry] = createSignal([]),\n        comp = createComponent(SuspenseListContext.Provider, {\n    value: {\n      register: inFallback => {\n        const [showingContent, showContent] = createSignal(false),\n              [showingFallback, showFallback] = createSignal(false);\n        setRegistry(registry => [...registry, {\n          inFallback,\n          showContent,\n          showFallback\n        }]);\n        return [showingContent, showingFallback];\n      }\n    },\n    get children() {\n      return props.children;\n    }\n  });\n  createComputed(() => {\n    const reveal = props.revealOrder,\n          tail = props.tail,\n          visibleContent = showContent ? showContent() : true,\n          visibleFallback = showFallback ? showFallback() : true,\n          reg = registry(),\n          reverse = reveal === \"backwards\";\n    if (reveal === \"together\") {\n      const all = reg.every(i => !i.inFallback());\n      suspenseSetter && suspenseSetter(!all);\n      reg.forEach(i => {\n        i.showContent(all && visibleContent);\n        i.showFallback(visibleFallback);\n      });\n      return;\n    }\n    let stop = false;\n    for (let i = 0, len = reg.length; i < len; i++) {\n      const n = reverse ? len - i - 1 : i,\n            s = reg[n].inFallback();\n      if (!stop && !s) {\n        reg[n].showContent(visibleContent);\n        reg[n].showFallback(visibleFallback);\n      } else {\n        const next = !stop;\n        if (next && suspenseSetter) suspenseSetter(true);\n        if (!tail || next && tail === \"collapsed\") {\n          reg[n].showFallback(visibleFallback);\n        } else reg[n].showFallback(false);\n        stop = true;\n        reg[n].showContent(next);\n      }\n    }\n    if (!stop && suspenseSetter) suspenseSetter(false);\n  });\n  return comp;\n}\nfunction Suspense(props) {\n  let counter = 0,\n      showContent,\n      showFallback,\n      ctx,\n      p,\n      flicker,\n      error;\n  const [inFallback, setFallback] = createSignal(false),\n        SuspenseContext = getSuspenseContext(),\n        store = {\n    increment: () => {\n      if (++counter === 1) setFallback(true);\n    },\n    decrement: () => {\n      if (--counter === 0) setFallback(false);\n    },\n    inFallback,\n    effects: [],\n    resolved: false\n  },\n        owner = getOwner();\n  if (sharedConfig.context && sharedConfig.load) {\n    const key = sharedConfig.context.id + sharedConfig.context.count;\n    p = sharedConfig.load(key);\n    if (p) {\n      if (typeof p !== \"object\" || !(\"then\" in p)) p = Promise.resolve(p);\n      const [s, set] = createSignal(undefined, {\n        equals: false\n      });\n      flicker = s;\n      p.then(err => {\n        if ((error = err) || sharedConfig.done) return set();\n        sharedConfig.gather(key);\n        setHydrateContext(ctx);\n        set();\n        setHydrateContext();\n      });\n    } else if (p === null) sharedConfig.gather(key);\n  }\n  const listContext = useContext(SuspenseListContext);\n  if (listContext) [showContent, showFallback] = listContext.register(store.inFallback);\n  let dispose;\n  onCleanup(() => dispose && dispose());\n  return createComponent(SuspenseContext.Provider, {\n    value: store,\n    get children() {\n      return createMemo(() => {\n        if (error) throw error;\n        ctx = sharedConfig.context;\n        if (flicker) {\n          flicker();\n          return flicker = undefined;\n        }\n        if (ctx && p === undefined) setHydrateContext();\n        const rendered = createMemo(() => props.children);\n        return createMemo(() => {\n          const inFallback = store.inFallback(),\n                visibleContent = showContent ? showContent() : true,\n                visibleFallback = showFallback ? showFallback() : true;\n          dispose && dispose();\n          if ((!inFallback || p !== undefined) && visibleContent) {\n            store.resolved = true;\n            ctx = p = undefined;\n            resumeEffects(store.effects);\n            return rendered();\n          }\n          if (!visibleFallback) return;\n          return createRoot(disposer => {\n            dispose = disposer;\n            if (ctx) {\n              setHydrateContext({\n                id: ctx.id + \"f\",\n                count: 0\n              });\n              ctx = undefined;\n            }\n            return props.fallback;\n          }, owner);\n        });\n      });\n    }\n  });\n}\n\nlet DEV;\n{\n  DEV = {\n    writeSignal,\n    serializeGraph,\n    registerGraph,\n    hashValue\n  };\n}\nif (globalThis) {\n  if (!globalThis.Solid$$) globalThis.Solid$$ = true;else console.warn(\"You appear to have multiple instances of Solid. This can lead to unexpected behavior.\");\n}\n\nexport { $DEVCOMP, $PROXY, $TRACK, DEV, ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, batch, cancelCallback, children, createComponent, createComputed, createContext, createDeferred, createEffect, createMemo, createReaction, createRenderEffect, createResource, createRoot, createSelector, createSignal, createUniqueId, enableExternalSource, enableHydration, enableScheduling, equalFn, from, getListener, getOwner, indexArray, lazy, mapArray, mergeProps, observable, on, onCleanup, onError, onMount, requestCallback, resetErrorBoundaries, runWithOwner, sharedConfig, splitProps, startTransition, untrack, useContext, useTransition };\n", "export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n", "import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize) {\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLine.length)\n                    this.nextLine();\n                if (from < to || from > this.value.to) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            // If a match goes almost to the end of a noncomplete chunk, try\n            // again, since it'll likely be able to match more\n            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)\n                match = null;\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                this.value = { from, to, match };\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                return this;\n            }\n            else {\n                if (this.flat.to == this.to) {\n                    this.done = true;\n                    return this;\n                }\n                // Grow the flattened doc\n                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n            }\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\" });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        view.dispatch({\n            effects: dialogEffect.of(false),\n            selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to)\n                    && insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to).trim();\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        var _a;\n        return {\n            top: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.top, undefined) || false,\n            caseSensitive: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.caseSensitive, undefined) || false,\n            literal: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.literal, undefined) || false,\n            createPanel: ((_a = configs.find(c => c.createPanel)) === null || _a === void 0 ? void 0 : _a.createPanel) || (view => new SearchPanel(view))\n        };\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.literal ? this.search : this.search.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given document.\n    */\n    getCursor(doc, from = 0, to = doc.length) {\n        return this.regexp ? regexpCursor(this, doc, from, to) : stringCursor(this, doc, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, doc, from, to) {\n    return new SearchCursor(doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase());\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, doc, curTo, doc.length).nextOverlapping();\n        if (cursor.done)\n            cursor = stringCursor(this.spec, doc, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(doc, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, doc, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* ChunkSize */;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(_result) { return this.spec.replace; }\n    matchAll(doc, limit) {\n        let cursor = stringCursor(this.spec, doc, 0, doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = stringCursor(this.spec, doc, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, doc, from, to) {\n    return new RegExpCursor(doc, spec.search, spec.caseSensitive ? undefined : { ignoreCase: true }, from, to);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, doc, curTo, doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, doc, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(doc, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* ChunkSize */);\n            let cursor = regexpCursor(this.spec, doc, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(doc, limit) {\n        let cursor = regexpCursor(this.spec, doc, 0, doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = regexpCursor(this.spec, doc, Math.max(0, from - 250 /* HighlightMargin */), Math.min(to + 250 /* HighlightMargin */, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state.doc, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state.doc, to, to);\n    if (!next)\n        return false;\n    view.dispatch({\n        selection: { anchor: next.from, head: next.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, next),\n        userEvent: \"select.search\"\n    });\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let range = query.prevMatch(state.doc, from, from);\n    if (!range)\n        return false;\n    view.dispatch({\n        selection: { anchor: range.from, head: range.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, range),\n        userEvent: \"select.search\"\n    });\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state.doc, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let next = query.nextMatch(state.doc, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    let announce = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state.doc, next.from, next.to);\n        announce.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = { anchor: next.from - off, head: next.to - off };\n        announce.push(announceMatch(view, next));\n    }\n    view.dispatch({\n        changes, selection,\n        scrollIntoView: !!selection,\n        effects: announce,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state.doc, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n    });\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let panel = getPanel(view, createSearchPanel);\n        if (!panel)\n            return false;\n        let searchInput = panel.dom.querySelector(\"[main-field]\");\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")]),\n                elt(\"button\", {\n                    name: \"close\",\n                    onclick: () => closeSearchPanel(view),\n                    \"aria-label\": phrase(view, \"close\"),\n                    type: \"button\"\n                }, [\"\u00D7\"])\n            ]\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            replace: this.replaceField.value\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.lowest(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n", "import { Annotation, Facet, combineConfig, StateField, EditorSelection, Transaction, ChangeSet, ChangeDesc, StateEffect, Text, findClusterBreak, countColumn, CharCategory } from '@codemirror/state';\nimport { EditorView, Direction } from '@codemirror/view';\nimport { IndentContext, getIndentation, indentString, indentUnit, getIndentUnit, matchBrackets, syntaxTree } from '@codemirror/language';\nimport { NodeProp } from '@lezer/common';\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n    let config = getConfig(target.state);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let tr = f(option, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* Uncomment */);\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/\nconst toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* Toggle */);\nfunction getConfig(state, pos = state.selection.main.head) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges) {\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from)\n            ranges[last].to = toLine.to;\n        else\n            ranges.push({ from: fromLine.from, to: toLine.to });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* Uncomment */ && !comments.every(c => c)) {\n        return { changes: state.changes(ranges.map((range, i) => {\n                if (comments[i])\n                    return [];\n                return [{ from: range.from, insert: tokens[i].open + \" \" }, { from: range.to, insert: \" \" + tokens[i].close }];\n            })) };\n    }\n    else if (option != 1 /* Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges) {\n        let startI = lines.length, minIndent = 1e9;\n        for (let pos = from; pos <= to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let token = getConfig(state, pos).line;\n                if (!token)\n                    continue;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent)\n                    minIndent = indent;\n                lines.push({ line, comment, token, indent, empty, single: false });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9)\n            for (let i = startI; i < lines.length; i++)\n                if (lines[i].indent < lines[i].line.text.length)\n                    lines[i].indent = minIndent;\n        if (lines.length == startI + 1)\n            lines[startI].single = true;\n    }\n    if (option != 2 /* Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)\n            if (single || !empty)\n                changes.push({ from: line.from + indent, insert: token + \" \" });\n        let changeSet = state.changes(changes);\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\n    }\n    else if (option != 1 /* Comment */ && lines.some(l => l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)\n            if (comment >= 0) {\n                let from = line.from + comment, to = from + token.length;\n                if (line.text[to - line.from] == \" \")\n                    to++;\n                changes.push({ from, to });\n            }\n        return { changes };\n    }\n    return null;\n}\n\nconst fromHistory = /*@__PURE__*/Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\nconst isolateHistory = /*@__PURE__*/Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\nconst invertedEffects = /*@__PURE__*/Facet.define();\nconst historyConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            minDepth: 100,\n            newGroupDelay: 500\n        }, { minDepth: Math.max, newGroupDelay: Math.min });\n    }\n});\nfunction changeEnd(changes) {\n    let end = 0;\n    changes.iterChangedRanges((_, to) => end = to);\n    return end;\n}\nconst historyField_ = /*@__PURE__*/StateField.define({\n    create() {\n        return HistoryState.empty;\n    },\n    update(state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : undefined;\n            let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;\n            let other = from == 0 /* Done */ ? state.undone : state.done;\n            if (item)\n                other = updateBranch(other, other.length, config.minDepth, item);\n            else\n                other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* Done */ ? fromHist.rest : other, from == 0 /* Done */ ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\")\n            state = state.isolate();\n        if (tr.annotation(Transaction.addToHistory) === false)\n            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);\n        if (event)\n            state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);\n        else if (tr.selection)\n            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\")\n            state = state.isolate();\n        return state;\n    },\n    toJSON(value) {\n        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };\n    },\n    fromJSON(json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/\nfunction history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        EditorView.domEventHandlers({\n            beforeinput(e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command)\n                    return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\nconst historyField = historyField_;\nfunction cmd(side, selection) {\n    return function ({ state, dispatch }) {\n        if (!selection && state.readOnly)\n            return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState)\n            return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr)\n            return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\nconst undo = /*@__PURE__*/cmd(0 /* Done */, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\nconst redo = /*@__PURE__*/cmd(1 /* Undone */, false);\n/**\nUndo a change or selection change.\n*/\nconst undoSelection = /*@__PURE__*/cmd(0 /* Done */, true);\n/**\nRedo a change or selection change.\n*/\nconst redoSelection = /*@__PURE__*/cmd(1 /* Undone */, true);\nfunction depth(side) {\n    return function (state) {\n        let histState = state.field(historyField_, false);\n        if (!histState)\n            return 0;\n        let branch = side == 0 /* Done */ ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\nconst undoDepth = /*@__PURE__*/depth(0 /* Done */);\n/**\nThe amount of redoable change events available in a given state.\n*/\nconst redoDepth = /*@__PURE__*/depth(1 /* Undone */);\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(\n    // The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, \n    // The effects associated with this event\n    effects, \n    // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, \n    // The selection before this event\n    startSelection, \n    // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter) {\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)) {\n            let result = invert(tr);\n            if (result.length)\n                effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty)\n            return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t) => ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t) => {\n        for (let i = 0; i < ranges.length;) {\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to)\n                isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length &&\n        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [HistEvent.selection([selection])];\n    }\n    else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection))\n            return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length)\n        return branch;\n    let length = branch.length, selections = none;\n    while (length) {\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        }\n        else { // Drop this event, since there's no changes or effects left\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [HistEvent.selection(selections)] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes)\n        return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, newGroupDelay, maxLen) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&\n            (!userEvent || joinableUserEvent.test(userEvent)) &&\n            ((!lastEvent.selectionsAfter.length &&\n                time - this.prevTime < newGroupDelay &&\n                isAdjacent(lastEvent.changes, event.changes)) ||\n                // For compose (but not compose.start) events, always join with previous event\n                userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        }\n        else {\n            done = updateBranch(done, done.length, maxLen, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 &&\n            time - this.prevTime < newGroupDelay &&\n            userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) &&\n            eqSelectionShape(last[last.length - 1], selection))\n            return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, selection) {\n        let branch = side == 0 /* Done */ ? this.done : this.undone;\n        if (branch.length == 0)\n            return null;\n        let event = branch[branch.length - 1];\n        if (selection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({ side, rest: popSelection(branch) }),\n                userEvent: side == 0 /* Done */ ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        }\n        else if (!event.changes) {\n            return null;\n        }\n        else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped)\n                rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({ side, rest }),\n                filter: false,\n                userEvent: side == 0 /* Done */ ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/\nconst historyKeymap = [\n    { key: \"Mod-z\", run: undo, preventDefault: true },\n    { key: \"Mod-y\", mac: \"Mod-Shift-z\", run: redo, preventDefault: true },\n    { linux: \"Ctrl-Shift-z\", run: redo, preventDefault: true },\n    { key: \"Mod-u\", run: undoSelection, preventDefault: true },\n    { key: \"Alt-u\", mac: \"Mod-Shift-u\", run: redoSelection, preventDefault: true }\n];\n\nfunction updateSel(sel, by) {\n    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({ selection, scrollIntoView: true, userEvent: \"select\" });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection))\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/\nconst cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/\nconst cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/\nconst cursorCharForward = view => cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/\nconst cursorCharBackward = view => cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/\nconst cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/\nconst cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/\nconst cursorGroupForward = view => cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/\nconst cursorGroupBackward = view => cursorByGroup(view, false);\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    return view.moveByChar(range, forward, start => {\n        let cat = CharCategory.Space, pos = range.from;\n        let done = false, sawUpper = false, sawLower = false;\n        let step = (next) => {\n            if (done)\n                return false;\n            pos += forward ? next.length : -next.length;\n            let nextCat = categorize(next), ahead;\n            if (cat == CharCategory.Space)\n                cat = nextCat;\n            if (cat != nextCat)\n                return false;\n            if (cat == CharCategory.Word) {\n                if (next.toLowerCase() == next) {\n                    if (!forward && sawUpper)\n                        return false;\n                    sawLower = true;\n                }\n                else if (sawLower) {\n                    if (forward)\n                        return false;\n                    done = true;\n                }\n                else {\n                    if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word &&\n                        ahead.toLowerCase() == ahead)\n                        return false;\n                    sawUpper = true;\n                }\n            }\n            return true;\n        };\n        step(start);\n        return step;\n    });\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/\nconst cursorSubwordForward = view => cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/\nconst cursorSubwordBackward = view => cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp))\n        return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = syntaxTree(state).resolveInner(start.head);\n    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for (let at = start.head;;) {\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next)\n            break;\n        if (interestingNode(state, next, bracketProp))\n            pos = next;\n        else\n            at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)\n        newPos = forward ? match.end.to : match.end.from;\n    else\n        newPos = forward ? pos.to : pos.from;\n    return EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/\nconst cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/\nconst cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, range => {\n        if (!range.empty)\n            return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/\nconst cursorLineUp = view => cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/\nconst cursorLineDown = view => cursorByLine(view, true);\nfunction pageHeight(view) {\n    return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);\n}\nfunction cursorByPage(view, forward) {\n    let { state } = view, selection = updateSel(state.selection, range => {\n        return range.empty ? view.moveVertically(range, forward, pageHeight(view)) : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection))\n        return false;\n    let startPos = view.coordsAtPos(state.selection.main.head);\n    let scrollRect = view.scrollDOM.getBoundingClientRect();\n    let effect;\n    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom &&\n        startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)\n        effect = EditorView.scrollIntoView(selection.main.head, { y: \"start\", yMargin: startPos.top - scrollRect.top });\n    view.dispatch(setSel(state, selection), { effects: effect });\n    return true;\n}\n/**\nMove the selection one page up.\n*/\nconst cursorPageUp = view => cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/\nconst cursorPageDown = view => cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))\n        moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space)\n            moved = EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/\nconst cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/\nconst cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/\nconst cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/\nconst cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/\nconst cursorLineStart = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/\nconst cursorLineEnd = view => moveSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, range => {\n        let matching = matchBrackets(state, range.head, -1)\n            || matchBrackets(state, range.head, 1)\n            || (range.head > 0 && matchBrackets(state, range.head - 1, 1))\n            || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));\n        if (!matching || !matching.end)\n            return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);\n    });\n    if (!found)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/\nconst cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/\nconst selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, range => {\n        let head = how(range);\n        return EditorSelection.range(range.anchor, head.head, head.goalColumn);\n    });\n    if (selection.eq(view.state.selection))\n        return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, range => view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/\nconst selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/\nconst selectCharRight = view => selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/\nconst selectCharForward = view => selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/\nconst selectCharBackward = view => selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, range => view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/\nconst selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/\nconst selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/\nconst selectGroupForward = view => selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/\nconst selectGroupBackward = view => selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, range => moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/\nconst selectSubwordForward = view => selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/\nconst selectSubwordBackward = view => selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/\nconst selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/\nconst selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/\nconst selectLineUp = view => selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/\nconst selectLineDown = view => selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, range => view.moveVertically(range, forward, pageHeight(view)));\n}\n/**\nMove the selection head one page up.\n*/\nconst selectPageUp = view => selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/\nconst selectPageDown = view => selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/\nconst selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/\nconst selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/\nconst selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/\nconst selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/\nconst selectLineStart = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/\nconst selectLineEnd = view => extendSel(view, range => EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/\nconst cursorDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: 0 }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/\nconst cursorDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.doc.length }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/\nconst selectDocStart = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/\nconst selectDocEnd = ({ state, dispatch }) => {\n    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));\n    return true;\n};\n/**\nSelect the entire document.\n*/\nconst selectAll = ({ state, dispatch }) => {\n    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: \"select\" }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/\nconst selectLine = ({ state, dispatch }) => {\n    let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: \"select\" }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/\nconst selectParentSyntax = ({ state, dispatch }) => {\n    let selection = updateSel(state.selection, range => {\n        var _a;\n        let context = syntaxTree(state).resolveInner(range.head, 1);\n        while (!((context.from < range.from && context.to >= range.to) ||\n            (context.to > range.to && context.from <= range.from) ||\n            !((_a = context.parent) === null || _a === void 0 ? void 0 : _a.parent)))\n            context = context.parent;\n        return EditorSelection.range(context.to, context.from);\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/\nconst simplifySelection = ({ state, dispatch }) => {\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1)\n        selection = EditorSelection.create([cur.main]);\n    else if (!cur.main.empty)\n        selection = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);\n    if (!selection)\n        return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy({ state, dispatch }, by) {\n    if (state.readOnly)\n        return false;\n    let event = \"delete.selection\";\n    let changes = state.changeByRange(range => {\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(from);\n            if (towards < from)\n                event = \"delete.backward\";\n            else if (towards > from)\n                event = \"delete.forward\";\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        }\n        return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof EditorView)\n        for (let ranges of target.state.facet(EditorView.atomicRanges).map(f => f(target)))\n            ranges.between(pos, pos, (from, to) => {\n                if (from < pos && to > pos)\n                    pos = forward ? to : from;\n            });\n    return pos;\n}\nconst deleteByChar = (target, forward) => deleteBy(target, pos => {\n    let { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n    if (!forward && pos > line.from && pos < line.from + 200 &&\n        !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n        if (before[before.length - 1] == \"\\t\")\n            return pos - 1;\n        let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);\n        for (let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)\n            pos--;\n        targetPos = pos;\n    }\n    else {\n        targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;\n        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))\n            targetPos += forward ? 1 : -1;\n    }\n    return skipAtomic(target, targetPos, forward);\n});\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/\nconst deleteCharBackward = view => deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/\nconst deleteCharForward = view => deleteByChar(view, true);\nconst deleteByGroup = (target, forward) => deleteBy(target, start => {\n    let pos = start, { state } = target, line = state.doc.lineAt(pos);\n    let categorize = state.charCategorizer(pos);\n    for (let cat = null;;) {\n        if (pos == (forward ? line.to : line.from)) {\n            if (pos == start && line.number != (forward ? state.doc.lines : 1))\n                pos += forward ? 1 : -1;\n            break;\n        }\n        let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;\n        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n        let nextCat = categorize(nextChar);\n        if (cat != null && nextCat != cat)\n            break;\n        if (nextChar != \" \" || pos != start)\n            cat = nextCat;\n        pos = next;\n    }\n    return skipAtomic(target, pos, forward);\n});\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/\nconst deleteGroupBackward = target => deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/\nconst deleteGroupForward = target => deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/\nconst deleteToLineEnd = view => deleteBy(view, pos => {\n    let lineEnd = view.lineBlockAt(pos).to;\n    return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);\n});\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/\nconst deleteToLineStart = view => deleteBy(view, pos => {\n    let lineStart = view.lineBlockAt(pos).from;\n    return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);\n});\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/\nconst deleteTrailingWhitespace = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let pos = 0, prev = \"\", iter = state.doc.iter();;) {\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1)\n                changes.push({ from: pos - (prev.length - trailing), to: pos });\n            if (iter.done)\n                break;\n            prev = \"\";\n        }\n        else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({ changes, userEvent: \"delete\" }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/\nconst splitLine = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        return { changes: { from: range.from, to: range.to, insert: Text.of([\"\", \"\"]) },\n            range: EditorSelection.cursor(range.from) };\n    });\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/\nconst transposeChars = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let changes = state.changeByRange(range => {\n        if (!range.empty || range.from == 0 || range.from == state.doc.length)\n            return { range };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;\n        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },\n            range: EditorSelection.cursor(to) };\n    });\n    if (changes.changes.empty)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"move.character\" }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges) {\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from)\n            endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        }\n        else {\n            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward ? block.to == state.doc.length : block.from == 0)\n            continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });\n            for (let r of block.ranges)\n                ranges.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        }\n        else {\n            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });\n            for (let r of block.ranges)\n                ranges.push(EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length)\n        return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/\nconst moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/\nconst moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly)\n        return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)) {\n        if (forward)\n            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });\n        else\n            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });\n    }\n    dispatch(state.update({ changes, scrollIntoView: true, userEvent: \"input.copyline\" }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/\nconst copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/\nconst copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/\nconst deleteLine = view => {\n    if (view.state.readOnly)\n        return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {\n        if (from > 0)\n            from--;\n        else if (to < state.doc.length)\n            to++;\n        return { from, to };\n    }));\n    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);\n    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: \"delete.line\" });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/\nconst insertNewline = ({ state, dispatch }) => {\n    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1)))\n        return { from: pos, to: pos };\n    let context = syntaxTree(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos &&\n        (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&\n        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)\n        return { from: before.to, to: after.from };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/\nconst insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/\nconst insertBlankLine = /*@__PURE__*/newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch }) => {\n        if (state.readOnly)\n            return false;\n        let changes = state.changeByRange(range => {\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof)\n                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });\n            let indent = getIndentation(cx, from);\n            if (indent == null)\n                indent = /^\\s*/.exec(state.doc.lineAt(from).text)[0].length;\n            while (to < line.to && /\\s/.test(line.text[to - line.from]))\n                to++;\n            if (explode)\n                ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from)))\n                from = line.from;\n            let insert = [\"\", indentString(state, indent)];\n            if (explode)\n                insert.push(indentString(state, cx.lineIndent(line.from, -1)));\n            return { changes: { from, to, insert: Text.of(insert) },\n                range: EditorSelection.cursor(from + 1 + insert[1].length) };\n        });\n        dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange(range => {\n        let changes = [];\n        for (let pos = range.from; pos <= range.to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return { changes,\n            range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/\nconst indentSelection = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    let updated = Object.create(null);\n    let context = new IndentContext(state, { overrideIndentation: start => {\n            let found = updated[start];\n            return found == null ? -1 : found;\n        } });\n    let changes = changeBySelectedLine(state, (line, changes, range) => {\n        let indent = getIndentation(context, line.from);\n        if (indent == null)\n            return;\n        if (!/\\S/.test(line.text))\n            indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });\n        }\n    });\n    if (!changes.changes.empty)\n        dispatch(state.update(changes, { userEvent: \"indent\" }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/\nconst indentMore = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        changes.push({ from: line.from, insert: state.facet(indentUnit) });\n    }), { userEvent: \"input.indent\" }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/\nconst indentLess = ({ state, dispatch }) => {\n    if (state.readOnly)\n        return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space)\n            return;\n        let col = countColumn(space, state.tabSize), keep = 0;\n        let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));\n        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))\n            keep++;\n        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });\n    }), { userEvent: \"delete.dedent\" }));\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/\nconst insertTab = ({ state, dispatch }) => {\n    if (state.selection.ranges.some(r => !r.empty))\n        return indentMore({ state, dispatch });\n    dispatch(state.update(state.replaceSelection(\"\\t\"), { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/\nconst emacsStyleKeymap = [\n    { key: \"Ctrl-b\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Ctrl-f\", run: cursorCharRight, shift: selectCharRight },\n    { key: \"Ctrl-p\", run: cursorLineUp, shift: selectLineUp },\n    { key: \"Ctrl-n\", run: cursorLineDown, shift: selectLineDown },\n    { key: \"Ctrl-a\", run: cursorLineStart, shift: selectLineStart },\n    { key: \"Ctrl-e\", run: cursorLineEnd, shift: selectLineEnd },\n    { key: \"Ctrl-d\", run: deleteCharForward },\n    { key: \"Ctrl-h\", run: deleteCharBackward },\n    { key: \"Ctrl-k\", run: deleteToLineEnd },\n    { key: \"Ctrl-Alt-h\", run: deleteGroupBackward },\n    { key: \"Ctrl-o\", run: splitLine },\n    { key: \"Ctrl-t\", run: transposeChars },\n    { key: \"Ctrl-v\", run: cursorPageDown },\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteToLineStart`](https://codemirror.net/6/docs/ref/#commands.deleteToLineStart).\n - Cmd-Delete (macOS): [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd).\n*/\nconst standardKeymap = /*@__PURE__*/[\n    { key: \"ArrowLeft\", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },\n    { key: \"Mod-ArrowLeft\", mac: \"Alt-ArrowLeft\", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },\n    { mac: \"Cmd-ArrowLeft\", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },\n    { key: \"ArrowRight\", run: cursorCharRight, shift: selectCharRight, preventDefault: true },\n    { key: \"Mod-ArrowRight\", mac: \"Alt-ArrowRight\", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },\n    { mac: \"Cmd-ArrowRight\", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },\n    { key: \"ArrowUp\", run: cursorLineUp, shift: selectLineUp, preventDefault: true },\n    { mac: \"Cmd-ArrowUp\", run: cursorDocStart, shift: selectDocStart },\n    { mac: \"Ctrl-ArrowUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"ArrowDown\", run: cursorLineDown, shift: selectLineDown, preventDefault: true },\n    { mac: \"Cmd-ArrowDown\", run: cursorDocEnd, shift: selectDocEnd },\n    { mac: \"Ctrl-ArrowDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"PageUp\", run: cursorPageUp, shift: selectPageUp },\n    { key: \"PageDown\", run: cursorPageDown, shift: selectPageDown },\n    { key: \"Home\", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },\n    { key: \"Mod-Home\", run: cursorDocStart, shift: selectDocStart },\n    { key: \"End\", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },\n    { key: \"Mod-End\", run: cursorDocEnd, shift: selectDocEnd },\n    { key: \"Enter\", run: insertNewlineAndIndent },\n    { key: \"Mod-a\", run: selectAll },\n    { key: \"Backspace\", run: deleteCharBackward, shift: deleteCharBackward },\n    { key: \"Delete\", run: deleteCharForward },\n    { key: \"Mod-Backspace\", mac: \"Alt-Backspace\", run: deleteGroupBackward },\n    { key: \"Mod-Delete\", mac: \"Alt-Delete\", run: deleteGroupForward },\n    { mac: \"Mod-Backspace\", run: deleteToLineStart },\n    { mac: \"Mod-Delete\", run: deleteToLineEnd }\n].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Comd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n*/\nconst defaultKeymap = /*@__PURE__*/[\n    { key: \"Alt-ArrowLeft\", mac: \"Ctrl-ArrowLeft\", run: cursorSyntaxLeft, shift: selectSyntaxLeft },\n    { key: \"Alt-ArrowRight\", mac: \"Ctrl-ArrowRight\", run: cursorSyntaxRight, shift: selectSyntaxRight },\n    { key: \"Alt-ArrowUp\", run: moveLineUp },\n    { key: \"Shift-Alt-ArrowUp\", run: copyLineUp },\n    { key: \"Alt-ArrowDown\", run: moveLineDown },\n    { key: \"Shift-Alt-ArrowDown\", run: copyLineDown },\n    { key: \"Escape\", run: simplifySelection },\n    { key: \"Mod-Enter\", run: insertBlankLine },\n    { key: \"Alt-l\", mac: \"Ctrl-l\", run: selectLine },\n    { key: \"Mod-i\", run: selectParentSyntax, preventDefault: true },\n    { key: \"Mod-[\", run: indentLess },\n    { key: \"Mod-]\", run: indentMore },\n    { key: \"Mod-Alt-\\\\\", run: indentSelection },\n    { key: \"Shift-Mod-k\", run: deleteLine },\n    { key: \"Shift-Mod-\\\\\", run: cursorMatchingBracket },\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/\nconst indentWithTab = { key: \"Tab\", run: indentMore, shift: indentLess };\n\nexport { blockComment, blockUncomment, copyLineDown, copyLineUp, cursorCharBackward, cursorCharForward, cursorCharLeft, cursorCharRight, cursorDocEnd, cursorDocStart, cursorGroupBackward, cursorGroupForward, cursorGroupLeft, cursorGroupRight, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorLineBoundaryLeft, cursorLineBoundaryRight, cursorLineDown, cursorLineEnd, cursorLineStart, cursorLineUp, cursorMatchingBracket, cursorPageDown, cursorPageUp, cursorSubwordBackward, cursorSubwordForward, cursorSyntaxLeft, cursorSyntaxRight, defaultKeymap, deleteCharBackward, deleteCharForward, deleteGroupBackward, deleteGroupForward, deleteLine, deleteToLineEnd, deleteToLineStart, deleteTrailingWhitespace, emacsStyleKeymap, history, historyField, historyKeymap, indentLess, indentMore, indentSelection, indentWithTab, insertBlankLine, insertNewline, insertNewlineAndIndent, insertTab, invertedEffects, isolateHistory, lineComment, lineUncomment, moveLineDown, moveLineUp, redo, redoDepth, redoSelection, selectAll, selectCharBackward, selectCharForward, selectCharLeft, selectCharRight, selectDocEnd, selectDocStart, selectGroupBackward, selectGroupForward, selectGroupLeft, selectGroupRight, selectLine, selectLineBoundaryBackward, selectLineBoundaryForward, selectLineBoundaryLeft, selectLineBoundaryRight, selectLineDown, selectLineEnd, selectLineStart, selectLineUp, selectMatchingBracket, selectPageDown, selectPageUp, selectParentSyntax, selectSubwordBackward, selectSubwordForward, selectSyntaxLeft, selectSyntaxRight, simplifySelection, splitLine, standardKeymap, toggleBlockComment, toggleBlockCommentByLine, toggleComment, toggleLineComment, transposeChars, undo, undoDepth, undoSelection };\n", "import { EditorSelection, MapMode, Prec, RangeSetBuilder, StateEffect, StateField } from '@codemirror/state';\nimport { foldCode, matchBrackets, indentUnit, ensureSyntaxTree, StringStream } from '@codemirror/language';\nimport { EditorView, Direction, ViewPlugin, Decoration, showPanel } from '@codemirror/view';\nimport { SearchQuery, setSearchQuery, RegExpCursor } from '@codemirror/search';\nimport { indentMore, indentLess, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorCharBackward, cursorCharLeft, insertNewlineAndIndent, indentSelection, deleteCharBackward, deleteCharForward, undo, redo } from '@codemirror/commands';\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/', '+']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n      registers['+'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        if (registerName === '+') {\n          navigator.clipboard.writeText(text);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        if (actionArgs.registerName === '+') {\n          navigator.clipboard.readText().then((value) => {\n            this.continuePaste(cm, actionArgs, vim, value, register);\n          });\n        } else {\n          var text = register.toString();\n          this.continuePaste(cm, actionArgs, vim, text, register);\n        }\n      },\n      continuePaste: function(cm, actionArgs, vim, text, register) {\n        var cur = copyCursor(cm.getCursor());\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n            text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line + 1,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the pos member to represent the\n    next valid position or sets the line to null if there are\n    no more valid positions.\n   */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n    Performs one iteration of traversal in forward direction\n    Returns an index object of the new location\n   */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1, };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /*\n    Performs one iteration of traversal in reverse direction\n    Returns an index object of the new location\n   */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1, };\n              } else {\n                return {ln: curr.ln, pos: lastSentencePos};\n              }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the line, ln, and pos members to represent the\n    next valid position or sets them to null if there are\n    no more valid positions.\n   */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction indexFromPos(doc, pos) {\n    var ch = pos.ch;\n    var lineNumber = pos.line + 1;\n    if (lineNumber < 1) {\n        lineNumber = 1;\n        ch = 0;\n    }\n    if (lineNumber > doc.lines) {\n        lineNumber = doc.lines;\n        ch = Number.MAX_VALUE;\n    }\n    var line = doc.line(lineNumber);\n    return Math.min(line.from + Math.max(0, ch), line.to);\n}\nfunction posFromIndex(doc, offset) {\n    let line = doc.lineAt(offset);\n    return { line: line.number - 1, ch: offset - line.from };\n}\nclass Pos {\n    constructor(line, ch) {\n        this.line = line;\n        this.ch = ch;\n    }\n}\nfunction on(emitter, type, f) {\n    if (emitter.addEventListener) {\n        emitter.addEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers || (emitter._handlers = {});\n        map[type] = (map[type] || []).concat(f);\n    }\n}\nfunction off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n        emitter.removeEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers, arr = map && map[type];\n        if (arr) {\n            var index = arr.indexOf(f);\n            if (index > -1) {\n                map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n            }\n        }\n    }\n}\nfunction signal(emitter, type, ...args) {\n    var _a;\n    var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nfunction signalTo(handlers, ...args) {\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nvar specialKey = {\n    Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n    Enter: 'CR', ' ': 'Space'\n};\nvar ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1, CapsLock: 1, AltGraph: 1 };\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\w\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) {\n    wordChar = /[\\w]/;\n}\n// workaround for missing api for merging transactions\nfunction dispatchChange(cm, transaction) {\n    var view = cm.cm6;\n    var type = \"input.type.compose\";\n    if (cm.curOp) {\n        if (!cm.curOp.lastChange)\n            type = \"input.type.compose.start\";\n    }\n    if (transaction.annotations) {\n        try {\n            transaction.annotations.some(function (note) {\n                if (note.value == \"input\")\n                    note.value = type;\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    else {\n        transaction.userEvent = type;\n    }\n    return view.dispatch(transaction);\n}\nfunction runHistoryCommand(cm, revert) {\n    var _a;\n    if (cm.curOp) {\n        cm.curOp.$changeStart = undefined;\n    }\n    (revert ? undo : redo)(cm.cm6);\n    let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;\n    // vim mode expects the changed text to be either selected or cursor placed at the start\n    if (changeStartIndex != null) {\n        cm.cm6.dispatch({ selection: { anchor: changeStartIndex } });\n    }\n}\nclass CodeMirror {\n    constructor(cm6) {\n        this.state = {};\n        this.marks = Object.create(null);\n        this.$mid = 0; // marker id counter\n        this.options = {};\n        this._handlers = {};\n        // TODO change vim.js to not use obscure api\n        this.doc = {\n            history: {\n                done: [\n                    {\n                        changes: [\n                            {\n                                cm: this,\n                                get to() {\n                                    return this.cm.posFromIndex(this.cm.$lastChangeEndOffset);\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }\n        };\n        this.$lastChangeEndOffset = 0;\n        this.virtualSelection = null;\n        this.cm6 = cm6;\n        this.onChange = this.onChange.bind(this);\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    // --------------------------\n    openDialog(template, callback, options) {\n        return openDialog(this, template, callback, options);\n    }\n    ;\n    openNotification(template, options) {\n        return openNotification(this, template, options);\n    }\n    ;\n    ;\n    on(type, f) { on(this, type, f); }\n    off(type, f) { off(this, type, f); }\n    signal(type, e, handlers) { signal(this, type, e, handlers); }\n    indexFromPos(pos) {\n        return indexFromPos(this.cm6.state.doc, pos);\n    }\n    ;\n    posFromIndex(offset) {\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    foldCode(pos) {\n        let view = this.cm6;\n        let ranges = view.state.selection.ranges;\n        let doc = this.cm6.state.doc;\n        let index = indexFromPos(doc, pos);\n        let tmpRanges = EditorSelection.create([EditorSelection.range(index, index)], 0).ranges;\n        view.state.selection.ranges = tmpRanges;\n        foldCode(view);\n        view.state.selection.ranges = ranges;\n    }\n    firstLine() { return 0; }\n    ;\n    lastLine() { return this.cm6.state.doc.lines - 1; }\n    ;\n    lineCount() { return this.cm6.state.doc.lines; }\n    ;\n    setCursor(line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var offset = indexFromPos(this.cm6.state.doc, { line, ch });\n        this.cm6.dispatch({ selection: { anchor: offset } }, { scrollIntoView: !this.curOp });\n        if (this.curOp && !this.curOp.isVimOp)\n            this.onBeforeEndOperation();\n    }\n    ;\n    getCursor(p) {\n        var sel = this.cm6.state.selection.main;\n        var offset = p == \"head\" || !p\n            ? sel.head\n            : p == \"anchor\"\n                ? sel.anchor\n                : p == \"start\"\n                    ? sel.from\n                    : p == \"end\"\n                        ? sel.to\n                        : null;\n        if (offset == null)\n            throw new Error(\"Invalid cursor type\");\n        return this.posFromIndex(offset);\n    }\n    ;\n    listSelections() {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.selection.ranges.map(r => {\n            return {\n                anchor: posFromIndex(doc, r.anchor),\n                head: posFromIndex(doc, r.head),\n            };\n        });\n    }\n    ;\n    setSelections(p, primIndex) {\n        var doc = this.cm6.state.doc;\n        var ranges = p.map(x => {\n            return EditorSelection.range(indexFromPos(doc, x.anchor), indexFromPos(doc, x.head));\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, primIndex)\n        });\n    }\n    ;\n    setSelection(anchor, head, options) {\n        var doc = this.cm6.state.doc;\n        var ranges = [EditorSelection.range(indexFromPos(doc, anchor), indexFromPos(doc, head))];\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, 0)\n        });\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    }\n    ;\n    getLine(row) {\n        var doc = this.cm6.state.doc;\n        if (row < 0 || row >= doc.lines)\n            return \"\";\n        return this.cm6.state.doc.line(row + 1).text;\n    }\n    ;\n    getLineHandle(row) {\n        return { text: this.getLine(row), row: row };\n    }\n    getLineNumber(handle) {\n        return handle.row;\n    }\n    getRange(s, e) {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.sliceDoc(indexFromPos(doc, s), indexFromPos(doc, e));\n    }\n    ;\n    replaceRange(text, s, e) {\n        if (!e)\n            e = s;\n        var doc = this.cm6.state.doc;\n        var from = indexFromPos(doc, s);\n        var to = indexFromPos(doc, e);\n        dispatchChange(this, { changes: { from, to, insert: text } });\n    }\n    ;\n    replaceSelection(text) {\n        dispatchChange(this, this.cm6.state.replaceSelection(text));\n    }\n    ;\n    replaceSelections(replacements) {\n        var ranges = this.cm6.state.selection.ranges;\n        var changes = ranges.map((r, i) => {\n            return { from: r.from, to: r.to, insert: replacements[i] || \"\" };\n        });\n        dispatchChange(this, { changes });\n    }\n    ;\n    getSelection() {\n        return this.getSelections().join(\"\\n\");\n    }\n    ;\n    getSelections() {\n        var cm = this.cm6;\n        return cm.state.selection.ranges.map(r => cm.state.sliceDoc(r.from, r.to));\n    }\n    ;\n    somethingSelected() {\n        return this.cm6.state.selection.ranges.some(r => !r.empty);\n    }\n    ;\n    getInputField() {\n        return this.cm6.contentDOM;\n    }\n    ;\n    clipPos(p) {\n        var doc = this.cm6.state.doc;\n        var ch = p.ch;\n        var lineNumber = p.line + 1;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            ch = 0;\n        }\n        if (lineNumber > doc.lines) {\n            lineNumber = doc.lines;\n            ch = Number.MAX_VALUE;\n        }\n        var line = doc.line(lineNumber);\n        ch = Math.min(Math.max(0, ch), line.to - line.from);\n        return new Pos(lineNumber - 1, ch);\n    }\n    ;\n    getValue() {\n        return this.cm6.state.doc.toString();\n    }\n    ;\n    setValue(text) {\n        var cm = this.cm6;\n        return cm.dispatch({\n            changes: { from: 0, to: cm.state.doc.length, insert: text },\n            selection: EditorSelection.range(0, 0)\n        });\n    }\n    ;\n    focus() {\n        return this.cm6.focus();\n    }\n    ;\n    blur() {\n        return this.cm6.contentDOM.blur();\n    }\n    ;\n    defaultTextHeight() {\n        return this.cm6.defaultLineHeight;\n    }\n    ;\n    findMatchingBracket(pos) {\n        var state = this.cm6.state;\n        var offset = indexFromPos(state.doc, pos);\n        var m = matchBrackets(state, offset + 1, -1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        m = matchBrackets(state, offset, 1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        return { to: undefined };\n    }\n    ;\n    scanForBracket(pos, dir, style, config) {\n        return scanForBracket(this, pos, dir, style, config);\n    }\n    ;\n    indentLine(line, more) {\n        // todo how to indent only one line instead of selection\n        if (more)\n            this.indentMore();\n        else\n            this.indentLess();\n    }\n    ;\n    indentMore() {\n        indentMore(this.cm6);\n    }\n    ;\n    indentLess() {\n        indentLess(this.cm6);\n    }\n    ;\n    execCommand(name) {\n        if (name == \"indentAuto\")\n            CodeMirror.commands.indentAuto(this);\n        else if (name == \"goLineLeft\")\n            cursorLineBoundaryBackward(this.cm6);\n        else if (name == \"goLineRight\") {\n            cursorLineBoundaryForward(this.cm6);\n            cursorCharBackward(this.cm6);\n        }\n        else\n            console.log(name + \" is not implemented\");\n    }\n    ;\n    setBookmark(cursor, options) {\n        var assoc = (options === null || options === void 0 ? void 0 : options.insertLeft) ? 1 : -1;\n        var offset = this.indexFromPos(cursor);\n        var bm = new Marker(this, offset, assoc);\n        return bm;\n    }\n    ;\n    addOverlay({ query }) {\n        let cm6Query = new SearchQuery({\n            regexp: true,\n            search: query.source,\n            caseSensitive: !/i/.test(query.flags),\n        });\n        if (cm6Query.valid) {\n            cm6Query.forVim = true;\n            this.cm6Query = cm6Query;\n            let effect = setSearchQuery.of(cm6Query);\n            this.cm6.dispatch({ effects: effect });\n            return cm6Query;\n        }\n    }\n    ;\n    removeOverlay(overlay) {\n        if (!this.cm6Query)\n            return;\n        this.cm6Query.forVim = false;\n        let effect = setSearchQuery.of(this.cm6Query);\n        this.cm6.dispatch({ effects: effect });\n    }\n    ;\n    getSearchCursor(query, pos) {\n        var cm = this;\n        var last = null;\n        var lastCM5Result = null;\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var firstOffset = indexFromPos(cm.cm6.state.doc, pos);\n        var source = query.source.replace(/(\\\\.|{(?:\\d+(?:,\\d*)?|,\\d+)})|[{}]/g, function (a, b) {\n            if (!b)\n                return \"\\\\\" + a;\n            return b;\n        });\n        function rCursor(doc, from = 0, to = doc.length) {\n            return new RegExpCursor(doc, source, { ignoreCase: query.ignoreCase }, from, to);\n        }\n        function nextMatch(from) {\n            var doc = cm.cm6.state.doc;\n            if (from > doc.length)\n                return null;\n            let res = rCursor(doc, from).next();\n            return res.done ? null : res.value;\n        }\n        var ChunkSize = 10000;\n        function prevMatchInRange(from, to) {\n            var doc = cm.cm6.state.doc;\n            for (let size = 1;; size++) {\n                let start = Math.max(from, to - size * ChunkSize);\n                let cursor = rCursor(doc, start, to), range = null;\n                while (!cursor.next().done)\n                    range = cursor.value;\n                if (range && (start == from || range.from > start + 10))\n                    return range;\n                if (start == from)\n                    return null;\n            }\n        }\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                var doc = cm.cm6.state.doc;\n                if (back) {\n                    let endAt = last ? (last.from == last.to ? last.to - 1 : last.from) : firstOffset;\n                    last = prevMatchInRange(0, endAt);\n                }\n                else {\n                    let startFrom = last ? (last.from == last.to ? last.to + 1 : last.to) : firstOffset;\n                    last = nextMatch(startFrom);\n                }\n                lastCM5Result = last && {\n                    from: posFromIndex(doc, last.from),\n                    to: posFromIndex(doc, last.to),\n                    match: last.match,\n                };\n                return last && last.match;\n            },\n            from: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from; },\n            to: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to; },\n            replace: function (text) {\n                if (last) {\n                    dispatchChange(cm, {\n                        changes: { from: last.from, to: last.to, insert: text }\n                    });\n                    last.to = last.from + text.length;\n                    if (lastCM5Result) {\n                        lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);\n                    }\n                }\n            }\n        };\n    }\n    ;\n    findPosV(start, amount, unit, goalColumn) {\n        let { cm6 } = this;\n        const doc = cm6.state.doc;\n        let pixels = unit == 'page' ? cm6.dom.clientHeight : 0;\n        const startOffset = indexFromPos(doc, start);\n        let range = EditorSelection.range(startOffset, startOffset, goalColumn);\n        let count = Math.round(Math.abs(amount));\n        for (let i = 0; i < count; i++) {\n            if (unit == 'page') {\n                range = cm6.moveVertically(range, amount > 0, pixels);\n            }\n            else if (unit == 'line') {\n                range = cm6.moveVertically(range, amount > 0);\n            }\n        }\n        let pos = posFromIndex(doc, range.head);\n        // set hitside to true if there was no place to move and cursor was clipped to the edge\n        // of document. Needed for gj/gk\n        if ((amount < 0 &&\n            range.head == 0 && goalColumn != 0 &&\n            start.line == 0 && start.ch != 0) || (amount > 0 &&\n            range.head == doc.length && pos.ch != goalColumn\n            && start.line == pos.line)) {\n            pos.hitSide = true;\n        }\n        return pos;\n    }\n    ;\n    charCoords(pos, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = indexFromPos(this.cm6.state.doc, pos);\n        var coords = this.cm6.coordsAtPos(offset);\n        var d = -rect.top;\n        return { left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left, top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d, bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d };\n    }\n    ;\n    coordsChar(coords, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = this.cm6.posAtCoords({ x: coords.left + rect.left, y: coords.top + rect.top }) || 0;\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    getScrollInfo() {\n        var scroller = this.cm6.scrollDOM;\n        return {\n            left: scroller.scrollLeft, top: scroller.scrollTop,\n            height: scroller.scrollHeight,\n            width: scroller.scrollWidth,\n            clientHeight: scroller.clientHeight, clientWidth: scroller.clientWidth\n        };\n    }\n    ;\n    scrollTo(x, y) {\n        if (x != null)\n            this.cm6.scrollDOM.scrollLeft = x;\n        if (y != null)\n            this.cm6.scrollDOM.scrollTop = y;\n    }\n    ;\n    scrollIntoView(pos, margin) {\n        if (pos) {\n            var offset = this.indexFromPos(pos);\n            this.cm6.dispatch({\n                effects: EditorView.scrollIntoView(offset)\n            });\n        }\n        else {\n            this.cm6.dispatch({ scrollIntoView: true, userEvent: \"scroll\" });\n        }\n    }\n    ;\n    getWrapperElement() {\n        return this.cm6.dom;\n    }\n    ;\n    // for tests\n    getMode() {\n        return { name: this.getOption(\"mode\") };\n    }\n    ;\n    setSize(w, h) {\n        this.cm6.dom.style.width = w + 4 + \"px\";\n        this.cm6.dom.style.height = h + \"px\";\n        this.refresh();\n    }\n    refresh() {\n        this.cm6.measure();\n    }\n    // event listeners\n    destroy() {\n        this.removeOverlay();\n    }\n    ;\n    onChange(update) {\n        for (let i in this.marks) {\n            let m = this.marks[i];\n            m.update(update.changes);\n        }\n        if (this.virtualSelection) {\n            this.virtualSelection.ranges = this.virtualSelection.ranges.map(range => range.map(update.changes));\n        }\n        var curOp = this.curOp = this.curOp || {};\n        update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n            if (curOp.$changeStart == null || curOp.$changeStart > fromB)\n                curOp.$changeStart = fromB;\n            this.$lastChangeEndOffset = toB;\n            var change = { text: text.toJSON() };\n            if (!curOp.lastChange) {\n                curOp.lastChange = curOp.change = change;\n            }\n            else {\n                curOp.lastChange.next = curOp.lastChange = change;\n            }\n        }, true);\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._handlers[\"change\"] && this._handlers[\"change\"].slice();\n    }\n    ;\n    onSelectionChange() {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._handlers[\"cursorActivity\"] && this._handlers[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n    }\n    ;\n    operation(fn) {\n        if (!this.curOp)\n            this.curOp = { $d: 0 };\n        this.curOp.$d++;\n        try {\n            var result = fn();\n        }\n        finally {\n            if (this.curOp) {\n                this.curOp.$d--;\n                if (!this.curOp.$d)\n                    this.onBeforeEndOperation();\n            }\n        }\n        return result;\n    }\n    ;\n    onBeforeEndOperation() {\n        var op = this.curOp;\n        var scrollIntoView = false;\n        if (op) {\n            if (op.change) {\n                signalTo(op.changeHandlers, this, op.change);\n            }\n            if (op && op.cursorActivity) {\n                signalTo(op.cursorActivityHandlers, this, null);\n                if (op.isVimOp)\n                    scrollIntoView = true;\n            }\n            this.curOp = null;\n        }\n        if (scrollIntoView)\n            this.scrollIntoView();\n    }\n    ;\n    moveH(increment, unit) {\n        if (unit == 'char') {\n            // todo\n            var cur = this.getCursor();\n            this.setCursor(cur.line, cur.ch + increment);\n        }\n    }\n    ;\n    setOption(name, val) {\n        switch (name) {\n            case \"keyMap\":\n                this.state.keyMap = val;\n                break;\n        }\n    }\n    ;\n    getOption(name) {\n        switch (name) {\n            case \"firstLineNumber\": return 1;\n            case \"tabSize\": return this.cm6.state.tabSize || 4;\n            case \"readonly\": return this.cm6.state.readOnly;\n            case \"indentWithTabs\": return this.cm6.state.facet(indentUnit) == \"\\t\"; // TODO\n            case \"indentUnit\": return this.cm6.state.facet(indentUnit).length || 2;\n            // for tests\n            case \"keyMap\": return this.state.keyMap || \"vim\";\n        }\n    }\n    ;\n    toggleOverwrite(on) {\n        this.state.overwrite = on;\n    }\n    ;\n    getTokenTypeAt(pos) {\n        var _a;\n        // only comment|string are needed\n        var offset = this.indexFromPos(pos);\n        var tree = ensureSyntaxTree(this.cm6.state, offset);\n        var node = tree === null || tree === void 0 ? void 0 : tree.resolve(offset);\n        var type = ((_a = node === null || node === void 0 ? void 0 : node.type) === null || _a === void 0 ? void 0 : _a.name) || \"\";\n        if (/comment/i.test(type))\n            return \"comment\";\n        if (/string/i.test(type))\n            return \"string\";\n        return \"\";\n    }\n    ;\n    overWriteSelection(text) {\n        var doc = this.cm6.state.doc;\n        var sel = this.cm6.state.selection;\n        var ranges = sel.ranges.map(x => {\n            if (x.empty) {\n                var ch = x.to < doc.length ? doc.sliceString(x.from, x.to + 1) : \"\";\n                if (ch && !/\\n/.test(ch))\n                    return EditorSelection.range(x.from, x.to + 1);\n            }\n            return x;\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, sel.mainIndex)\n        });\n        this.replaceSelection(text);\n    }\n    /*** multiselect ****/\n    isInMultiSelectMode() {\n        return this.cm6.state.selection.ranges.length > 1;\n    }\n    virtualSelectionMode() {\n        return !!this.virtualSelection;\n    }\n    forEachSelection(command) {\n        var selection = this.cm6.state.selection;\n        this.virtualSelection = EditorSelection.create(selection.ranges, selection.mainIndex);\n        for (var i = 0; i < this.virtualSelection.ranges.length; i++) {\n            var range = this.virtualSelection.ranges[i];\n            if (!range)\n                continue;\n            this.cm6.dispatch({ selection: EditorSelection.create([range]) });\n            command();\n            this.virtualSelection.ranges[i] = this.cm6.state.selection.ranges[0];\n        }\n        this.cm6.dispatch({ selection: this.virtualSelection });\n        this.virtualSelection = null;\n    }\n}\n// --------------------------\nCodeMirror.Pos = Pos;\nCodeMirror.StringStream = StringStream;\nCodeMirror.commands = {\n    cursorCharLeft: function (cm) { cursorCharLeft(cm.cm6); },\n    redo: function (cm) { runHistoryCommand(cm, false); },\n    undo: function (cm) { runHistoryCommand(cm, true); },\n    newlineAndIndent: function (cm) {\n        insertNewlineAndIndent({\n            state: cm.cm6.state,\n            dispatch: (tr) => {\n                return dispatchChange(cm, tr);\n            }\n        });\n    },\n    indentAuto: function (cm) {\n        indentSelection(cm.cm6);\n    }\n};\nCodeMirror.defineOption = function (name, val, setter) { };\nCodeMirror.isWordChar = function (ch) {\n    return wordChar.test(ch);\n};\nCodeMirror.keys = {\n    Backspace: function (cm) {\n        deleteCharBackward(cm.cm6);\n    },\n    Delete: function (cm) {\n        deleteCharForward(cm.cm6);\n    }\n};\nCodeMirror.keyMap = {};\nCodeMirror.addClass = function () { };\nCodeMirror.rmClass = function () { };\nCodeMirror.e_preventDefault = function (e) {\n    e.preventDefault();\n};\nCodeMirror.e_stop = function (e) {\n    var _a, _b;\n    (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);\n    (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);\n};\nCodeMirror.keyName = function (e) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key == \"Escape\")\n        key = \"Esc\";\n    if (key == \" \")\n        key = \"Space\";\n    if (key.length > 1) {\n        key = key.replace(/Numpad|Arrow/, \"\");\n    }\n    if (key.length == 1)\n        key = key.toUpperCase();\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'Ctrl-';\n    }\n    if (e.altKey) {\n        name += 'Alt-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'Shift-';\n    }\n    name += key;\n    return name;\n};\nCodeMirror.vimKey = function vimKey(e) {\n    var key = e.key;\n    if (ignoredKeys[key])\n        return;\n    if (key.length > 1 && key[0] == \"n\") {\n        key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n        name += 'C-';\n    }\n    if (e.altKey) {\n        name += 'A-';\n    }\n    if (e.metaKey) {\n        name += 'M-';\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n        name += 'S-';\n    }\n    name += key;\n    if (name.length > 1) {\n        name = '<' + name + '>';\n    }\n    return name;\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    var result = CodeMirror.keys[key];\n    if (result)\n        handle(result);\n};\nCodeMirror.on = on;\nCodeMirror.off = off;\nCodeMirror.signal = signal;\nCodeMirror.findMatchingTag = findMatchingTag;\nCodeMirror.findEnclosingTag = findEnclosingTag;\n/************* dialog *************/\nfunction dialogDiv(cm, template, bottom) {\n    var dialog = document.createElement(\"div\");\n    dialog.appendChild(template);\n    return dialog;\n}\nfunction closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n        cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n}\nfunction openNotification(cm, template, options) {\n    closeNotification(cm, close);\n    var dialog = dialogDiv(cm, template, options && options.bottom);\n    var closed = false;\n    var doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n    function close() {\n        if (closed)\n            return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n        hideDialog(cm, dialog);\n    }\n    dialog.onclick = function (e) {\n        e.preventDefault();\n        close();\n    };\n    showDialog(cm, dialog);\n    if (duration)\n        doneTimer = setTimeout(close, duration);\n    return close;\n}\nfunction showDialog(cm, dialog) {\n    var oldDialog = cm.state.dialog;\n    cm.state.dialog = dialog;\n    if (dialog && oldDialog !== dialog) {\n        if (oldDialog && oldDialog.contains(document.activeElement))\n            cm.focus();\n        if (oldDialog && oldDialog.parentElement) {\n            oldDialog.parentElement.replaceChild(dialog, oldDialog);\n        }\n        else if (oldDialog) {\n            oldDialog.remove();\n        }\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction hideDialog(cm, dialog) {\n    if (cm.state.dialog == dialog) {\n        cm.state.dialog = null;\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction openDialog(me, template, callback, options) {\n    if (!options)\n        options = {};\n    closeNotification(me, undefined);\n    var dialog = dialogDiv(me, template, options.bottom);\n    var closed = false;\n    showDialog(me, dialog);\n    function close(newVal) {\n        if (typeof newVal == 'string') {\n            inp.value = newVal;\n        }\n        else {\n            if (closed)\n                return;\n            closed = true;\n            hideDialog(me, dialog);\n            if (!me.state.dialog)\n                me.focus();\n            if (options.onClose)\n                options.onClose(dialog);\n        }\n    }\n    var inp = dialog.getElementsByTagName(\"input\")[0];\n    if (inp) {\n        if (options.value) {\n            inp.value = options.value;\n            if (options.selectValueOnOpen !== false)\n                inp.select();\n        }\n        if (options.onInput)\n            CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n        if (options.onKeyUp)\n            CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                return;\n            }\n            if (e.keyCode == 13)\n                callback(inp.value);\n            if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                inp.blur();\n                CodeMirror.e_stop(e);\n                close();\n            }\n        });\n        if (options.closeOnBlur !== false)\n            CodeMirror.on(inp, \"blur\", function () {\n                setTimeout(function () {\n                    if (document.activeElement === inp)\n                        return;\n                    close();\n                });\n            });\n        inp.focus();\n    }\n    return close;\n}\nvar matching = { \"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\" };\nfunction bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/;\n}\nfunction scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n    var stack = [];\n    var re = bracketRegex(config);\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n        : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n            continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n            continue;\n        if (lineNo == where.line)\n            pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end; pos += dir) {\n            var ch = line.charAt(pos);\n            if (re.test(ch) /*&& (style === undefined ||\n                                (cm.getTokenTypeAt(new Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))*/) {\n                var match = matching[ch];\n                if (match && (match.charAt(1) == \">\") == (dir > 0))\n                    stack.push(ch);\n                else if (!stack.length)\n                    return { pos: new Pos(lineNo, pos), ch: ch };\n                else\n                    stack.pop();\n            }\n        }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n}\nfunction findMatchingTag(cm, pos) {\n    var state = cm.cm6.state;\n    var offset = cm.indexFromPos(pos);\n    var m = matchBrackets(state, offset + 1, -1, { brackets: \"\\n\\n\" });\n    if (m) {\n        if (!m.end || !m.start)\n            return;\n        return {\n            open: convertRange(state.doc, m.end),\n            close: convertRange(state.doc, m.start),\n        };\n    }\n    m = matchBrackets(state, offset, 1, { brackets: \"\\n\\n\" });\n    if (m) {\n        if (!m.end || !m.start)\n            return;\n        return {\n            open: convertRange(state.doc, m.start),\n            close: convertRange(state.doc, m.end),\n        };\n    }\n}\nfunction convertRange(doc, cm6Range) {\n    return {\n        from: posFromIndex(doc, cm6Range.from),\n        to: posFromIndex(doc, cm6Range.to)\n    };\n}\nfunction findEnclosingTag(cm, pos) {\n    var state = cm.cm6.state;\n    var offset = cm.indexFromPos(pos);\n    var text = state.sliceDoc(0, offset);\n    var i = offset;\n    while (i > 0) {\n        var m = matchBrackets(state, i, 1, { brackets: \"\\n\\n\" });\n        if (m && m.start && m.end) {\n            return {\n                open: convertRange(state.doc, m.start),\n                close: convertRange(state.doc, m.end),\n            };\n        }\n        i = text.lastIndexOf(\">\", i - 1);\n    }\n}\nclass Marker {\n    constructor(cm, offset, assoc) {\n        this.cm = cm;\n        this.id = cm.$mid++;\n        this.offset = offset;\n        this.assoc = assoc;\n        cm.marks[this.id] = this;\n    }\n    ;\n    clear() { delete this.cm.marks[this.id]; }\n    ;\n    find() {\n        if (this.offset == null)\n            return null;\n        return this.cm.posFromIndex(this.offset);\n    }\n    ;\n    update(change) {\n        if (this.offset != null)\n            this.offset = change.mapPos(this.offset, this.assoc, MapMode.TrackDel);\n    }\n}\n\nclass Piece {\n    constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {\n        this.left = left;\n        this.top = top;\n        this.height = height;\n        this.fontFamily = fontFamily;\n        this.fontSize = fontSize;\n        this.fontWeight = fontWeight;\n        this.color = color;\n        this.className = className;\n        this.letter = letter;\n        this.partial = partial;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        elt.style.height = this.height + \"px\";\n        elt.style.lineHeight = this.height + \"px\";\n        elt.style.fontFamily = this.fontFamily;\n        elt.style.fontSize = this.fontSize;\n        elt.style.fontWeight = this.fontWeight;\n        elt.style.color = this.partial ? \"transparent\" : this.color;\n        elt.className = this.className;\n        elt.textContent = this.letter;\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.height == p.height &&\n            this.fontFamily == p.fontFamily && this.fontSize == p.fontSize &&\n            this.fontWeight == p.fontWeight && this.color == p.color &&\n            this.className == p.className &&\n            this.letter == p.letter;\n    }\n}\nclass BlockCursorPlugin {\n    constructor(view, cm) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.cm = cm;\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = \"cm-cursorLayer cm-vimCursorLayer\";\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        this.cursorLayer.style.animationDuration = 1200 + \"ms\";\n    }\n    update(update) {\n        if (update.selectionSet || update.geometryChanged || update.viewportChanged) {\n            this.view.requestMeasure(this.measureReq);\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        }\n    }\n    scheduleRedraw() {\n        this.view.requestMeasure(this.measureReq);\n    }\n    readPos() {\n        let { state } = this.view;\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            let piece = measureCursor(this.cm, this.view, r, prim);\n            if (piece)\n                cursors.push(piece);\n        }\n        return { cursors };\n    }\n    drawSel({ cursors }) {\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            let oldCursors = this.cursorLayer.children;\n            if (oldCursors.length !== cursors.length) {\n                this.cursorLayer.textContent = \"\";\n                for (const c of cursors)\n                    this.cursorLayer.appendChild(c.draw());\n            }\n            else {\n                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n            }\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.cursorLayer.remove();\n    }\n}\nconst themeSpec = {\n    \".cm-vimMode .cm-line\": {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" },\n        caretColor: \"transparent !important\",\n    },\n    \".cm-fat-cursor\": {\n        position: \"absolute\",\n        background: \"#ff9696\",\n        border: \"none\",\n        whiteSpace: \"pre\",\n    },\n    \"&:not(.cm-focused) .cm-fat-cursor\": {\n        background: \"none\",\n        outline: \"solid 1px #ff9696\"\n    },\n};\nconst hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\n}\nfunction measureCursor(cm, view, cursor, primary) {\n    let head = cursor.head;\n    let fatCursor = false;\n    let hCoeff = 1;\n    let vim = cm.state.vim;\n    if (vim && (!vim.insertMode || cm.state.overwrite)) {\n        fatCursor = true;\n        if (vim.visualBlock && !primary)\n            return null;\n        if (cursor.anchor < cursor.head)\n            head--;\n        if (cm.state.overwrite)\n            hCoeff = 0.2;\n        else if (vim.status)\n            hCoeff = 0.5;\n    }\n    if (fatCursor) {\n        let pos = view.coordsAtPos(head, cursor.assoc || 1);\n        if (!pos)\n            return null;\n        let base = getBase(view);\n        let domAtPos = view.domAtPos(head);\n        let node = domAtPos ? domAtPos.node : view.contentDOM;\n        while (domAtPos && domAtPos.node instanceof HTMLElement) {\n            node = domAtPos.node;\n            domAtPos = { node: domAtPos.node.childNodes[domAtPos.offset], offset: 0 };\n        }\n        if (!(node instanceof HTMLElement)) {\n            node = node.parentNode;\n        }\n        let style = getComputedStyle(node);\n        let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);\n        if (!letter || letter == \"\\n\" || letter == \"\\r\")\n            letter = \"\\xa0\";\n        let h = (pos.bottom - pos.top);\n        return new Piece(pos.left - base.left, pos.top - base.top + h * (1 - hCoeff), h * hCoeff, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? \"cm-fat-cursor cm-cursor-primary\" : \"cm-fat-cursor cm-cursor-secondary\", letter, hCoeff != 1);\n    }\n    else {\n        return null;\n    }\n}\n\nconst Vim = /*@__PURE__*/initVim(CodeMirror);\nconst HighlightMargin = 250;\nconst vimStyle = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)\": {\n        display: \"none\",\n    },\n    \".cm-vim-panel\": {\n        padding: \"0px 10px\",\n        fontFamily: \"monospace\",\n        minHeight: \"1.3em\",\n    },\n    \".cm-vim-panel input\": {\n        border: \"none\",\n        outline: \"none\",\n        backgroundColor: \"inherit\",\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n});\nconst vimPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.status = \"\";\n        this.query = null;\n        this.decorations = Decoration.none;\n        this.view = view;\n        const cm = (this.cm = new CodeMirror(view));\n        Vim.enterVimMode(this.cm);\n        this.view.cm = this.cm;\n        this.cm.state.vimPlugin = this;\n        this.blockCursor = new BlockCursorPlugin(view, cm);\n        this.updateClass();\n        this.cm.on(\"vim-command-done\", () => {\n            if (cm.state.vim)\n                cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateStatus();\n        });\n        this.cm.on(\"vim-mode-change\", (e) => {\n            cm.state.vim.mode = e.mode;\n            if (e.subMode) {\n                cm.state.vim.mode += \" block\";\n            }\n            cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateClass();\n            this.updateStatus();\n        });\n        this.cm.on(\"dialog\", () => {\n            if (this.cm.state.statusbar) {\n                this.updateStatus();\n            }\n            else {\n                view.dispatch({\n                    effects: showVimPanel.of(!!this.cm.state.dialog),\n                });\n            }\n        });\n        this.dom = document.createElement(\"span\");\n        this.dom.style.cssText = \"position: absolute; right: 10px; top: 1px\";\n    }\n    update(update) {\n        var _a;\n        if ((update.viewportChanged || update.docChanged) && this.query) {\n            this.highlight(this.query);\n        }\n        if (update.docChanged) {\n            this.cm.onChange(update);\n        }\n        if (update.selectionSet) {\n            this.cm.onSelectionChange();\n        }\n        if (update.viewportChanged) ;\n        if (this.cm.curOp && !this.cm.curOp.isVimOp) {\n            this.cm.onBeforeEndOperation();\n        }\n        if (update.transactions) {\n            for (let tr of update.transactions)\n                for (let effect of tr.effects) {\n                    if (effect.is(setSearchQuery)) {\n                        let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;\n                        if (!forVim) {\n                            this.highlight(null);\n                        }\n                        else {\n                            let query = effect.value.create();\n                            this.highlight(query);\n                        }\n                    }\n                }\n        }\n        this.blockCursor.update(update);\n    }\n    updateClass() {\n        const state = this.cm.state;\n        if (!state.vim || (state.vim.insertMode && !state.overwrite))\n            this.view.scrollDOM.classList.remove(\"cm-vimMode\");\n        else\n            this.view.scrollDOM.classList.add(\"cm-vimMode\");\n    }\n    updateStatus() {\n        let dom = this.cm.state.statusbar;\n        if (!dom)\n            return;\n        let dialog = this.cm.state.dialog;\n        let vim = this.cm.state.vim;\n        if (dialog) {\n            if (dialog.parentElement != dom) {\n                dom.textContent = \"\";\n                dom.appendChild(dialog);\n            }\n        }\n        else {\n            dom.textContent = `--${(vim.mode || \"normal\").toUpperCase()}--`;\n        }\n        this.dom.textContent = vim.status;\n        dom.appendChild(this.dom);\n    }\n    destroy() {\n        this.cm.state.vim = null;\n        this.updateClass();\n        this.blockCursor.destroy();\n        delete this.view.cm;\n    }\n    highlight(query) {\n        this.query = query;\n        if (!query)\n            return (this.decorations = Decoration.none);\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * HighlightMargin)\n                to = ranges[++i].to;\n            query.highlight(view.state.doc, from, to, (from, to) => {\n                builder.add(from, to, matchMark);\n            });\n        }\n        return (this.decorations = builder.finish());\n    }\n}, {\n    eventHandlers: {\n        keydown: function (e, view) {\n            const key = CodeMirror.vimKey(e);\n            const cm = this.cm;\n            if (!key)\n                return;\n            // clear search highlight\n            let vim = cm.state.vim;\n            if (key == \"<Esc>\" &&\n                !vim.insertMode &&\n                !vim.visualMode &&\n                this.query /* && !cm.inMultiSelectMode*/) {\n                const searchState = vim.searchState_;\n                if (searchState) {\n                    cm.removeOverlay(searchState.getOverlay());\n                    searchState.setOverlay(null);\n                }\n            }\n            cm.state.vim.status = (cm.state.vim.status || \"\") + key;\n            let result = Vim.multiSelectHandleKey(cm, key, \"user\");\n            // insert mode\n            if (!result && cm.state.vim.insertMode && cm.state.overwrite) {\n                if (e.key && e.key.length == 1 && !/\\n/.test(e.key)) {\n                    result = true;\n                    cm.overWriteSelection(e.key);\n                }\n                else if (e.key == \"Backspace\") {\n                    result = true;\n                    CodeMirror.commands.cursorCharLeft(cm);\n                }\n            }\n            if (result) {\n                CodeMirror.signal(this.cm, 'vim-keypress', key);\n                e.preventDefault();\n                e.stopPropagation();\n                this.blockCursor.scheduleRedraw();\n            }\n            this.updateStatus();\n            return !!result;\n        },\n    },\n    decorations: (v) => v.decorations,\n});\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" });\nconst showVimPanel = /*@__PURE__*/StateEffect.define();\nconst vimPanelState = /*@__PURE__*/StateField.define({\n    create: () => false,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(showVimPanel))\n                value = e.value;\n        return value;\n    },\n    provide: (f) => {\n        return showPanel.from(f, (on) => (on ? createVimPanel : null));\n    },\n});\nfunction createVimPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    if (cm.state.dialog) {\n        dom.appendChild(cm.state.dialog);\n    }\n    return { top: false, dom };\n}\nfunction statusPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    cm.state.statusbar = dom;\n    cm.state.vimPlugin.updateStatus();\n    return { dom };\n}\nfunction vim(options = {}) {\n    return [\n        vimStyle,\n        vimPlugin,\n        hideNativeSelection,\n        options.status ? showPanel.of(statusPanel) : vimPanelState,\n    ];\n}\nfunction getCM(view) {\n    return view.cm || null;\n}\n\nexport { CodeMirror, Vim, getCM, vim };\n", "import { LanguageDescription, LanguageSupport, StreamLanguage } from '@codemirror/language';\n\nfunction legacy(parser) {\n    return new LanguageSupport(StreamLanguage.define(parser));\n}\nfunction sql(dialectName) {\n    return import('@codemirror/lang-sql').then(m => m.sql({ dialect: m[dialectName] }));\n}\n/**\nAn array of language descriptions for known language packages.\n*/\nconst languages = [\n    // New-style language modes\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"C\",\n        extensions: [\"c\", \"h\", \"ino\"],\n        load() {\n            return import('@codemirror/lang-cpp').then(m => m.cpp());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"C++\",\n        alias: [\"cpp\"],\n        extensions: [\"cpp\", \"c++\", \"cc\", \"cxx\", \"hpp\", \"h++\", \"hh\", \"hxx\"],\n        load() {\n            return import('@codemirror/lang-cpp').then(m => m.cpp());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"CQL\",\n        alias: [\"cassandra\"],\n        extensions: [\"cql\"],\n        load() { return sql(\"Cassandra\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"CSS\",\n        extensions: [\"css\"],\n        load() {\n            return import('@codemirror/lang-css').then(m => m.css());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"HTML\",\n        alias: [\"xhtml\"],\n        extensions: [\"html\", \"htm\", \"handlebars\", \"hbs\"],\n        load() {\n            return import('@codemirror/lang-html').then(m => m.html());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Java\",\n        extensions: [\"java\"],\n        load() {\n            return import('@codemirror/lang-java').then(m => m.java());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"JavaScript\",\n        alias: [\"ecmascript\", \"js\", \"node\"],\n        extensions: [\"js\", \"mjs\", \"cjs\"],\n        load() {\n            return import('@codemirror/lang-javascript').then(m => m.javascript());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"JSON\",\n        alias: [\"json5\"],\n        extensions: [\"json\", \"map\"],\n        load() {\n            return import('@codemirror/lang-json').then(m => m.json());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"JSX\",\n        extensions: [\"jsx\"],\n        load() {\n            return import('@codemirror/lang-javascript').then(m => m.javascript({ jsx: true }));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"MariaDB SQL\",\n        load() { return sql(\"MariaSQL\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Markdown\",\n        extensions: [\"md\", \"markdown\", \"mkd\"],\n        load() {\n            return import('@codemirror/lang-markdown').then(m => m.markdown());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"MS SQL\",\n        load() { return sql(\"MSSQL\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"MySQL\",\n        load() { return sql(\"MySQL\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"PHP\",\n        extensions: [\"php\", \"php3\", \"php4\", \"php5\", \"php7\", \"phtml\"],\n        load() {\n            return import('@codemirror/lang-php').then(m => m.php());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"PLSQL\",\n        extensions: [\"pls\"],\n        load() { return sql(\"PLSQL\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"PostgreSQL\",\n        load() { return sql(\"PostgreSQL\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Python\",\n        extensions: [\"BUILD\", \"bzl\", \"py\", \"pyw\"],\n        filename: /^(BUCK|BUILD)$/,\n        load() {\n            return import('@codemirror/lang-python').then(m => m.python());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Rust\",\n        extensions: [\"rs\"],\n        load() {\n            return import('@codemirror/lang-rust').then(m => m.rust());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"SQL\",\n        extensions: [\"sql\"],\n        load() { return sql(\"StandardSQL\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"SQLite\",\n        load() { return sql(\"SQLite\"); }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"TSX\",\n        extensions: [\"tsx\"],\n        load() {\n            return import('@codemirror/lang-javascript').then(m => m.javascript({ jsx: true, typescript: true }));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"TypeScript\",\n        alias: [\"ts\"],\n        extensions: [\"ts\"],\n        load() {\n            return import('@codemirror/lang-javascript').then(m => m.javascript({ typescript: true }));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"WebAssembly\",\n        extensions: [\"wat\", \"wast\"],\n        load() {\n            return import('@codemirror/lang-wast').then(m => m.wast());\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"XML\",\n        alias: [\"rss\", \"wsdl\", \"xsd\"],\n        extensions: [\"xml\", \"xsl\", \"xsd\", \"svg\"],\n        load() {\n            return import('@codemirror/lang-xml').then(m => m.xml());\n        }\n    }),\n    // Legacy modes ported from CodeMirror 5\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"APL\",\n        extensions: [\"dyalog\", \"apl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/apl').then(m => legacy(m.apl));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"PGP\",\n        alias: [\"asciiarmor\"],\n        extensions: [\"asc\", \"pgp\", \"sig\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/asciiarmor').then(m => legacy(m.asciiArmor));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"ASN.1\",\n        extensions: [\"asn\", \"asn1\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/asn1').then(m => legacy(m.asn1({})));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Asterisk\",\n        filename: /^extensions\\.conf$/i,\n        load() {\n            return import('@codemirror/legacy-modes/mode/asterisk').then(m => legacy(m.asterisk));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Brainfuck\",\n        extensions: [\"b\", \"bf\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/brainfuck').then(m => legacy(m.brainfuck));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Cobol\",\n        extensions: [\"cob\", \"cpy\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/cobol').then(m => legacy(m.cobol));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"C#\",\n        alias: [\"csharp\", \"cs\"],\n        extensions: [\"cs\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clike').then(m => legacy(m.csharp));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Clojure\",\n        extensions: [\"clj\", \"cljc\", \"cljx\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clojure').then(m => legacy(m.clojure));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"ClojureScript\",\n        extensions: [\"cljs\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clojure').then(m => legacy(m.clojure));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Closure Stylesheets (GSS)\",\n        extensions: [\"gss\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/css').then(m => legacy(m.gss));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"CMake\",\n        extensions: [\"cmake\", \"cmake.in\"],\n        filename: /^CMakeLists\\.txt$/,\n        load() {\n            return import('@codemirror/legacy-modes/mode/cmake').then(m => legacy(m.cmake));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"CoffeeScript\",\n        alias: [\"coffee\", \"coffee-script\"],\n        extensions: [\"coffee\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/coffeescript').then(m => legacy(m.coffeeScript));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Common Lisp\",\n        alias: [\"lisp\"],\n        extensions: [\"cl\", \"lisp\", \"el\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/commonlisp').then(m => legacy(m.commonLisp));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Cypher\",\n        extensions: [\"cyp\", \"cypher\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/cypher').then(m => legacy(m.cypher));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Cython\",\n        extensions: [\"pyx\", \"pxd\", \"pxi\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/python').then(m => legacy(m.cython));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Crystal\",\n        extensions: [\"cr\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/crystal').then(m => legacy(m.crystal));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"D\",\n        extensions: [\"d\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/d').then(m => legacy(m.d));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Dart\",\n        extensions: [\"dart\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clike').then(m => legacy(m.dart));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"diff\",\n        extensions: [\"diff\", \"patch\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/diff').then(m => legacy(m.diff));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Dockerfile\",\n        filename: /^Dockerfile$/,\n        load() {\n            return import('@codemirror/legacy-modes/mode/dockerfile').then(m => legacy(m.dockerFile));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"DTD\",\n        extensions: [\"dtd\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/dtd').then(m => legacy(m.dtd));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Dylan\",\n        extensions: [\"dylan\", \"dyl\", \"intr\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/dylan').then(m => legacy(m.dylan));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"EBNF\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/ebnf').then(m => legacy(m.ebnf));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"ECL\",\n        extensions: [\"ecl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/ecl').then(m => legacy(m.ecl));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"edn\",\n        extensions: [\"edn\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clojure').then(m => legacy(m.clojure));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Eiffel\",\n        extensions: [\"e\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/eiffel').then(m => legacy(m.eiffel));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Elm\",\n        extensions: [\"elm\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/elm').then(m => legacy(m.elm));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Erlang\",\n        extensions: [\"erl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/erlang').then(m => legacy(m.erlang));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Esper\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/sql').then(m => legacy(m.esper));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Factor\",\n        extensions: [\"factor\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/factor').then(m => legacy(m.factor));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"FCL\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/fcl').then(m => legacy(m.fcl));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Forth\",\n        extensions: [\"forth\", \"fth\", \"4th\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/forth').then(m => legacy(m.forth));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Fortran\",\n        extensions: [\"f\", \"for\", \"f77\", \"f90\", \"f95\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/fortran').then(m => legacy(m.fortran));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"F#\",\n        alias: [\"fsharp\"],\n        extensions: [\"fs\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mllike').then(m => legacy(m.fSharp));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Gas\",\n        extensions: [\"s\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/gas').then(m => legacy(m.gas));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Gherkin\",\n        extensions: [\"feature\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/gherkin').then(m => legacy(m.gherkin));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Go\",\n        extensions: [\"go\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/go').then(m => legacy(m.go));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Groovy\",\n        extensions: [\"groovy\", \"gradle\"],\n        filename: /^Jenkinsfile$/,\n        load() {\n            return import('@codemirror/legacy-modes/mode/groovy').then(m => legacy(m.groovy));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Haskell\",\n        extensions: [\"hs\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/haskell').then(m => legacy(m.haskell));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Haxe\",\n        extensions: [\"hx\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/haxe').then(m => legacy(m.haxe));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"HXML\",\n        extensions: [\"hxml\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/haxe').then(m => legacy(m.hxml));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"HTTP\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/http').then(m => legacy(m.http));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"IDL\",\n        extensions: [\"pro\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/idl').then(m => legacy(m.idl));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"JSON-LD\",\n        alias: [\"jsonld\"],\n        extensions: [\"jsonld\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/javascript').then(m => legacy(m.jsonld));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Jinja2\",\n        extensions: [\"j2\", \"jinja\", \"jinja2\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/jinja2').then(m => legacy(m.jinja2));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Julia\",\n        extensions: [\"jl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/julia').then(m => legacy(m.julia));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Kotlin\",\n        extensions: [\"kt\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clike').then(m => legacy(m.kotlin));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"LESS\",\n        extensions: [\"less\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/css').then(m => legacy(m.less));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"LiveScript\",\n        alias: [\"ls\"],\n        extensions: [\"ls\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/livescript').then(m => legacy(m.liveScript));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Lua\",\n        extensions: [\"lua\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/lua').then(m => legacy(m.lua));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"mIRC\",\n        extensions: [\"mrc\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mirc').then(m => legacy(m.mirc));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Mathematica\",\n        extensions: [\"m\", \"nb\", \"wl\", \"wls\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mathematica').then(m => legacy(m.mathematica));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Modelica\",\n        extensions: [\"mo\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/modelica').then(m => legacy(m.modelica));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"MUMPS\",\n        extensions: [\"mps\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mumps').then(m => legacy(m.mumps));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Mbox\",\n        extensions: [\"mbox\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mbox').then(m => legacy(m.mbox));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Nginx\",\n        filename: /nginx.*\\.conf$/i,\n        load() {\n            return import('@codemirror/legacy-modes/mode/nginx').then(m => legacy(m.nginx));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"NSIS\",\n        extensions: [\"nsh\", \"nsi\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/nsis').then(m => legacy(m.nsis));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"NTriples\",\n        extensions: [\"nt\", \"nq\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/ntriples').then(m => legacy(m.ntriples));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Objective-C\",\n        alias: [\"objective-c\", \"objc\"],\n        extensions: [\"m\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clike').then(m => legacy(m.objectiveC));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Objective-C++\",\n        alias: [\"objective-c++\", \"objc++\"],\n        extensions: [\"mm\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clike').then(m => legacy(m.objectiveCpp));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"OCaml\",\n        extensions: [\"ml\", \"mli\", \"mll\", \"mly\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mllike').then(m => legacy(m.oCaml));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Octave\",\n        extensions: [\"m\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/octave').then(m => legacy(m.octave));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Oz\",\n        extensions: [\"oz\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/oz').then(m => legacy(m.oz));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Pascal\",\n        extensions: [\"p\", \"pas\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/pascal').then(m => legacy(m.pascal));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Perl\",\n        extensions: [\"pl\", \"pm\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/perl').then(m => legacy(m.perl));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Pig\",\n        extensions: [\"pig\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/pig').then(m => legacy(m.pig));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"PowerShell\",\n        extensions: [\"ps1\", \"psd1\", \"psm1\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/powershell').then(m => legacy(m.powerShell));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Properties files\",\n        alias: [\"ini\", \"properties\"],\n        extensions: [\"properties\", \"ini\", \"in\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/properties').then(m => legacy(m.properties));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"ProtoBuf\",\n        extensions: [\"proto\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/protobuf').then(m => legacy(m.protobuf));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Puppet\",\n        extensions: [\"pp\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/puppet').then(m => legacy(m.puppet));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Q\",\n        extensions: [\"q\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/q').then(m => legacy(m.q));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"R\",\n        alias: [\"rscript\"],\n        extensions: [\"r\", \"R\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/r').then(m => legacy(m.r));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"RPM Changes\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/rpm').then(m => legacy(m.rpmChanges));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"RPM Spec\",\n        extensions: [\"spec\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/rpm').then(m => legacy(m.rpmSpec));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Ruby\",\n        alias: [\"jruby\", \"macruby\", \"rake\", \"rb\", \"rbx\"],\n        extensions: [\"rb\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/ruby').then(m => legacy(m.ruby));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"SAS\",\n        extensions: [\"sas\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/sas').then(m => legacy(m.sas));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Sass\",\n        extensions: [\"sass\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/sass').then(m => legacy(m.sass));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Scala\",\n        extensions: [\"scala\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clike').then(m => legacy(m.scala));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Scheme\",\n        extensions: [\"scm\", \"ss\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/scheme').then(m => legacy(m.scheme));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"SCSS\",\n        extensions: [\"scss\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/css').then(m => legacy(m.sCSS));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Shell\",\n        alias: [\"bash\", \"sh\", \"zsh\"],\n        extensions: [\"sh\", \"ksh\", \"bash\"],\n        filename: /^PKGBUILD$/,\n        load() {\n            return import('@codemirror/legacy-modes/mode/shell').then(m => legacy(m.shell));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Sieve\",\n        extensions: [\"siv\", \"sieve\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/sieve').then(m => legacy(m.sieve));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Smalltalk\",\n        extensions: [\"st\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/smalltalk').then(m => legacy(m.smalltalk));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Solr\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/solr').then(m => legacy(m.solr));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"SML\",\n        extensions: [\"sml\", \"sig\", \"fun\", \"smackspec\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mllike').then(m => legacy(m.sml));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"SPARQL\",\n        alias: [\"sparul\"],\n        extensions: [\"rq\", \"sparql\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/sparql').then(m => legacy(m.sparql));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Spreadsheet\",\n        alias: [\"excel\", \"formula\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/spreadsheet').then(m => legacy(m.spreadsheet));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Squirrel\",\n        extensions: [\"nut\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/clike').then(m => legacy(m.squirrel));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Stylus\",\n        extensions: [\"styl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/stylus').then(m => legacy(m.stylus));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Swift\",\n        extensions: [\"swift\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/swift').then(m => legacy(m.swift));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"sTeX\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/stex').then(m => legacy(m.stex));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"LaTeX\",\n        alias: [\"tex\"],\n        extensions: [\"text\", \"ltx\", \"tex\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/stex').then(m => legacy(m.stex));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"SystemVerilog\",\n        extensions: [\"v\", \"sv\", \"svh\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/verilog').then(m => legacy(m.verilog));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Tcl\",\n        extensions: [\"tcl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/tcl').then(m => legacy(m.tcl));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Textile\",\n        extensions: [\"textile\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/textile').then(m => legacy(m.textile));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"TiddlyWiki\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/tiddlywiki').then(m => legacy(m.tiddlyWiki));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Tiki wiki\",\n        load() {\n            return import('@codemirror/legacy-modes/mode/tiki').then(m => legacy(m.tiki));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"TOML\",\n        extensions: [\"toml\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/toml').then(m => legacy(m.toml));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Troff\",\n        extensions: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/troff').then(m => legacy(m.troff));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"TTCN\",\n        extensions: [\"ttcn\", \"ttcn3\", \"ttcnpp\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/ttcn').then(m => legacy(m.ttcn));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"TTCN_CFG\",\n        extensions: [\"cfg\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/ttcn-cfg').then(m => legacy(m.ttcnCfg));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Turtle\",\n        extensions: [\"ttl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/turtle').then(m => legacy(m.turtle));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Web IDL\",\n        extensions: [\"webidl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/webidl').then(m => legacy(m.webIDL));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"VB.NET\",\n        extensions: [\"vb\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/vb').then(m => legacy(m.vb));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"VBScript\",\n        extensions: [\"vbs\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/vbscript').then(m => legacy(m.vbScript));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Velocity\",\n        extensions: [\"vtl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/velocity').then(m => legacy(m.velocity));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Verilog\",\n        extensions: [\"v\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/verilog').then(m => legacy(m.verilog));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"VHDL\",\n        extensions: [\"vhd\", \"vhdl\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/vhdl').then(m => legacy(m.vhdl));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"XQuery\",\n        extensions: [\"xy\", \"xquery\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/xquery').then(m => legacy(m.xQuery));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Yacas\",\n        extensions: [\"ys\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/yacas').then(m => legacy(m.yacas));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"YAML\",\n        alias: [\"yml\"],\n        extensions: [\"yaml\", \"yml\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/yaml').then(m => legacy(m.yaml));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"Z80\",\n        extensions: [\"z80\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/z80').then(m => legacy(m.z80));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"MscGen\",\n        extensions: [\"mscgen\", \"mscin\", \"msc\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mscgen').then(m => legacy(m.mscgen));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"X\u00F9\",\n        extensions: [\"xu\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mscgen').then(m => legacy(m.xu));\n        }\n    }),\n    /*@__PURE__*/LanguageDescription.of({\n        name: \"MsGenny\",\n        extensions: [\"msgenny\"],\n        load() {\n            return import('@codemirror/legacy-modes/mode/mscgen').then(m => legacy(m.msgenny));\n        }\n    })\n];\n\nexport { languages };\n", "import { sharedConfig as M, createRoot as Be, createRenderEffect as z, createSignal as D, onMount as me, onCleanup as Ne, createComponent as f, For as De, Show as x, createEffect as Ee, createContext as Te, useContext as He } from \"solid-js\";\nimport { EditorView as b, Decoration as C, WidgetType as he, ViewPlugin as je, keymap as ze } from \"@codemirror/view\";\nimport { closeBrackets as Ve, autocompletion as Oe } from \"@codemirror/autocomplete\";\nimport { StateField as Z, RangeSet as W, Compartment as Ie, EditorState as Q, EditorSelection as Re, SelectionRange as We, RangeSetBuilder as Fe, Transaction as Pe } from \"@codemirror/state\";\nimport { vim as Ue } from \"@replit/codemirror-vim\";\nimport { syntaxTree as J, syntaxHighlighting as qe, HighlightStyle as Xe } from \"@codemirror/language\";\nimport { defaultKeymap as Qe, historyKeymap as Ge, indentMore as Ke, indentLess as Ze, history as Je } from \"@codemirror/commands\";\nimport { markdown as Ye, markdownLanguage as et } from \"@codemirror/lang-markdown\";\nimport { languages as tt } from \"@codemirror/language-data\";\nimport { tags as d } from \"@lezer/highlight\";\nfunction nt(e, n, t) {\n  let o = t.length, r = n.length, a = o, l = 0, i = 0, s = n[r - 1].nextSibling, c = null;\n  for (; l < r || i < a; ) {\n    if (n[l] === t[i]) {\n      l++, i++;\n      continue;\n    }\n    for (; n[r - 1] === t[a - 1]; )\n      r--, a--;\n    if (r === l) {\n      const u = a < o ? i ? t[i - 1].nextSibling : t[a - i] : s;\n      for (; i < a; )\n        e.insertBefore(t[i++], u);\n    } else if (a === i)\n      for (; l < r; )\n        (!c || !c.has(n[l])) && n[l].remove(), l++;\n    else if (n[l] === t[a - 1] && t[i] === n[r - 1]) {\n      const u = n[--r].nextSibling;\n      e.insertBefore(t[i++], n[l++].nextSibling), e.insertBefore(t[--a], u), n[r] = t[a];\n    } else {\n      if (!c) {\n        c = /* @__PURE__ */ new Map();\n        let k = i;\n        for (; k < a; )\n          c.set(t[k], k++);\n      }\n      const u = c.get(n[l]);\n      if (u != null)\n        if (i < u && u < a) {\n          let k = l, L = 1, H;\n          for (; ++k < r && k < a && !((H = c.get(n[k])) == null || H !== u + L); )\n            L++;\n          if (L > u - i) {\n            const I = n[l];\n            for (; i < u; )\n              e.insertBefore(t[i++], I);\n          } else\n            e.replaceChild(t[i++], n[l++]);\n        } else\n          l++;\n      else\n        n[l++].remove();\n    }\n  }\n}\nconst le = \"_$DX_DELEGATE\";\nfunction ot(e, n, t) {\n  let o;\n  return Be((r) => {\n    o = r, n === document ? e() : p(n, e(), n.firstChild ? null : void 0, t);\n  }), () => {\n    o(), n.textContent = \"\";\n  };\n}\nfunction h(e, n, t) {\n  const o = document.createElement(\"template\");\n  o.innerHTML = e;\n  let r = o.content.firstChild;\n  return t && (r = r.firstChild), r;\n}\nfunction ke(e, n = window.document) {\n  const t = n[le] || (n[le] = /* @__PURE__ */ new Set());\n  for (let o = 0, r = e.length; o < r; o++) {\n    const a = e[o];\n    t.has(a) || (t.add(a), n.addEventListener(a, rt));\n  }\n}\nfunction se(e, n, t) {\n  t == null ? e.removeAttribute(n) : e.setAttribute(n, t);\n}\nfunction p(e, n, t, o) {\n  if (t !== void 0 && !o && (o = []), typeof n != \"function\")\n    return F(e, n, o, t);\n  z((r) => F(e, n(), r, t), o);\n}\nfunction rt(e) {\n  const n = `$$${e.type}`;\n  let t = e.composedPath && e.composedPath()[0] || e.target;\n  for (e.target !== t && Object.defineProperty(e, \"target\", {\n    configurable: !0,\n    value: t\n  }), Object.defineProperty(e, \"currentTarget\", {\n    configurable: !0,\n    get() {\n      return t || document;\n    }\n  }), M.registry && !M.done && (M.done = !0, document.querySelectorAll(\"[id^=pl-]\").forEach((o) => o.remove())); t !== null; ) {\n    const o = t[n];\n    if (o && !t.disabled) {\n      const r = t[`${n}Data`];\n      if (r !== void 0 ? o.call(t, r, e) : o.call(t, e), e.cancelBubble)\n        return;\n    }\n    t = t.host && t.host !== t && t.host instanceof Node ? t.host : t.parentNode;\n  }\n}\nfunction F(e, n, t, o, r) {\n  for (M.context && !t && (t = [...e.childNodes]); typeof t == \"function\"; )\n    t = t();\n  if (n === t)\n    return t;\n  const a = typeof n, l = o !== void 0;\n  if (e = l && t[0] && t[0].parentNode || e, a === \"string\" || a === \"number\") {\n    if (M.context)\n      return t;\n    if (a === \"number\" && (n = n.toString()), l) {\n      let i = t[0];\n      i && i.nodeType === 3 ? i.data = n : i = document.createTextNode(n), t = B(e, t, o, i);\n    } else\n      t !== \"\" && typeof t == \"string\" ? t = e.firstChild.data = n : t = e.textContent = n;\n  } else if (n == null || a === \"boolean\") {\n    if (M.context)\n      return t;\n    t = B(e, t, o);\n  } else {\n    if (a === \"function\")\n      return z(() => {\n        let i = n();\n        for (; typeof i == \"function\"; )\n          i = i();\n        t = F(e, i, t, o);\n      }), () => t;\n    if (Array.isArray(n)) {\n      const i = [], s = t && Array.isArray(t);\n      if (G(i, n, t, r))\n        return z(() => t = F(e, i, t, o, !0)), () => t;\n      if (M.context) {\n        for (let c = 0; c < i.length; c++)\n          if (i[c].parentNode)\n            return t = i;\n      }\n      if (i.length === 0) {\n        if (t = B(e, t, o), l)\n          return t;\n      } else\n        s ? t.length === 0 ? ce(e, i, o) : nt(e, t, i) : (t && B(e), ce(e, i));\n      t = i;\n    } else if (n instanceof Node) {\n      if (M.context && n.parentNode)\n        return t = l ? [n] : n;\n      if (Array.isArray(t)) {\n        if (l)\n          return t = B(e, t, o, n);\n        B(e, t, null, n);\n      } else\n        t == null || t === \"\" || !e.firstChild ? e.appendChild(n) : e.replaceChild(n, e.firstChild);\n      t = n;\n    }\n  }\n  return t;\n}\nfunction G(e, n, t, o) {\n  let r = !1;\n  for (let a = 0, l = n.length; a < l; a++) {\n    let i = n[a], s = t && t[a];\n    if (i instanceof Node)\n      e.push(i);\n    else if (!(i == null || i === !0 || i === !1))\n      if (Array.isArray(i))\n        r = G(e, i, s) || r;\n      else if (typeof i == \"function\")\n        if (o) {\n          for (; typeof i == \"function\"; )\n            i = i();\n          r = G(e, Array.isArray(i) ? i : [i], s) || r;\n        } else\n          e.push(i), r = !0;\n      else {\n        const c = String(i);\n        s && s.nodeType === 3 && s.data === c ? e.push(s) : e.push(document.createTextNode(c));\n      }\n  }\n  return r;\n}\nfunction ce(e, n, t) {\n  for (let o = 0, r = n.length; o < r; o++)\n    e.insertBefore(n[o], t);\n}\nfunction B(e, n, t, o) {\n  if (t === void 0)\n    return e.textContent = \"\";\n  const r = o || document.createTextNode(\"\");\n  if (n.length) {\n    let a = !1;\n    for (let l = n.length - 1; l >= 0; l--) {\n      const i = n[l];\n      if (r !== i) {\n        const s = i.parentNode === e;\n        !a && !l ? s ? e.replaceChild(r, i) : e.insertBefore(r, t) : s && i.remove();\n      } else\n        a = !0;\n    }\n  } else\n    e.insertBefore(r, t);\n  return [r];\n}\nconst _ = {\n  array: \"[object Array]\",\n  object: \"[object Object]\",\n  string: \"[object String]\",\n  undefined: \"[object Undefined]\",\n  window: \"[object Window]\"\n}, it = (e) => {\n  if (Object.prototype.toString.call(e) === _.object)\n    return `[object ${e.constructor.name}]`;\n}, N = (e, n) => it(e) === n, at = (e, n) => {\n  const t = /* @__PURE__ */ new WeakMap(), o = (r, a) => t.get(r) || (N(r, _.object) && t.set(r, !0), N(a, _.undefined)) ? r : N(r, _.array) && N(a, _.array) ? [...a] : N(r, _.object) && N(a, _.object) ? Object.keys(r).reduce((l, i) => (Object.hasOwn(a, i) ? l[i] = o(r[i], a[i]) : l[i] = r[i], l), {}) : a;\n  return o(e, n);\n}, V = (e, n) => at(e, n);\nvar E = /* @__PURE__ */ ((e) => (e.Auto = \"auto\", e.Dark = \"dark\", e.Light = \"light\", e))(E || {}), $ = /* @__PURE__ */ ((e) => (e.Appearance = \"appearance\", e.Attribution = \"attribution\", e.Autocomplete = \"autocomplete\", e.Images = \"images\", e.ReadOnly = \"readonly\", e.Spellcheck = \"spellcheck\", e.Vim = \"vim\", e))($ || {}), m = /* @__PURE__ */ ((e) => (e.Bold = \"bold\", e.Code = \"code\", e.CodeBlock = \"code_block\", e.Heading = \"heading\", e.Image = \"image\", e.Italic = \"italic\", e.Link = \"link\", e.List = \"list\", e.OrderedList = \"ordered_list\", e.Quote = \"quote\", e.TaskList = \"task_list\", e))(m || {}), R = /* @__PURE__ */ ((e) => (e.Completion = \"completion\", e.Default = \"default\", e.Grammar = \"grammar\", e))(R || {});\nconst de = () => document.createElement(\"div\"), xe = () => window.matchMedia(\"(prefers-color-scheme: dark)\").matches, lt = (e) => e === E.Dark ? !0 : e === E.Light ? !1 : xe(), X = (e) => {\n  const n = [\n    { suffix: \"border-radius\", default: \"0.25rem\" },\n    { suffix: \"color\", default: \"currentColor\" },\n    { suffix: \"flex-direction\", default: \"column\" },\n    { suffix: \"font-family\", default: \"inherit\" },\n    { suffix: \"block-background-color\", default: \"#121212\", light: \"#f5f5f5\" },\n    { suffix: \"block-background-color-on-hover\", default: \"#0f0f0f\", light: \"#e0e0e0\" },\n    { suffix: \"block-max-height\", default: \"20rem\" },\n    { suffix: \"block-padding\", default: \"0.5rem\" },\n    { suffix: \"code-background-color\", default: \"var(--ink-internal-block-background-color)\" },\n    { suffix: \"code-color\", default: \"inherit\" },\n    { suffix: \"code-font-family\", default: \"'Monaco', Courier, monospace\" },\n    { suffix: \"editor-font-size\", default: \"1em\" },\n    { suffix: \"editor-line-height\", default: \"2em\" },\n    { suffix: \"editor-padding\", default: \"0.5rem\" },\n    { suffix: \"inline-padding\", default: \"0.125rem\" },\n    { suffix: \"modal-position\", default: \"fixed\" },\n    { suffix: \"syntax-atom-color\", default: \"#d19a66\" },\n    { suffix: \"syntax-comment-color\", default: \"#abb2bf\" },\n    { suffix: \"syntax-comment-font-style\", default: \"italic\" },\n    { suffix: \"syntax-emphasis-color\", default: \"inherit\" },\n    { suffix: \"syntax-emphasis-font-style\", default: \"italic\" },\n    { suffix: \"syntax-hashtag-background-color\", default: \"#222\", light: \"#eee\" },\n    { suffix: \"syntax-hashtag-color\", default: \"inherit\" },\n    { suffix: \"syntax-heading-color\", default: \"inherit\" },\n    { suffix: \"syntax-heading-font-weight\", default: \"600\" },\n    { suffix: \"syntax-heading1-color\", default: \"var(--ink-internal-syntax-heading-color, inherit)\" },\n    { suffix: \"syntax-heading1-font-size\", default: \"1.6em\" },\n    { suffix: \"syntax-heading1-font-weight\", default: \"600\" },\n    { suffix: \"syntax-heading2-color\", default: \"var(--ink-internal-syntax-heading-color, inherit)\" },\n    { suffix: \"syntax-heading2-font-size\", default: \"1.5em\" },\n    { suffix: \"syntax-heading2-font-weight\", default: \"600\" },\n    { suffix: \"syntax-heading3-color\", default: \"var(--ink-internal-syntax-heading-color, inherit)\" },\n    { suffix: \"syntax-heading3-font-size\", default: \"1.4em\" },\n    { suffix: \"syntax-heading3-font-weight\", default: \"600\" },\n    { suffix: \"syntax-heading4-color\", default: \"var(--ink-internal-syntax-heading-color, inherit)\" },\n    { suffix: \"syntax-heading4-font-size\", default: \"1.3em\" },\n    { suffix: \"syntax-heading4-font-weight\", default: \"600\" },\n    { suffix: \"syntax-heading5-color\", default: \"var(--ink-internal-syntax-heading-color, inherit)\" },\n    { suffix: \"syntax-heading5-font-size\", default: \"1.2em\" },\n    { suffix: \"syntax-heading5-font-weight\", default: \"600\" },\n    { suffix: \"syntax-heading6-color\", default: \"var(--ink-internal-syntax-heading-color, inherit)\" },\n    { suffix: \"syntax-heading6-font-size\", default: \"1.1em\" },\n    { suffix: \"syntax-heading6-font-weight\", default: \"600\" },\n    { suffix: \"syntax-highlight-background-color\", default: \"#555555\" },\n    { suffix: \"syntax-keyword-color\", default: \"#c678dd\" },\n    { suffix: \"syntax-link-color\", default: \"inherit\" },\n    { suffix: \"syntax-meta-color\", default: \"#abb2bf\" },\n    { suffix: \"syntax-monospace-color\", default: \"var(--ink-internal-code-color)\" },\n    { suffix: \"syntax-monospace-font-family\", default: \"var(--ink-internal-code-font-family)\" },\n    { suffix: \"syntax-name-color\", default: \"#d19a66\" },\n    { suffix: \"syntax-name-label-color\", default: \"#abb2bf\" },\n    { suffix: \"syntax-name-property-color\", default: \"#96c0d8\" },\n    { suffix: \"syntax-name-property-definition-color\", default: \"#e06c75\" },\n    { suffix: \"syntax-name-variable-color\", default: \"#e06c75\" },\n    { suffix: \"syntax-name-variable-definition-color\", default: \"#e5c07b\" },\n    { suffix: \"syntax-name-variable-local-color\", default: \"#d19a66\" },\n    { suffix: \"syntax-name-variable-special-color\", default: \"inherit\" },\n    { suffix: \"syntax-number-color\", default: \"#d19a66\" },\n    { suffix: \"syntax-operator-color\", default: \"#96c0d8\" },\n    { suffix: \"syntax-processing-instruction-color\", default: \"#444444\", light: \"#bbbbbb\" },\n    { suffix: \"syntax-punctuation-color\", default: \"#abb2bf\" },\n    { suffix: \"syntax-strikethrough-color\", default: \"inherit\" },\n    { suffix: \"syntax-strikethrough-text-decoration\", default: \"line-through\" },\n    { suffix: \"syntax-string-color\", default: \"#98c379\" },\n    { suffix: \"syntax-string-special-color\", default: \"inherit\" },\n    { suffix: \"syntax-strong-color\", default: \"inherit\" },\n    { suffix: \"syntax-strong-font-weight\", default: \"600\" },\n    { suffix: \"syntax-url-color\", default: \"#aaaaaa\", light: \"#666666\" }\n  ], t = !lt(e.options.interface.appearance);\n  return n.map((o) => {\n    const r = t && o.light ? o.light : o.default;\n    return `--ink-internal-${o.suffix}: var(--ink-${o.suffix}, ${r});`;\n  });\n}, fe = () => [\n  b.theme({}, { dark: !0 })\n], ue = () => [\n  b.theme({}, { dark: !1 })\n];\nclass st extends he {\n  constructor() {\n    super();\n  }\n  eq() {\n    return !0;\n  }\n  toDOM() {\n    const n = document.createElement(\"div\"), t = n.appendChild(document.createElement(\"span\")), o = n.appendChild(document.createElement(\"a\"));\n    return n.setAttribute(\"aria-hidden\", \"true\"), n.style.bottom = \"0\", n.style.fontSize = \"0.75em\", n.style.opacity = \"0.5\", n.style.position = \"absolute\", n.style.right = \"0\", t.innerText = \"powered by \", o.href = \"https://github.com/voracious/ink-mde\", o.innerText = \"ink-mde\", o.rel = \"noopener noreferrer\", o.target = \"_blank\", o.style.color = \"var(--ink-internal-color)\", o.style.fontWeight = \"600\", o.style.textDecoration = \"none\", n;\n  }\n}\nconst ct = b.baseTheme({\n  \".cm-content\": {\n    paddingBottom: \"2em\"\n  }\n}), dt = Z.define({\n  create(e) {\n    return W.of(ge().range(e.doc.length));\n  },\n  update(e, n) {\n    return W.of(ge().range(n.newDoc.length));\n  },\n  provide(e) {\n    return b.decorations.from(e);\n  }\n}), ge = () => C.widget({\n  widget: new st(),\n  side: 1,\n  block: !0\n}), ft = () => [\n  ct,\n  dt\n];\nclass ut extends he {\n  url;\n  constructor({ url: n }) {\n    super(), this.url = n;\n  }\n  eq(n) {\n    return n.url === this.url;\n  }\n  toDOM() {\n    const n = document.createElement(\"div\"), t = n.appendChild(document.createElement(\"div\")), o = t.appendChild(document.createElement(\"figure\")), r = o.appendChild(document.createElement(\"img\"));\n    return n.setAttribute(\"aria-hidden\", \"true\"), n.className = \"cm-image-container\", t.className = \"cm-image-backdrop\", o.className = \"cm-image-figure\", r.className = \"cm-image-img\", r.src = this.url, n.style.paddingBottom = \"0.5rem\", n.style.paddingTop = \"0.5rem\", t.classList.add(\"cm-image-backdrop\"), t.style.borderRadius = \"var(--ink-internal-border-radius)\", t.style.display = \"flex\", t.style.alignItems = \"center\", t.style.justifyContent = \"center\", t.style.overflow = \"hidden\", t.style.maxWidth = \"100%\", o.style.margin = \"0\", r.style.display = \"block\", r.style.maxHeight = \"var(--ink-internal-block-max-height)\", r.style.maxWidth = \"100%\", r.style.width = \"100%\", n;\n  }\n}\nconst gt = () => {\n  const e = /!\\[.*?\\]\\((?<url>.*?)\\)/, n = (a) => C.widget({\n    widget: new ut(a),\n    side: -1,\n    block: !0\n  }), t = (a) => {\n    const l = [];\n    return J(a).iterate({\n      enter: ({ type: i, from: s, to: c }) => {\n        if (i.name === \"Image\") {\n          const u = e.exec(a.doc.sliceString(s, c));\n          u && u.groups && u.groups.url && l.push(n({ url: u.groups.url }).range(a.doc.lineAt(s).from));\n        }\n      }\n    }), l.length > 0 ? W.of(l) : C.none;\n  }, o = b.baseTheme({\n    \".cm-image-backdrop\": {\n      backgroundColor: \"var(--ink-internal-block-background-color)\"\n    }\n  }), r = Z.define({\n    create(a) {\n      return t(a);\n    },\n    update(a, l) {\n      return l.docChanged ? t(l.state) : a.map(l.changes);\n    },\n    provide(a) {\n      return b.decorations.from(a);\n    }\n  });\n  return [\n    o,\n    r\n  ];\n}, pt = () => b.contentAttributes.of({\n  spellcheck: \"true\"\n}), mt = (e, n) => {\n  const t = e.resolver(n);\n  return e.compartment.of(t);\n}, ht = (e) => e.extensions.map((n) => mt(n, e.options)), kt = (e, n) => {\n  const t = e.resolver(n);\n  return e.compartment.reconfigure(t);\n}, be = (e) => e.extensions.map((n) => kt(n, e.options)), S = (e) => {\n  const n = new Ie(), t = bt[e];\n  return {\n    compartment: n,\n    name: e,\n    resolver: t\n  };\n}, xt = () => [\n  S($.Appearance),\n  S($.Attribution),\n  S($.Autocomplete),\n  S($.Images),\n  S($.ReadOnly),\n  S($.Spellcheck),\n  S($.Vim)\n], bt = {\n  appearance({ interface: { appearance: e } }) {\n    return e === E.Dark ? fe() : e === E.Light ? ue() : xe() ? fe() : ue();\n  },\n  attribution(e) {\n    return e.interface.attribution ? ft() : [];\n  },\n  autocomplete(e) {\n    return e.interface.autocomplete ? Ve() : [];\n  },\n  images(e) {\n    return e.interface.images ? gt() : [];\n  },\n  readonly(e) {\n    return e.interface.readonly ? Q.readOnly.of(!0) : Q.readOnly.of(!1);\n  },\n  spellcheck(e) {\n    return e.interface.spellcheck ? pt() : [];\n  },\n  vim(e) {\n    return e.vim ? Ue() : [];\n  }\n}, ve = () => ({\n  editor: new b(),\n  extensions: xt(),\n  options: {\n    doc: \"\",\n    files: {\n      clipboard: !1,\n      dragAndDrop: !1,\n      handler: () => {\n      },\n      injectMarkup: !0,\n      types: [\"image/*\"]\n    },\n    hooks: {\n      afterUpdate: () => {\n      },\n      beforeUpdate: () => {\n      }\n    },\n    interface: {\n      appearance: E.Auto,\n      attribution: !0,\n      autocomplete: !1,\n      images: !1,\n      readonly: !1,\n      spellcheck: !0,\n      toolbar: !1\n    },\n    plugins: [],\n    selections: [],\n    toolbar: {\n      bold: !0,\n      code: !0,\n      codeBlock: !0,\n      heading: !0,\n      image: !0,\n      italic: !0,\n      link: !0,\n      list: !0,\n      orderedList: !0,\n      quote: !0,\n      taskList: !0,\n      upload: !1\n    },\n    vim: !1\n  },\n  root: de(),\n  target: de()\n}), vt = (e) => V(ve(), e), yt = (e) => {\n  const [n, t] = D(vt({ options: e }));\n  return [n, t];\n}, ye = (e) => {\n  const n = e.map((t) => We.fromJSON({ anchor: t.start, head: t.end }));\n  return Re.create(n);\n}, wt = (e) => e.ranges.map((t) => ({\n  end: t.anchor < t.head ? t.head : t.anchor,\n  start: t.head < t.anchor ? t.head : t.anchor\n})), w = (e) => ({ ...{\n  block: !1,\n  line: !1,\n  multiline: !1,\n  nodes: [],\n  prefix: \"\",\n  prefixStates: [],\n  suffix: \"\"\n}, ...e }), Ct = {\n  [m.Bold]: w({\n    nodes: [\"StrongEmphasis\"],\n    prefix: \"**\",\n    suffix: \"**\"\n  }),\n  [m.Code]: w({\n    nodes: [\"InlineCode\"],\n    prefix: \"`\",\n    suffix: \"`\"\n  }),\n  [m.CodeBlock]: w({\n    block: !0,\n    nodes: [\"FencedCode\"],\n    prefix: \"```\\n\",\n    suffix: \"\\n```\"\n  }),\n  [m.Heading]: w({\n    multiline: !0,\n    nodes: [\"ATXHeading1\", \"ATXHeading2\", \"ATXHeading3\", \"ATXHeading4\", \"ATXHeading5\", \"ATXHeading6\"],\n    prefix: \"# \",\n    prefixStates: [\"# \", \"## \", \"### \", \"#### \", \"##### \", \"###### \", \"\"]\n  }),\n  [m.Image]: w({\n    nodes: [\"Image\"],\n    prefix: \"![](\",\n    suffix: \")\"\n  }),\n  [m.Italic]: w({\n    nodes: [\"Emphasis\"],\n    prefix: \"*\",\n    suffix: \"*\"\n  }),\n  [m.Link]: w({\n    nodes: [\"Link\"],\n    prefix: \"[](\",\n    suffix: \")\"\n  }),\n  [m.OrderedList]: w({\n    line: !0,\n    multiline: !0,\n    nodes: [\"OrderedList\"],\n    prefix: \"1. \"\n  }),\n  [m.Quote]: w({\n    line: !0,\n    multiline: !0,\n    nodes: [\"Blockquote\"],\n    prefix: \"> \"\n  }),\n  [m.TaskList]: w({\n    line: !0,\n    multiline: !0,\n    nodes: [\"BulletList\"],\n    prefix: \"- [ ] \"\n  }),\n  [m.List]: w({\n    line: !0,\n    multiline: !0,\n    nodes: [\"BulletList\"],\n    prefix: \"- \"\n  })\n}, we = ([e, n], t) => {\n  const { editor: o } = e(), r = o.lineBlockAt(t.start), a = o.lineBlockAt(t.end);\n  return { start: r.from, end: a.to };\n}, Lt = ([e, n], t) => {\n  const { editor: o } = e();\n  let r = t.start;\n  const a = [];\n  for (; r <= t.end; ) {\n    const l = o.lineBlockAt(r), i = Math.max(r, l.from), s = Math.min(r, l.to);\n    a.push({ start: i, end: s }), r = l.to + 1;\n  }\n  return a;\n}, $t = ([e, n], t) => {\n  const { editor: o } = e(), r = o.state.wordAt(t.start)?.from || t.start, a = o.state.wordAt(t.end)?.to || t.end;\n  return { start: r, end: a };\n}, Mt = ([e, n], t) => t || P([e, n]).pop() || { start: 0, end: 0 }, Ce = ([e, n], t) => {\n  const { editor: o } = e();\n  return o.state.sliceDoc(t.start, t.end);\n}, Y = ([e, n], t, o) => St(e(), o).find(({ type: a }) => t.nodes.includes(a.name)), St = ({ editor: { state: e } }, n) => {\n  const t = [];\n  return J(e).iterate({\n    from: n.start,\n    to: n.end,\n    enter: ({ type: o, from: r, to: a }) => {\n      t.push({ type: o, from: r, to: a });\n    }\n  }), t;\n}, ee = ([e, n], t, o) => {\n  const r = Ce([e, n], o), a = t.prefix.length, l = t.suffix.length * -1 || r.length, i = r.slice(a, l);\n  T([e, n], i, o);\n}, _t = ([e, n], t, o) => {\n  const r = we([e, n], o), a = Y([e, n], t, r);\n  if (a) {\n    const l = a.from, i = a.to;\n    ee([e, n], t, { start: l, end: i });\n  } else {\n    const l = t.prefix, i = t.suffix;\n    U([e, n], { before: l, after: i, selection: r });\n  }\n}, At = ([e, n], t, o) => {\n  Lt([e, n], o).forEach((a) => {\n    Le([e, n], t, a);\n  });\n}, Le = ([e, n], t, o) => {\n  const r = we([e, n], o), a = Y([e, n], t, r), l = t.prefixStates.length > 0;\n  if (a && l)\n    t.prefixStates.find((i, s) => {\n      const c = a.from, u = a.to, k = Ce([e, n], { start: c, end: u }), L = k.startsWith(i);\n      return L && T([e, n], k.replace(new RegExp(`^${i}`), t.prefixStates[s + 1]), { start: c, end: u }), L;\n    });\n  else if (a) {\n    const i = a.from, s = a.to;\n    ee([e, n], t, { start: i, end: s });\n  } else {\n    const i = t.prefix, s = t.suffix;\n    U([e, n], { before: i, after: s, selection: r });\n  }\n}, Bt = ([e, n], t, o) => {\n  const r = Y([e, n], t, o);\n  if (r) {\n    const a = r.from, l = r.to;\n    ee([e, n], t, { start: a, end: l });\n  } else {\n    const { start: a, end: l } = $t([e, n], o), i = Array.isArray(t.prefix) ? t.prefix[0] : t.prefix, s = t.suffix;\n    U([e, n], { before: i, after: s, selection: { start: a, end: l } });\n  }\n}, Nt = ([e, n], t, o) => {\n  const r = Ct[t], a = Mt([e, n], o);\n  r.block ? _t([e, n], r, a) : r.multiline ? At([e, n], r, a) : r.line ? Le([e, n], r, a) : Bt([e, n], r, a);\n}, Dt = b.baseTheme({\n  \".cm-line\": {\n    fontFamily: \"var(--ink-internal-font-family)\"\n  },\n  \".cm-line.cm-codeblock\": {\n    backgroundColor: \"var(--ink-internal-block-background-color)\",\n    fontFamily: \"var(--ink-internal-code-font-family)\",\n    padding: \"0 var(--ink-internal-block-padding)\"\n  },\n  \".cm-line.cm-codeblock.cm-codeblock-open\": {\n    borderRadius: \"var(--ink-internal-border-radius) var(--ink-internal-border-radius) 0 0\",\n    paddingTop: \"var(--ink-internal-block-padding)\"\n  },\n  \".cm-line.cm-codeblock.cm-codeblock-close\": {\n    borderRadius: \"0 0 var(--ink-internal-border-radius) var(--ink-internal-border-radius)\",\n    paddingBottom: \"var(--ink-internal-block-padding)\"\n  },\n  \".cm-line .cm-code\": {\n    backgroundColor: \"var(--ink-internal-block-background-color)\",\n    fontFamily: \"var(--ink-internal-code-font-family)\",\n    padding: \"var(--ink-internal-inline-padding) 0\"\n  },\n  \".cm-line .cm-code.cm-code-open\": {\n    borderRadius: \"var(--ink-internal-border-radius) 0 0 var(--ink-internal-border-radius)\",\n    paddingLeft: \"var(--ink-internal-inline-padding)\"\n  },\n  \".cm-line .cm-code.cm-code-close\": {\n    borderRadius: \"0 var(--ink-internal-border-radius) var(--ink-internal-border-radius) 0\",\n    paddingRight: \"var(--ink-internal-inline-padding)\"\n  }\n}), Et = [\n  \"CodeBlock\",\n  \"FencedCode\",\n  \"HTMLBlock\",\n  \"CommentBlock\"\n], Tt = C.line({ attributes: { class: \"cm-codeblock\" } }), Ht = C.line({ attributes: { class: \"cm-codeblock-open\" } }), jt = C.line({ attributes: { class: \"cm-codeblock-close\" } }), zt = C.mark({ attributes: { class: \"cm-code\" } }), Vt = C.mark({ attributes: { class: \"cm-code cm-code-open\" } }), Ot = C.mark({ attributes: { class: \"cm-code cm-code-close\" } }), It = je.define((e) => ({\n  update: () => Rt(e)\n}), { decorations: (e) => e.update() }), Rt = (e) => {\n  const n = new Fe(), t = J(e.state);\n  for (const o of e.visibleRanges)\n    for (let r = o.from; r < o.to; ) {\n      const a = e.state.doc.lineAt(r);\n      let l;\n      t.iterate({\n        enter({ type: i, from: s, to: c }) {\n          if (i.name !== \"Document\")\n            if (Et.includes(i.name)) {\n              n.add(a.from, a.from, Tt);\n              const u = e.state.doc.lineAt(s), k = e.state.doc.lineAt(c);\n              return u.number === a.number && n.add(a.from, a.from, Ht), k.number === a.number && n.add(a.from, a.from, jt), !1;\n            } else\n              i.name === \"InlineCode\" ? l = { from: s, to: c, innerFrom: s, innerTo: c } : i.name === \"CodeMark\" && (s === l.from ? (l.innerFrom = c, n.add(s, c, Vt)) : c === l.to && (l.innerTo = s, n.add(l.innerFrom, l.innerTo, zt), n.add(s, c, Ot)));\n        },\n        from: a.from,\n        to: a.to\n      }), r = a.to + 1;\n    }\n  return n.finish();\n}, Wt = () => [\n  Dt,\n  It\n], Ft = [\n  {\n    key: \"Tab\",\n    run: ({ state: e, dispatch: n }) => e.selection.ranges.some((t) => !t.empty) ? Ke({ state: e, dispatch: n }) : (n(e.update(e.replaceSelection(\"  \"), {\n      scrollIntoView: !0,\n      annotations: Pe.userEvent.of(\"input\")\n    })), !0),\n    shift: Ze\n  }\n], Pt = () => ze.of([\n  ...Ft,\n  ...Qe,\n  ...Ge\n]), Ut = () => b.lineWrapping, qt = () => {\n  const e = b.baseTheme({\n    \"&\": {},\n    \".cm-scroller\": {\n      lineHeight: \"var(--ink-internal-editor-line-height)\",\n      fontFamily: \"var(--ink-internal-font-family)\",\n      fontSize: \"var(--ink-internal-editor-font-size)\"\n    },\n    \".cm-line\": {\n      padding: \"0\"\n    }\n  }), n = qe(Xe.define([\n    {\n      tag: d.atom,\n      color: \"var(--ink-internal-syntax-atom-color)\"\n    },\n    {\n      tag: d.meta,\n      color: \"var(--ink-internal-syntax-meta-color)\"\n    },\n    {\n      tag: d.emphasis,\n      color: \"var(--ink-internal-syntax-emphasis-color)\",\n      fontStyle: \"var(--ink-internal-syntax-emphasis-font-style)\"\n    },\n    {\n      tag: d.strong,\n      color: \"var(--ink-internal-syntax-strong-color)\",\n      fontWeight: \"var(--ink-internal-syntax-strong-font-weight)\"\n    },\n    {\n      tag: d.strikethrough,\n      color: \"var(--ink-internal-syntax-strikethrough-color)\",\n      textDecoration: \"var(--ink-internal-syntax-strikethrough-text-decoration)\"\n    },\n    {\n      tag: d.comment,\n      color: \"var(--ink-internal-syntax-comment-color)\",\n      fontStyle: \"var(--ink-internal-syntax-comment-font-style)\"\n    },\n    {\n      tag: d.monospace,\n      color: \"var(--ink-internal-syntax-code-color)\",\n      fontFamily: \"var(--ink-internal-syntax-code-font-family)\"\n    },\n    {\n      tag: d.name,\n      color: \"var(--ink-internal-syntax-name-color)\"\n    },\n    {\n      tag: d.labelName,\n      color: \"var(--ink-internal-syntax-name-label-color)\"\n    },\n    {\n      tag: d.propertyName,\n      color: \"var(--ink-internal-syntax-name-property-color)\"\n    },\n    {\n      tag: d.definition(d.propertyName),\n      color: \"var(--ink-internal-syntax-name-property-definition-color)\"\n    },\n    {\n      tag: d.variableName,\n      color: \"var(--ink-internal-syntax-name-variable-color)\"\n    },\n    {\n      tag: d.definition(d.variableName),\n      color: \"var(--ink-internal-syntax-name-variable-definition-color)\"\n    },\n    {\n      tag: d.local(d.variableName),\n      color: \"var(--ink-internal-syntax-name-variable-local-color)\"\n    },\n    {\n      tag: d.special(d.variableName),\n      color: \"var(--ink-internal-syntax-name-variable-special-color)\"\n    },\n    {\n      tag: d.heading,\n      color: \"var(--ink-internal-syntax-heading-color)\",\n      fontWeight: \"var(--ink-internal-syntax-heading-font-weight)\"\n    },\n    {\n      tag: d.heading1,\n      color: \"var(--ink-internal-syntax-heading1-color)\",\n      fontSize: \"var(--ink-internal-syntax-heading1-font-size)\",\n      fontWeight: \"var(--ink-internal-syntax-heading1-font-weight)\"\n    },\n    {\n      tag: d.heading2,\n      color: \"var(--ink-internal-syntax-heading2-color)\",\n      fontSize: \"var(--ink-internal-syntax-heading2-font-size)\",\n      fontWeight: \"var(--ink-internal-syntax-heading2-font-weight)\"\n    },\n    {\n      tag: d.heading3,\n      color: \"var(--ink-internal-syntax-heading3-color)\",\n      fontSize: \"var(--ink-internal-syntax-heading3-font-size)\",\n      fontWeight: \"var(--ink-internal-syntax-heading3-font-weight)\"\n    },\n    {\n      tag: d.heading4,\n      color: \"var(--ink-internal-syntax-heading4-color)\",\n      fontSize: \"var(--ink-internal-syntax-heading4-font-size)\",\n      fontWeight: \"var(--ink-internal-syntax-heading4-font-weight)\"\n    },\n    {\n      tag: d.heading5,\n      color: \"var(--ink-internal-syntax-heading5-color)\",\n      fontSize: \"var(--ink-internal-syntax-heading5-font-size)\",\n      fontWeight: \"var(--ink-internal-syntax-heading5-font-weight)\"\n    },\n    {\n      tag: d.heading6,\n      color: \"var(--ink-internal-syntax-heading6-color)\",\n      fontSize: \"var(--ink-internal-syntax-heading6-font-size)\",\n      fontWeight: \"var(--ink-internal-syntax-heading6-font-weight)\"\n    },\n    {\n      tag: d.keyword,\n      color: \"var(--ink-internal-syntax-keyword-color)\"\n    },\n    {\n      tag: d.number,\n      color: \"var(--ink-internal-syntax-number-color)\"\n    },\n    {\n      tag: d.operator,\n      color: \"var(--ink-internal-syntax-operator-color)\"\n    },\n    {\n      tag: d.punctuation,\n      color: \"var(--ink-internal-syntax-punctuation-color)\"\n    },\n    {\n      tag: d.link,\n      color: \"var(--ink-internal-syntax-link-color)\"\n    },\n    {\n      tag: d.url,\n      color: \"var(--ink-internal-syntax-url-color)\"\n    },\n    {\n      tag: d.string,\n      color: \"var(--ink-internal-syntax-string-color)\"\n    },\n    {\n      tag: d.special(d.string),\n      color: \"var(--ink-internal-syntax-string-special-color)\"\n    },\n    {\n      tag: d.processingInstruction,\n      color: \"var(--ink-internal-syntax-processing-instruction-color)\"\n    }\n  ]));\n  return [\n    e,\n    n\n  ];\n}, Xt = (e) => {\n  if (e.length > 0)\n    return ye(e);\n}, $e = (e) => {\n  const n = e.options.plugins.flatMap((r) => r.type === R.Completion ? r.value : []), t = e.options.plugins.flatMap((r) => r.type === R.Default ? r.value : []), o = e.options.plugins.flatMap((r) => r.type === R.Grammar ? r.value : []);\n  return Q.create({\n    doc: e.options.doc,\n    selection: Xt(e.options.selections),\n    extensions: [\n      ...ht(e),\n      Oe({\n        defaultKeymap: !0,\n        icons: !1,\n        override: n,\n        optionClass: () => \"ink-tooltip-option\"\n      }),\n      Wt(),\n      Je(),\n      Pt(),\n      Ut(),\n      Ye({\n        base: et,\n        codeLanguages: tt,\n        extensions: o\n      }),\n      qt(),\n      ...t\n    ]\n  });\n}, Qt = ([e, n]) => {\n  const { editor: t } = e();\n  t.destroy();\n}, Gt = ([e, n]) => {\n  const { editor: t } = e();\n  return t.state.sliceDoc();\n}, K = ([e, n]) => {\n  const { editor: t } = e();\n  t.hasFocus || t.focus();\n}, Kt = ([e, n], t, o) => Nt([e, n], t, o), T = ([e, n], t, o, r = !1) => {\n  const { editor: a } = e();\n  let l = o?.start, i = o?.end || o?.start;\n  if (typeof l > \"u\") {\n    const c = P([e, n]).pop();\n    l = c.start, i = c.end;\n  }\n  const s = { changes: { from: l, to: i, insert: t } };\n  if (r) {\n    const c = l === i ? l + t.length : l, u = l + t.length;\n    Object.assign(s, { selection: { anchor: c, head: u } });\n  }\n  a.dispatch(a.state.update(s));\n}, Zt = ([e, n], t) => {\n  n(V(e(), { options: { doc: t } })), e().editor.setState($e(e()));\n}, Jt = (e) => ({\n  destroy: Qt.bind(void 0, e),\n  doc: Gt.bind(void 0, e),\n  focus: K.bind(void 0, e),\n  insert: T.bind(void 0, e),\n  load: Zt.bind(void 0, e),\n  reconfigure: Yt.bind(void 0, e),\n  select: Me.bind(void 0, e),\n  selections: P.bind(void 0, e),\n  update: en.bind(void 0, e),\n  wrap: U.bind(void 0, e)\n}), Yt = ([e, n], t) => {\n  const o = be(n(V(e(), { options: t })));\n  e().editor.dispatch({\n    effects: o\n  });\n}, Me = ([e, n], t) => {\n  const { editor: o } = e();\n  o.dispatch(o.state.update({\n    selection: ye(t)\n  }));\n}, P = ([e, n]) => {\n  const { editor: t } = e();\n  return wt(t.state.selection);\n}, en = ([e, n], t) => {\n  const { editor: o } = e();\n  o.dispatch(o.state.update({\n    changes: {\n      from: 0,\n      to: o.state.doc.length,\n      insert: t\n    }\n  }));\n}, U = ([e, n], { after: t, before: o, selection: r }) => {\n  const { editor: a } = e(), l = r || P([e, n]).pop() || { start: 0, end: 0 }, i = a.state.sliceDoc(l.start, l.end);\n  T([e, n], `${o}${i}${t}`, l), Me([e, n], [{ start: l.start + o.length, end: l.end + o.length }]);\n}, tn = `.ink-drop-zone{align-items:center;background-color:#00000080;color:var(--ink-internal-color);display:flex;inset:0;justify-content:center;position:var(--ink-internal-modal-position);z-index:100}.ink-drop-zone:not(.visible){display:none}.ink-drop-zone-modal{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);box-sizing:border-box;height:100%;max-height:20rem;max-width:40rem;padding:1rem;position:relative;width:100%}.ink-drop-zone-hide{cursor:pointer;height:1.75rem;position:absolute;right:.25rem;top:.25rem;width:1.75rem}.ink-drop-zone-hide svg{background-color:var(--ink-internal-block-background-color)}.ink-drop-zone-droppable-area{align-items:center;border:.2rem dashed var(--ink-internal-color);border-radius:.125rem;box-sizing:border-box;display:flex;flex-direction:column;font-size:1.25em;gap:1rem;height:100%;justify-content:center;padding:1rem;text-align:center}.ink-drop-zone-file-preview{align-items:center;display:flex;flex-wrap:wrap;gap:.5rem;max-width:25.5rem}.ink-drop-zone-file-preview-image{border:.125rem solid #222;border-radius:.125rem;box-sizing:border-box;height:6rem;object-fit:cover;padding:.5rem;width:6rem}\n`, nn = /* @__PURE__ */ h(\"<style></style>\"), on = /* @__PURE__ */ h(\"<span>uploading files...</span>\"), rn = /* @__PURE__ */ h('<div class=\"ink-drop-zone\"><div class=\"ink-drop-zone-modal\"><div class=\"ink-drop-zone-droppable-area\"><div class=\"ink-drop-zone-file-preview\"></div></div><div class=\"ink-drop-zone-hide\"><svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z\"></path></svg></div></div></div>'), an = /* @__PURE__ */ h('<img class=\"ink-drop-zone-file-preview-image\">'), ln = /* @__PURE__ */ h(\"<span>drop files here</span>\"), sn = () => {\n  const [e, n] = D(0), [t, o] = D([]), [r, a] = D(!1), [l, i] = D(!1), [s, c] = O(), u = () => {\n    i(!1);\n  }, k = (g) => {\n    if (s().options.files.dragAndDrop) {\n      g.preventDefault(), g.stopPropagation();\n      const v = g.dataTransfer;\n      v?.files ? oe(v.files) : (n(0), i(!1), o([]));\n    }\n  }, L = (g) => {\n    s().options.files.dragAndDrop && (g.preventDefault(), n(e() + 1), i(!0));\n  }, H = (g) => {\n    s().options.files.dragAndDrop && (g.preventDefault(), n(e() - 1), e() === 0 && i(!1));\n  }, I = (g) => {\n    s().options.files.dragAndDrop && (g.preventDefault(), i(!0));\n  }, te = (g) => {\n    s().options.files.dragAndDrop && (g.preventDefault(), n(0), i(!1));\n  }, ne = (g) => {\n    if (s().options.files.clipboard) {\n      g.preventDefault();\n      const v = g.clipboardData;\n      v?.files && v.files.length > 0 && oe(v.files);\n    }\n  }, oe = (g) => {\n    Array.from(g).forEach((v) => {\n      o([...t(), v]);\n    }), a(!0), i(!0), Promise.resolve(s().options.files.handler(g)).then((v) => {\n      if (s().options.files.injectMarkup && v) {\n        const A = `![](${v})`;\n        T([s, c], A);\n      }\n    }).finally(() => {\n      n(0), a(!1), i(!1), o([]);\n    });\n  };\n  return me(() => {\n    document.addEventListener(\"dragenter\", L), document.addEventListener(\"dragleave\", H), document.addEventListener(\"dragover\", I), document.addEventListener(\"drop\", te), s().root.addEventListener(\"paste\", ne);\n  }), Ne(() => {\n    document.removeEventListener(\"dragenter\", L), document.removeEventListener(\"dragleave\", H), document.removeEventListener(\"dragover\", I), document.removeEventListener(\"drop\", te), s().root.removeEventListener(\"paste\", ne);\n  }), [(() => {\n    const g = nn.cloneNode(!0);\n    return p(g, tn), g;\n  })(), (() => {\n    const g = rn.cloneNode(!0), v = g.firstChild, A = v.firstChild, _e = A.firstChild, Ae = A.nextSibling;\n    return A.addEventListener(\"drop\", k), p(_e, f(De, {\n      get each() {\n        return t().slice(0, 8);\n      },\n      children: (re) => (() => {\n        const q = an.cloneNode(!0);\n        return z((j) => {\n          const ie = re.name, ae = URL.createObjectURL(re);\n          return ie !== j._v$ && se(q, \"alt\", j._v$ = ie), ae !== j._v$2 && se(q, \"src\", j._v$2 = ae), j;\n        }, {\n          _v$: void 0,\n          _v$2: void 0\n        }), q;\n      })()\n    })), p(A, f(x, {\n      get when() {\n        return r();\n      },\n      get fallback() {\n        return ln.cloneNode(!0);\n      },\n      get children() {\n        return on.cloneNode(!0);\n      }\n    }), null), Ae.$$click = u, z(() => g.classList.toggle(\"visible\", !!l())), g;\n  })()];\n};\nke([\"click\"]);\nconst cn = (e) => {\n  const n = new b({\n    dispatch: (t) => {\n      const { options: o } = e;\n      o.hooks.beforeUpdate(t.newDoc.toString()), n.update([t]), t.docChanged && o.hooks.afterUpdate(t.newDoc.toString());\n    },\n    state: $e(e)\n  });\n  return n;\n}, dn = () => {\n  const [e, n] = O(), t = cn(e());\n  return n(V(e(), {\n    editor: t\n  })), t.dom;\n}, fn = /* @__PURE__ */ h('<button class=\"ink-button\"></button>'), y = (e) => (() => {\n  const n = fn.cloneNode(!0);\n  return n.$$click = (t) => e.onclick(t), p(n, () => e.children), n;\n})();\nke([\"click\"]);\nconst un = `.ink .ink-toolbar{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);bottom:.25rem;color:inherit;display:flex;gap:2rem;overflow:auto;padding:.25rem;position:sticky;top:.25rem;z-index:10}.ink .ink-toolbar-group{display:flex}.ink .ink-toolbar .ink-button{align-items:center;background:none;border:none;border-radius:var(--ink-internal-border-radius);color:inherit;cursor:pointer;display:flex;height:2.25rem;justify-content:center;padding:.4rem;width:2.25rem}.ink .ink-toolbar .ink-button:hover{background-color:var(--ink-internal-block-background-color-on-hover)}.ink .ink-toolbar .ink-button>*{align-items:center;display:flex;height:100%}\n`, gn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M6 4V10M6 16V10M6 10H14M14 10V4M14 10V16\"></path></svg>'), pn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M6.5 10H10.5C12.1569 10 13.5 11.3431 13.5 13C13.5 14.6569 12.1569 16 10.5 16H6.5V4H9.5C11.1569 4 12.5 5.34315 12.5 7C12.5 8.65686 11.1569 10 9.5 10\"></path></svg>'), mn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M11 4L9 16M13 4H9M7 16H11\"></path></svg>'), hn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M2.00257 16H17.9955M2.00055 4H18M7 10H18.0659M2 8.5V11.4999C2.4 11.5 2.5 11.5 2.5 11.5V11V10.5M4 8.5V11.4999H4.5V11V10.5\"></path></svg>'), kn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M13 4L7 16\"></path><path d=\"M5 7L2 10L5 13\"></path><path d=\"M15 7L18 10L15 13\"></path></svg>'), xn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M7 4L8 6\"></path></svg>'), bn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M7 16H17.8294\"></path><path d=\"M2 16H4\"></path><path d=\"M7 10H17.8294\"></path><path d=\"M2 10H4\"></path><path d=\"M7 4H17.8294\"></path><path d=\"M2 4H4\"></path></svg>'), vn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M7 16H18\"></path><path d=\"M2 17.0242C2.48314 17.7569 3.94052 17.6154 3.99486 16.7919C4.05315 15.9169 3.1975 16.0044 2.99496 16.0044M2.0023 14.9758C2.48544 14.2431 3.94282 14.3846 3.99716 15.2081C4.05545 16.0831 3.1998 16.0002 2.99726 16.0002\"></path><path d=\"M7 10H18\"></path><path d=\"M2.00501 11.5H4M2.00193 8.97562C2.48449 8.24319 3.9401 8.38467 3.99437 9.20777C4.05259 10.0825 2.04342 10.5788 2 11.4996\"></path><path d=\"M7 4H18\"></path><path d=\"M2 5.5H4M2.99713 5.49952V2.5L2.215 2.93501\"></path></svg>'), yn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M7 16H17.8294\"></path><path d=\"M5 15L3 17L2 16\"></path><path d=\"M7 10H17.8294\"></path><path d=\"M5 9L3 11L2 10\"></path><path d=\"M7 4H17.8294\"></path><path d=\"M5 3L3 5L2 4\"></path></svg>'), wn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M9.12127 10.881C10.02 11.78 11.5237 11.7349 12.4771 10.7813L15.2546 8.00302C16.2079 7.04937 16.253 5.54521 15.3542 4.6462C14.4555 3.74719 12.9512 3.79174 11.9979 4.74539L10.3437 6.40007M10.8787 9.11903C9.97997 8.22002 8.47626 8.26509 7.52288 9.21874L4.74545 11.997C3.79208 12.9506 3.74701 14.4548 4.64577 15.3538C5.54452 16.2528 7.04876 16.2083 8.00213 15.2546L9.65633 13.5999\"></path></svg>'), Cn = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><rect x=\"2\" y=\"4\" width=\"16\" height=\"12\" rx=\"1\"></rect><path d=\"M7.42659 7.67597L13.7751 13.8831M2.00208 12.9778L7.42844 7.67175\"></path><path d=\"M11.9119 12.0599L14.484 9.54443L17.9973 12.9785\"></path><path d=\"M10.9989 7.95832C11.551 7.95832 11.9986 7.52072 11.9986 6.98092C11.9986 6.44113 11.551 6.00354 10.9989 6.00354C10.4468 6.00354 9.99921 6.44113 9.99921 6.98092C9.99921 7.52072 10.4468 7.95832 10.9989 7.95832Z\"></path></svg>'), Ln = /* @__PURE__ */ h('<svg viewBox=\"0 0 20 20\" fill=\"none\" stroke=\"currentColor\" stroke-miterlimit=\"5\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M10 13V4M10 4L13 7M10 4L7 7\"></path><path d=\"M2 13V15C2 15.5523 2.44772 16 3 16H17C17.5523 16 18 15.5523 18 15V13\"></path></svg>'), $n = /* @__PURE__ */ h('<div class=\"ink-toolbar\"><style></style><div class=\"ink-toolbar-group\"></div><div class=\"ink-toolbar-group\"></div><div class=\"ink-toolbar-group\"></div><div class=\"ink-toolbar-group\"></div></div>'), Mn = () => {\n  const [e, n] = O(), t = (a) => {\n    Kt([e, n], a), K([e, n]);\n  }, o = document.createElement(\"input\"), r = () => {\n    o.click();\n  };\n  return o.style.display = \"none\", o.type = \"file\", o.onchange = (a) => {\n    const l = a.target;\n    l?.files && Promise.resolve(e().options.files.handler(l.files)).then((i) => {\n      const s = `![](${i})`;\n      T([e, n], s), K([e, n]);\n    });\n  }, (() => {\n    const a = $n.cloneNode(!0), l = a.firstChild, i = l.nextSibling, s = i.nextSibling, c = s.nextSibling, u = c.nextSibling;\n    return p(l, un), p(i, f(x, {\n      get when() {\n        return e().options.toolbar.heading;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.Heading),\n          get children() {\n            return gn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(i, f(x, {\n      get when() {\n        return e().options.toolbar.bold;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.Bold),\n          get children() {\n            return pn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(i, f(x, {\n      get when() {\n        return e().options.toolbar.italic;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.Italic),\n          get children() {\n            return mn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(s, f(x, {\n      get when() {\n        return e().options.toolbar.quote;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.Quote),\n          get children() {\n            return hn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(s, f(x, {\n      get when() {\n        return e().options.toolbar.codeBlock;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.CodeBlock),\n          get children() {\n            return kn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(s, f(x, {\n      get when() {\n        return e().options.toolbar.code;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.Code),\n          get children() {\n            return xn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(c, f(x, {\n      get when() {\n        return e().options.toolbar.list;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.List),\n          get children() {\n            return bn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(c, f(x, {\n      get when() {\n        return e().options.toolbar.orderedList;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.OrderedList),\n          get children() {\n            return vn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(c, f(x, {\n      get when() {\n        return e().options.toolbar.taskList;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.TaskList),\n          get children() {\n            return yn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(u, f(x, {\n      get when() {\n        return e().options.toolbar.link;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.Link),\n          get children() {\n            return wn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(u, f(x, {\n      get when() {\n        return e().options.toolbar.image;\n      },\n      get children() {\n        return f(y, {\n          onclick: () => t(m.Image),\n          get children() {\n            return Cn.cloneNode(!0);\n          }\n        });\n      }\n    }), null), p(u, f(x, {\n      get when() {\n        return e().options.toolbar.upload;\n      },\n      get children() {\n        return f(y, {\n          onclick: r,\n          get children() {\n            return [Ln.cloneNode(!0), o];\n          }\n        });\n      }\n    }), null), a;\n  })();\n}, Sn = `.ink{color:var(--ink-internal-color, inherit);display:flex;flex-direction:var(--ink-internal-flex-direction, column);gap:1rem;padding:var(--ink-internal-editor-padding, 0)}.ink .cm-tooltip{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);font-family:inherit;padding:.25rem}.ink .cm-tooltip.cm-tooltip-autocomplete ul{font-family:inherit}.ink .cm-tooltip.cm-tooltip-autocomplete ul li.ink-tooltip-option{border-radius:var(--ink-internal-border-radius);padding:.25rem}.ink .cm-tooltip.cm-tooltip-autocomplete ul li.ink-tooltip-option[aria-selected]{background-color:#96969640}.ink .cm-completionLabel{font-family:inherit}\n`, _n = /* @__PURE__ */ h(\"<style></style>\"), An = () => {\n  const [e] = O(), [n, t] = D(X(e()));\n  return Ee(() => {\n    t(X(e()));\n  }), me(() => {\n    const o = window.matchMedia(\"(prefers-color-scheme: dark)\"), r = (a) => {\n      const {\n        editor: l,\n        root: i\n      } = e();\n      if (i.isConnected) {\n        const s = be(e());\n        l.dispatch({\n          effects: s\n        }), t(X(e()));\n      } else\n        o.removeEventListener(\"change\", r);\n    };\n    o.addEventListener(\"change\", r);\n  }), (() => {\n    const o = _n.cloneNode(!0);\n    return p(o, () => `.ink {\n  ${n().join(`\n  `)}\n}`, null), p(o, Sn, null), o;\n  })();\n}, Bn = /* @__PURE__ */ h('<div class=\"ink\"></div>'), Nn = () => {\n  const [e, n] = O(), t = (o) => {\n    n(V(e(), {\n      root: o\n    }));\n  };\n  return (() => {\n    const o = Bn.cloneNode(!0);\n    return t(o), p(o, f(An, {}), null), p(o, f(sn, {}), null), p(o, f(x, {\n      get when() {\n        return e().options.interface.toolbar;\n      },\n      get children() {\n        return f(Mn, {});\n      }\n    }), null), p(o, f(dn, {}), null), o;\n  })();\n}, pe = ve(), Se = Te([() => pe, (e) => typeof e == \"function\" ? e(pe) : e]), Dn = (e) => f(Se.Provider, {\n  get value() {\n    return e.store;\n  },\n  get children() {\n    return e.children;\n  }\n}), O = () => He(Se), En = (e) => f(Dn, {\n  get store() {\n    return e.store;\n  },\n  get children() {\n    return f(Nn, {\n      get store() {\n        return e.store;\n      }\n    });\n  }\n}), Pn = ({ theme: e, decorator: n }) => {\n  const t = b.baseTheme(e), o = (l) => C.widget({\n    widget: l,\n    side: -1,\n    block: !0\n  }), r = (l) => {\n    const s = n(l).map((c) => o(c.widget).range(c.from, c.to));\n    return s.length > 0 ? W.of(s) : C.none;\n  }, a = Z.define({\n    create(l) {\n      return r(l);\n    },\n    update(l, i) {\n      return i.docChanged ? r(i.state) : l.map(i.changes);\n    },\n    provide(l) {\n      return b.decorations.from(l);\n    }\n  });\n  return [\n    t,\n    a\n  ];\n}, Un = (e) => e, qn = (e, n = {}) => {\n  const t = yt(n);\n  return ot(() => f(En, {\n    store: t\n  }), e), Jt(t);\n};\nexport {\n  E as Appearance,\n  $ as Extensions,\n  m as Markup,\n  R as PluginType,\n  qn as default,\n  Un as defineOptions,\n  Pn as extension,\n  qn as ink\n};\n", "import o from \"ink-mde\";\nimport { defineComponent as a, openBlock as r, createElementBlock as c } from \"vue\";\nconst p = a({\n  name: \"Ink\",\n  emits: [\"input\", \"update:modelValue\"],\n  props: {\n    options: {\n      type: Object\n    },\n    modelValue: {\n      type: String\n    },\n    value: {\n      type: String\n    },\n    version: {\n      type: Number,\n      default: () => 3,\n      validator: (t) => [2, 3].includes(t)\n    }\n  },\n  data() {\n    return { instance: void 0 };\n  },\n  watch: {\n    options: {\n      deep: !0,\n      handler(t, e) {\n        var s;\n        (s = this.instance) == null || s.reconfigure(t);\n      }\n    },\n    modelValue(t) {\n      var e, s;\n      ((e = this.instance) == null ? void 0 : e.doc()) !== t && ((s = this.instance) == null || s.update(t));\n    },\n    value(t) {\n      var e, s;\n      ((e = this.instance) == null ? void 0 : e.doc()) !== t && ((s = this.instance) == null || s.update(t));\n    }\n  },\n  computed: {\n    doc() {\n      return (this.version === 3 ? this.modelValue : this.value) || \"\";\n    }\n  },\n  methods: {\n    focus() {\n      var t;\n      (t = this.instance) == null || t.focus();\n    },\n    select(t) {\n      var e;\n      (e = this.instance) == null || e.select(t);\n    },\n    selections() {\n      var t;\n      return (t = this.instance) == null ? void 0 : t.selections();\n    }\n  },\n  mounted() {\n    var t;\n    this.instance = o(this.$refs.ink, {\n      ...this.options,\n      doc: this.doc,\n      hooks: {\n        ...(t = this.options) == null ? void 0 : t.hooks,\n        afterUpdate: (e) => {\n          var s, i;\n          this.version === 3 ? this.$emit(\"update:modelValue\", e) : this.$emit(\"input\", e), (i = (s = this.options) == null ? void 0 : s.hooks) != null && i.afterUpdate && this.options.hooks.afterUpdate(e);\n        }\n      }\n    }), this.$refs.ink.addEventListener(\"input\", (e) => {\n      e.stopPropagation();\n    }), this.instance.focus();\n  }\n}), d = (t, e) => {\n  const s = t.__vccOpts || t;\n  for (const [i, n] of e)\n    s[i] = n;\n  return s;\n}, u = { ref: \"ink\" };\nfunction h(t, e, s, i, n, l) {\n  return r(), c(\"div\", u, null, 512);\n}\nconst k = /* @__PURE__ */ d(p, [[\"render\", h]]);\nexport {\n  k as default\n};\n", "import d from \"./node_modules/ink-mde/dist/vue/ink.js\";export default d;"],
  "mappings": "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",
  "names": ["fn", "value", "fn", "fn", "fn", "fn", "k", "v", "fn", "children", "fn", "d", "children", "h", "k", "d", "off", "ln", "_", "add", "m", "from", "to", "off", "phrase", "empty", "_", "command", "isAdjacent", "_t", "at", "matching", "changes", "CodeMirror", "Pos", "vim", "defaultKeymap", "vimKey", "cmd", "_", "k", "add", "ctx", "command", "query", "macroModeState", "e", "findNext", "fn", "y", "tags", "i", "dir", "cm", "ln", "SearchState", "options", "searchState", "commandMatch", "numberRegex", "line", "replaceAll", "repeat", "p", "m", "d", "w", "h", "on", "from", "to", "matchMark", "m", "u", "k", "on", "p", "h"]
}
